
laba4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d34  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000007a  00800060  00001d34  00001dc8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000069b  008000da  008000da  00001e42  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001e42  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001ea0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000330  00000000  00000000  00001edc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003794  00000000  00000000  0000220c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000125b  00000000  00000000  000059a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002184  00000000  00000000  00006bfb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000874  00000000  00000000  00008d80  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000012ac  00000000  00000000  000095f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002edd  00000000  00000000  0000a8a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000328  00000000  00000000  0000d77d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 a7 03 	jmp	0x74e	; 0x74e <__vector_7>
      20:	0c 94 f5 08 	jmp	0x11ea	; 0x11ea <__vector_8>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e3       	ldi	r30, 0x34	; 52
      68:	fd e1       	ldi	r31, 0x1D	; 29
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 3d       	cpi	r26, 0xDA	; 218
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	aa ed       	ldi	r26, 0xDA	; 218
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 37       	cpi	r26, 0x75	; 117
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d6 08 	call	0x11ac	; 0x11ac <main>
      8a:	0c 94 98 0e 	jmp	0x1d30	; 0x1d30 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <nullifyDataArray>:
	"31",
};

void nullifyDataArray()
{
	data[0] = '0';
      92:	e5 e4       	ldi	r30, 0x45	; 69
      94:	f7 e0       	ldi	r31, 0x07	; 7
      96:	20 e3       	ldi	r18, 0x30	; 48
      98:	30 e0       	ldi	r19, 0x00	; 0
      9a:	31 83       	std	Z+1, r19	; 0x01
      9c:	20 83       	st	Z, r18
	data[1] = '1';
      9e:	81 e3       	ldi	r24, 0x31	; 49
      a0:	90 e0       	ldi	r25, 0x00	; 0
      a2:	93 83       	std	Z+3, r25	; 0x03
      a4:	82 83       	std	Z+2, r24	; 0x02
	data[2] = ' ';
      a6:	80 e2       	ldi	r24, 0x20	; 32
      a8:	90 e0       	ldi	r25, 0x00	; 0
      aa:	95 83       	std	Z+5, r25	; 0x05
      ac:	84 83       	std	Z+4, r24	; 0x04
	data[3] = 'J';
      ae:	4a e4       	ldi	r20, 0x4A	; 74
      b0:	50 e0       	ldi	r21, 0x00	; 0
      b2:	57 83       	std	Z+7, r21	; 0x07
      b4:	46 83       	std	Z+6, r20	; 0x06
	data[4] = 'a';
      b6:	41 e6       	ldi	r20, 0x61	; 97
      b8:	50 e0       	ldi	r21, 0x00	; 0
      ba:	51 87       	std	Z+9, r21	; 0x09
      bc:	40 87       	std	Z+8, r20	; 0x08
	data[5] = 'n';
      be:	4e e6       	ldi	r20, 0x6E	; 110
      c0:	50 e0       	ldi	r21, 0x00	; 0
      c2:	53 87       	std	Z+11, r21	; 0x0b
      c4:	42 87       	std	Z+10, r20	; 0x0a
	data[6] = ' ';
      c6:	95 87       	std	Z+13, r25	; 0x0d
      c8:	84 87       	std	Z+12, r24	; 0x0c
	data[7] = '2';
      ca:	82 e3       	ldi	r24, 0x32	; 50
      cc:	90 e0       	ldi	r25, 0x00	; 0
      ce:	97 87       	std	Z+15, r25	; 0x0f
      d0:	86 87       	std	Z+14, r24	; 0x0e
	data[8] = '0';
      d2:	31 8b       	std	Z+17, r19	; 0x11
      d4:	20 8b       	std	Z+16, r18	; 0x10
	data[9] = '2';
      d6:	93 8b       	std	Z+19, r25	; 0x13
      d8:	82 8b       	std	Z+18, r24	; 0x12
	data[10] = '4';
      da:	84 e3       	ldi	r24, 0x34	; 52
      dc:	90 e0       	ldi	r25, 0x00	; 0
      de:	95 8b       	std	Z+21, r25	; 0x15
      e0:	84 8b       	std	Z+20, r24	; 0x14
      e2:	08 95       	ret

000000e4 <setMonthDataArray>:
}

void setMonthDataArray()
{
	const char* monthStr = months[month];
      e4:	e0 91 da 00 	lds	r30, 0x00DA	; 0x8000da <__data_end>
      e8:	f0 91 db 00 	lds	r31, 0x00DB	; 0x8000db <__data_end+0x1>
      ec:	ee 0f       	add	r30, r30
      ee:	ff 1f       	adc	r31, r31
      f0:	e8 58       	subi	r30, 0x88	; 136
      f2:	ff 4f       	sbci	r31, 0xFF	; 255
      f4:	a0 81       	ld	r26, Z
      f6:	b1 81       	ldd	r27, Z+1	; 0x01
	for (int i = 0; i < 3; i++)
	{
		data[i + 3] = monthStr[i];
      f8:	e5 e4       	ldi	r30, 0x45	; 69
      fa:	f7 e0       	ldi	r31, 0x07	; 7
      fc:	8c 91       	ld	r24, X
      fe:	90 e0       	ldi	r25, 0x00	; 0
     100:	97 83       	std	Z+7, r25	; 0x07
     102:	86 83       	std	Z+6, r24	; 0x06
     104:	11 96       	adiw	r26, 0x01	; 1
     106:	8c 91       	ld	r24, X
     108:	11 97       	sbiw	r26, 0x01	; 1
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	91 87       	std	Z+9, r25	; 0x09
     10e:	80 87       	std	Z+8, r24	; 0x08
     110:	12 96       	adiw	r26, 0x02	; 2
     112:	8c 91       	ld	r24, X
     114:	90 e0       	ldi	r25, 0x00	; 0
     116:	93 87       	std	Z+11, r25	; 0x0b
     118:	82 87       	std	Z+10, r24	; 0x0a
     11a:	08 95       	ret

0000011c <clearDisplaySecondLine>:
	dataArrayToDisplaySecondLine(positionOnDisplay);
	showDisplaySecondLine();
}

void clearDisplaySecondLine()
{
     11c:	e5 e2       	ldi	r30, 0x25	; 37
     11e:	f7 e0       	ldi	r31, 0x07	; 7
     120:	25 e4       	ldi	r18, 0x45	; 69
     122:	37 e0       	ldi	r19, 0x07	; 7
	for (int i = 0; i < 16; i++)
	{
		displaySecondLine[i] = ' ';
     124:	80 e2       	ldi	r24, 0x20	; 32
     126:	90 e0       	ldi	r25, 0x00	; 0
     128:	81 93       	st	Z+, r24
     12a:	91 93       	st	Z+, r25
	showDisplaySecondLine();
}

void clearDisplaySecondLine()
{
	for (int i = 0; i < 16; i++)
     12c:	e2 17       	cp	r30, r18
     12e:	f3 07       	cpc	r31, r19
     130:	d9 f7       	brne	.-10     	; 0x128 <clearDisplaySecondLine+0xc>
	{
		displaySecondLine[i] = ' ';
	}
}
     132:	08 95       	ret

00000134 <dataArrayToDisplaySecondLine>:

void dataArrayToDisplaySecondLine(int positionOnDisplay)
{
     134:	e5 e4       	ldi	r30, 0x45	; 69
     136:	f7 e0       	ldi	r31, 0x07	; 7
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	dc 01       	movw	r26, r24
     13e:	ab 5d       	subi	r26, 0xDB	; 219
     140:	b8 4f       	sbci	r27, 0xF8	; 248
     142:	2b e5       	ldi	r18, 0x5B	; 91
     144:	37 e0       	ldi	r19, 0x07	; 7
	for(int i = 0; i<11; i++)
	{
		displaySecondLine[positionOnDisplay + i] = data[i];
     146:	81 91       	ld	r24, Z+
     148:	91 91       	ld	r25, Z+
     14a:	8d 93       	st	X+, r24
     14c:	9d 93       	st	X+, r25
	}
}

void dataArrayToDisplaySecondLine(int positionOnDisplay)
{
	for(int i = 0; i<11; i++)
     14e:	e2 17       	cp	r30, r18
     150:	f3 07       	cpc	r31, r19
     152:	c9 f7       	brne	.-14     	; 0x146 <dataArrayToDisplaySecondLine+0x12>
	{
		displaySecondLine[positionOnDisplay + i] = data[i];
	}
}
     154:	08 95       	ret

00000156 <showDisplaySecondLine>:

void showDisplaySecondLine()
{
     156:	0f 93       	push	r16
     158:	1f 93       	push	r17
     15a:	cf 93       	push	r28
     15c:	df 93       	push	r29
	LCDKursorPosihin(1, 0);
     15e:	60 e0       	ldi	r22, 0x00	; 0
     160:	81 e0       	ldi	r24, 0x01	; 1
     162:	0e 94 cb 08 	call	0x1196	; 0x1196 <LCDKursorPosihin>
     166:	c5 e2       	ldi	r28, 0x25	; 37
     168:	d7 e0       	ldi	r29, 0x07	; 7
     16a:	05 e4       	ldi	r16, 0x45	; 69
     16c:	17 e0       	ldi	r17, 0x07	; 7
	for (int i = 0; i < 16; i++)
	{
		LCDWriteByte(LCD_DR, displaySecondLine[i]);
     16e:	68 81       	ld	r22, Y
     170:	22 96       	adiw	r28, 0x02	; 2
     172:	81 e0       	ldi	r24, 0x01	; 1
     174:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
}

void showDisplaySecondLine()
{
	LCDKursorPosihin(1, 0);
	for (int i = 0; i < 16; i++)
     178:	c0 17       	cp	r28, r16
     17a:	d1 07       	cpc	r29, r17
     17c:	c1 f7       	brne	.-16     	; 0x16e <showDisplaySecondLine+0x18>
	{
		LCDWriteByte(LCD_DR, displaySecondLine[i]);
	}
}
     17e:	df 91       	pop	r29
     180:	cf 91       	pop	r28
     182:	1f 91       	pop	r17
     184:	0f 91       	pop	r16
     186:	08 95       	ret

00000188 <displayData>:
		data[i + 3] = monthStr[i];
	}
}

void displayData(int positionOnDisplay)
{
     188:	cf 93       	push	r28
     18a:	df 93       	push	r29
     18c:	ec 01       	movw	r28, r24
	clearDisplaySecondLine();
     18e:	0e 94 8e 00 	call	0x11c	; 0x11c <clearDisplaySecondLine>
	dataArrayToDisplaySecondLine(positionOnDisplay);
     192:	ce 01       	movw	r24, r28
     194:	0e 94 9a 00 	call	0x134	; 0x134 <dataArrayToDisplaySecondLine>
	showDisplaySecondLine();
     198:	0e 94 ab 00 	call	0x156	; 0x156 <showDisplaySecondLine>
}
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	08 95       	ret

000001a2 <getYearFromData>:
		LCDWriteByte(LCD_DR, displaySecondLine[i]);
	}
}

int getYearFromData()
{
     1a2:	cf 93       	push	r28
     1a4:	df 93       	push	r29
     1a6:	cd b7       	in	r28, 0x3d	; 61
     1a8:	de b7       	in	r29, 0x3e	; 62
     1aa:	27 97       	sbiw	r28, 0x07	; 7
     1ac:	0f b6       	in	r0, 0x3f	; 63
     1ae:	f8 94       	cli
     1b0:	de bf       	out	0x3e, r29	; 62
     1b2:	0f be       	out	0x3f, r0	; 63
     1b4:	cd bf       	out	0x3d, r28	; 61
	char str[5] = "";
     1b6:	fe 01       	movw	r30, r28
     1b8:	33 96       	adiw	r30, 0x03	; 3
     1ba:	83 e0       	ldi	r24, 0x03	; 3
     1bc:	df 01       	movw	r26, r30
     1be:	1d 92       	st	X+, r1
     1c0:	8a 95       	dec	r24
     1c2:	e9 f7       	brne	.-6      	; 0x1be <getYearFromData+0x1c>
	for (int i = 0; i < 4; i++)
		str[i] = data[7 + i];
     1c4:	e5 e4       	ldi	r30, 0x45	; 69
     1c6:	f7 e0       	ldi	r31, 0x07	; 7
     1c8:	86 85       	ldd	r24, Z+14	; 0x0e
     1ca:	89 83       	std	Y+1, r24	; 0x01
     1cc:	80 89       	ldd	r24, Z+16	; 0x10
     1ce:	8a 83       	std	Y+2, r24	; 0x02
     1d0:	82 89       	ldd	r24, Z+18	; 0x12
     1d2:	8b 83       	std	Y+3, r24	; 0x03
     1d4:	84 89       	ldd	r24, Z+20	; 0x14
     1d6:	8c 83       	std	Y+4, r24	; 0x04
	str[4] = '\0';
     1d8:	1d 82       	std	Y+5, r1	; 0x05
	
	char* endPtr;
	int year = strtol(str, &endPtr, 10);
     1da:	4a e0       	ldi	r20, 0x0A	; 10
     1dc:	50 e0       	ldi	r21, 0x00	; 0
     1de:	be 01       	movw	r22, r28
     1e0:	6a 5f       	subi	r22, 0xFA	; 250
     1e2:	7f 4f       	sbci	r23, 0xFF	; 255
     1e4:	ce 01       	movw	r24, r28
     1e6:	01 96       	adiw	r24, 0x01	; 1
     1e8:	0e 94 40 0a 	call	0x1480	; 0x1480 <strtol>
	if (*endPtr != '\0') return 0;
     1ec:	ee 81       	ldd	r30, Y+6	; 0x06
     1ee:	ff 81       	ldd	r31, Y+7	; 0x07
     1f0:	20 81       	ld	r18, Z
     1f2:	21 11       	cpse	r18, r1
     1f4:	02 c0       	rjmp	.+4      	; 0x1fa <getYearFromData+0x58>
	
	return year;
     1f6:	cb 01       	movw	r24, r22
     1f8:	02 c0       	rjmp	.+4      	; 0x1fe <getYearFromData+0x5c>
		str[i] = data[7 + i];
	str[4] = '\0';
	
	char* endPtr;
	int year = strtol(str, &endPtr, 10);
	if (*endPtr != '\0') return 0;
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	90 e0       	ldi	r25, 0x00	; 0
	
	return year;
}
     1fe:	27 96       	adiw	r28, 0x07	; 7
     200:	0f b6       	in	r0, 0x3f	; 63
     202:	f8 94       	cli
     204:	de bf       	out	0x3e, r29	; 62
     206:	0f be       	out	0x3f, r0	; 63
     208:	cd bf       	out	0x3d, r28	; 61
     20a:	df 91       	pop	r29
     20c:	cf 91       	pop	r28
     20e:	08 95       	ret

00000210 <isLeapYear>:

bool isLeapYear()
{
	int year = getYearFromData();
     210:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <getYearFromData>
     214:	9c 01       	movw	r18, r24
	if (year % 4 != 0) return false;
     216:	83 70       	andi	r24, 0x03	; 3
     218:	99 27       	eor	r25, r25
     21a:	89 2b       	or	r24, r25
     21c:	a9 f4       	brne	.+42     	; 0x248 <isLeapYear+0x38>
	
	return (year % 100 == 0 && year % 400 != 0) ? false : true;
     21e:	c9 01       	movw	r24, r18
     220:	64 e6       	ldi	r22, 0x64	; 100
     222:	70 e0       	ldi	r23, 0x00	; 0
     224:	0e 94 18 0a 	call	0x1430	; 0x1430 <__divmodhi4>
     228:	89 2b       	or	r24, r25
     22a:	59 f4       	brne	.+22     	; 0x242 <isLeapYear+0x32>
     22c:	c9 01       	movw	r24, r18
     22e:	60 e9       	ldi	r22, 0x90	; 144
     230:	71 e0       	ldi	r23, 0x01	; 1
     232:	0e 94 18 0a 	call	0x1430	; 0x1430 <__divmodhi4>
     236:	21 e0       	ldi	r18, 0x01	; 1
     238:	89 2b       	or	r24, r25
     23a:	09 f0       	breq	.+2      	; 0x23e <isLeapYear+0x2e>
     23c:	20 e0       	ldi	r18, 0x00	; 0
     23e:	82 2f       	mov	r24, r18
     240:	01 c0       	rjmp	.+2      	; 0x244 <isLeapYear+0x34>
     242:	81 e0       	ldi	r24, 0x01	; 1
     244:	81 70       	andi	r24, 0x01	; 1
     246:	08 95       	ret
}

bool isLeapYear()
{
	int year = getYearFromData();
	if (year % 4 != 0) return false;
     248:	80 e0       	ldi	r24, 0x00	; 0
	
	return (year % 100 == 0 && year % 400 != 0) ? false : true;
}
     24a:	08 95       	ret

0000024c <findDayMonth>:

const char* findDayMonth()
{
	return (month == 1 && isLeapYear()) ? "29" : days[month];
     24c:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     250:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     254:	01 97       	sbiw	r24, 0x01	; 1
     256:	21 f4       	brne	.+8      	; 0x260 <findDayMonth+0x14>
     258:	0e 94 08 01 	call	0x210	; 0x210 <isLeapYear>
     25c:	81 11       	cpse	r24, r1
     25e:	0b c0       	rjmp	.+22     	; 0x276 <findDayMonth+0x2a>
     260:	e0 91 da 00 	lds	r30, 0x00DA	; 0x8000da <__data_end>
     264:	f0 91 db 00 	lds	r31, 0x00DB	; 0x8000db <__data_end+0x1>
     268:	ee 0f       	add	r30, r30
     26a:	ff 1f       	adc	r31, r31
     26c:	e0 5a       	subi	r30, 0xA0	; 160
     26e:	ff 4f       	sbci	r31, 0xFF	; 255
     270:	80 81       	ld	r24, Z
     272:	91 81       	ldd	r25, Z+1	; 0x01
     274:	08 95       	ret
     276:	81 e9       	ldi	r24, 0x91	; 145
     278:	90 e0       	ldi	r25, 0x00	; 0
}
     27a:	08 95       	ret

0000027c <computeDay>:

void computeDay()
{
     27c:	0f 93       	push	r16
     27e:	1f 93       	push	r17
     280:	cf 93       	push	r28
     282:	df 93       	push	r29
     284:	00 d0       	rcall	.+0      	; 0x286 <computeDay+0xa>
     286:	00 d0       	rcall	.+0      	; 0x288 <computeDay+0xc>
     288:	1f 92       	push	r1
     28a:	cd b7       	in	r28, 0x3d	; 61
     28c:	de b7       	in	r29, 0x3e	; 62
	const char* day;
	day = findDayMonth();
     28e:	0e 94 26 01 	call	0x24c	; 0x24c <findDayMonth>
	data[1]++;
     292:	e5 e4       	ldi	r30, 0x45	; 69
     294:	f7 e0       	ldi	r31, 0x07	; 7
     296:	22 81       	ldd	r18, Z+2	; 0x02
     298:	33 81       	ldd	r19, Z+3	; 0x03
     29a:	2f 5f       	subi	r18, 0xFF	; 255
     29c:	3f 4f       	sbci	r19, 0xFF	; 255
     29e:	33 83       	std	Z+3, r19	; 0x03
     2a0:	22 83       	std	Z+2, r18	; 0x02
	if((data[1] > day[1]) && data[0] == day[0])
     2a2:	fc 01       	movw	r30, r24
     2a4:	41 81       	ldd	r20, Z+1	; 0x01
     2a6:	50 e0       	ldi	r21, 0x00	; 0
     2a8:	42 17       	cp	r20, r18
     2aa:	53 07       	cpc	r21, r19
     2ac:	0c f0       	brlt	.+2      	; 0x2b0 <computeDay+0x34>
     2ae:	56 c0       	rjmp	.+172    	; 0x35c <computeDay+0xe0>
     2b0:	80 81       	ld	r24, Z
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	40 91 45 07 	lds	r20, 0x0745	; 0x800745 <data>
     2b8:	50 91 46 07 	lds	r21, 0x0746	; 0x800746 <data+0x1>
     2bc:	48 17       	cp	r20, r24
     2be:	59 07       	cpc	r21, r25
     2c0:	09 f0       	breq	.+2      	; 0x2c4 <computeDay+0x48>
     2c2:	4c c0       	rjmp	.+152    	; 0x35c <computeDay+0xe0>
	{
		data[0] = '0';
     2c4:	e5 e4       	ldi	r30, 0x45	; 69
     2c6:	f7 e0       	ldi	r31, 0x07	; 7
     2c8:	80 e3       	ldi	r24, 0x30	; 48
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	91 83       	std	Z+1, r25	; 0x01
     2ce:	80 83       	st	Z, r24
		data[1] = '1';
     2d0:	81 e3       	ldi	r24, 0x31	; 49
     2d2:	90 e0       	ldi	r25, 0x00	; 0
     2d4:	93 83       	std	Z+3, r25	; 0x03
     2d6:	82 83       	std	Z+2, r24	; 0x02
		month++;
     2d8:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__data_end>
     2dc:	90 91 db 00 	lds	r25, 0x00DB	; 0x8000db <__data_end+0x1>
     2e0:	01 96       	adiw	r24, 0x01	; 1
		if (month == 12)
     2e2:	8c 30       	cpi	r24, 0x0C	; 12
     2e4:	91 05       	cpc	r25, r1
     2e6:	29 f0       	breq	.+10     	; 0x2f2 <computeDay+0x76>
	data[1]++;
	if((data[1] > day[1]) && data[0] == day[0])
	{
		data[0] = '0';
		data[1] = '1';
		month++;
     2e8:	90 93 db 00 	sts	0x00DB, r25	; 0x8000db <__data_end+0x1>
     2ec:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__data_end>
     2f0:	32 c0       	rjmp	.+100    	; 0x356 <computeDay+0xda>
		if (month == 12)
		{
			month = 0;
     2f2:	10 92 db 00 	sts	0x00DB, r1	; 0x8000db <__data_end+0x1>
     2f6:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__data_end>
			int year = getYearFromData();
     2fa:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <getYearFromData>
			char str[5];
			year++;
     2fe:	8c 01       	movw	r16, r24
     300:	0f 5f       	subi	r16, 0xFF	; 255
     302:	1f 4f       	sbci	r17, 0xFF	; 255
			sprintf(str, "%d", year);
     304:	1f 93       	push	r17
     306:	0f 93       	push	r16
     308:	84 e9       	ldi	r24, 0x94	; 148
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	9f 93       	push	r25
     30e:	8f 93       	push	r24
     310:	ce 01       	movw	r24, r28
     312:	01 96       	adiw	r24, 0x01	; 1
     314:	9f 93       	push	r25
     316:	8f 93       	push	r24
     318:	0e 94 5f 0b 	call	0x16be	; 0x16be <sprintf>
			for (int i = 0; i < 4; i++)
			data[i+7] = str[i];
     31c:	e5 e4       	ldi	r30, 0x45	; 69
     31e:	f7 e0       	ldi	r31, 0x07	; 7
     320:	89 81       	ldd	r24, Y+1	; 0x01
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	97 87       	std	Z+15, r25	; 0x0f
     326:	86 87       	std	Z+14, r24	; 0x0e
     328:	8a 81       	ldd	r24, Y+2	; 0x02
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	91 8b       	std	Z+17, r25	; 0x11
     32e:	80 8b       	std	Z+16, r24	; 0x10
     330:	8b 81       	ldd	r24, Y+3	; 0x03
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	93 8b       	std	Z+19, r25	; 0x13
     336:	82 8b       	std	Z+18, r24	; 0x12
     338:	8c 81       	ldd	r24, Y+4	; 0x04
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	95 8b       	std	Z+21, r25	; 0x15
     33e:	84 8b       	std	Z+20, r24	; 0x14
			if (year > 9999)
     340:	0f 90       	pop	r0
     342:	0f 90       	pop	r0
     344:	0f 90       	pop	r0
     346:	0f 90       	pop	r0
     348:	0f 90       	pop	r0
     34a:	0f 90       	pop	r0
     34c:	00 31       	cpi	r16, 0x10	; 16
     34e:	17 42       	sbci	r17, 0x27	; 39
     350:	14 f0       	brlt	.+4      	; 0x356 <computeDay+0xda>
			nullifyDataArray();
     352:	0e 94 49 00 	call	0x92	; 0x92 <nullifyDataArray>
		}
		setMonthDataArray();
     356:	0e 94 72 00 	call	0xe4	; 0xe4 <setMonthDataArray>
     35a:	0e c0       	rjmp	.+28     	; 0x378 <computeDay+0xfc>
	}
	else if (data[1] > '9')
     35c:	2a 33       	cpi	r18, 0x3A	; 58
     35e:	31 05       	cpc	r19, r1
     360:	5c f0       	brlt	.+22     	; 0x378 <computeDay+0xfc>
	{
		data[0]++;
     362:	e5 e4       	ldi	r30, 0x45	; 69
     364:	f7 e0       	ldi	r31, 0x07	; 7
     366:	80 81       	ld	r24, Z
     368:	91 81       	ldd	r25, Z+1	; 0x01
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	91 83       	std	Z+1, r25	; 0x01
     36e:	80 83       	st	Z, r24
		data[1] = '0';
     370:	80 e3       	ldi	r24, 0x30	; 48
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	93 83       	std	Z+3, r25	; 0x03
     376:	82 83       	std	Z+2, r24	; 0x02
		
	}
}
     378:	0f 90       	pop	r0
     37a:	0f 90       	pop	r0
     37c:	0f 90       	pop	r0
     37e:	0f 90       	pop	r0
     380:	0f 90       	pop	r0
     382:	df 91       	pop	r29
     384:	cf 91       	pop	r28
     386:	1f 91       	pop	r17
     388:	0f 91       	pop	r16
     38a:	08 95       	ret

0000038c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     38c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     38e:	03 96       	adiw	r24, 0x03	; 3
     390:	92 83       	std	Z+2, r25	; 0x02
     392:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     394:	2f ef       	ldi	r18, 0xFF	; 255
     396:	3f ef       	ldi	r19, 0xFF	; 255
     398:	34 83       	std	Z+4, r19	; 0x04
     39a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     39c:	96 83       	std	Z+6, r25	; 0x06
     39e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3a0:	90 87       	std	Z+8, r25	; 0x08
     3a2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     3a4:	10 82       	st	Z, r1
     3a6:	08 95       	ret

000003a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     3a8:	fc 01       	movw	r30, r24
     3aa:	11 86       	std	Z+9, r1	; 0x09
     3ac:	10 86       	std	Z+8, r1	; 0x08
     3ae:	08 95       	ret

000003b0 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3b0:	cf 93       	push	r28
     3b2:	df 93       	push	r29
     3b4:	9c 01       	movw	r18, r24
     3b6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     3b8:	dc 01       	movw	r26, r24
     3ba:	11 96       	adiw	r26, 0x01	; 1
     3bc:	cd 91       	ld	r28, X+
     3be:	dc 91       	ld	r29, X
     3c0:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3c2:	d3 83       	std	Z+3, r29	; 0x03
     3c4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3c6:	8c 81       	ldd	r24, Y+4	; 0x04
     3c8:	9d 81       	ldd	r25, Y+5	; 0x05
     3ca:	95 83       	std	Z+5, r25	; 0x05
     3cc:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3ce:	8c 81       	ldd	r24, Y+4	; 0x04
     3d0:	9d 81       	ldd	r25, Y+5	; 0x05
     3d2:	dc 01       	movw	r26, r24
     3d4:	13 96       	adiw	r26, 0x03	; 3
     3d6:	7c 93       	st	X, r23
     3d8:	6e 93       	st	-X, r22
     3da:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     3dc:	7d 83       	std	Y+5, r23	; 0x05
     3de:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     3e0:	31 87       	std	Z+9, r19	; 0x09
     3e2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3e4:	f9 01       	movw	r30, r18
     3e6:	80 81       	ld	r24, Z
     3e8:	8f 5f       	subi	r24, 0xFF	; 255
     3ea:	80 83       	st	Z, r24
}
     3ec:	df 91       	pop	r29
     3ee:	cf 91       	pop	r28
     3f0:	08 95       	ret

000003f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3f2:	cf 93       	push	r28
     3f4:	df 93       	push	r29
     3f6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     3f8:	48 81       	ld	r20, Y
     3fa:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3fc:	4f 3f       	cpi	r20, 0xFF	; 255
     3fe:	2f ef       	ldi	r18, 0xFF	; 255
     400:	52 07       	cpc	r21, r18
     402:	21 f4       	brne	.+8      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     404:	fc 01       	movw	r30, r24
     406:	a7 81       	ldd	r26, Z+7	; 0x07
     408:	b0 85       	ldd	r27, Z+8	; 0x08
     40a:	0d c0       	rjmp	.+26     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     40c:	dc 01       	movw	r26, r24
     40e:	13 96       	adiw	r26, 0x03	; 3
     410:	01 c0       	rjmp	.+2      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
     412:	df 01       	movw	r26, r30
     414:	12 96       	adiw	r26, 0x02	; 2
     416:	ed 91       	ld	r30, X+
     418:	fc 91       	ld	r31, X
     41a:	13 97       	sbiw	r26, 0x03	; 3
     41c:	20 81       	ld	r18, Z
     41e:	31 81       	ldd	r19, Z+1	; 0x01
     420:	42 17       	cp	r20, r18
     422:	53 07       	cpc	r21, r19
     424:	b0 f7       	brcc	.-20     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     426:	12 96       	adiw	r26, 0x02	; 2
     428:	ed 91       	ld	r30, X+
     42a:	fc 91       	ld	r31, X
     42c:	13 97       	sbiw	r26, 0x03	; 3
     42e:	fb 83       	std	Y+3, r31	; 0x03
     430:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     432:	d5 83       	std	Z+5, r29	; 0x05
     434:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     436:	bd 83       	std	Y+5, r27	; 0x05
     438:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     43a:	13 96       	adiw	r26, 0x03	; 3
     43c:	dc 93       	st	X, r29
     43e:	ce 93       	st	-X, r28
     440:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     442:	99 87       	std	Y+9, r25	; 0x09
     444:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     446:	fc 01       	movw	r30, r24
     448:	20 81       	ld	r18, Z
     44a:	2f 5f       	subi	r18, 0xFF	; 255
     44c:	20 83       	st	Z, r18
}
     44e:	df 91       	pop	r29
     450:	cf 91       	pop	r28
     452:	08 95       	ret

00000454 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     454:	cf 93       	push	r28
     456:	df 93       	push	r29
     458:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     45a:	a0 85       	ldd	r26, Z+8	; 0x08
     45c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     45e:	c2 81       	ldd	r28, Z+2	; 0x02
     460:	d3 81       	ldd	r29, Z+3	; 0x03
     462:	84 81       	ldd	r24, Z+4	; 0x04
     464:	95 81       	ldd	r25, Z+5	; 0x05
     466:	9d 83       	std	Y+5, r25	; 0x05
     468:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     46a:	c4 81       	ldd	r28, Z+4	; 0x04
     46c:	d5 81       	ldd	r29, Z+5	; 0x05
     46e:	82 81       	ldd	r24, Z+2	; 0x02
     470:	93 81       	ldd	r25, Z+3	; 0x03
     472:	9b 83       	std	Y+3, r25	; 0x03
     474:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     476:	11 96       	adiw	r26, 0x01	; 1
     478:	8d 91       	ld	r24, X+
     47a:	9c 91       	ld	r25, X
     47c:	12 97       	sbiw	r26, 0x02	; 2
     47e:	e8 17       	cp	r30, r24
     480:	f9 07       	cpc	r31, r25
     482:	31 f4       	brne	.+12     	; 0x490 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     484:	84 81       	ldd	r24, Z+4	; 0x04
     486:	95 81       	ldd	r25, Z+5	; 0x05
     488:	12 96       	adiw	r26, 0x02	; 2
     48a:	9c 93       	st	X, r25
     48c:	8e 93       	st	-X, r24
     48e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     490:	11 86       	std	Z+9, r1	; 0x09
     492:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     494:	8c 91       	ld	r24, X
     496:	81 50       	subi	r24, 0x01	; 1
     498:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     49a:	8c 91       	ld	r24, X
}
     49c:	df 91       	pop	r29
     49e:	cf 91       	pop	r28
     4a0:	08 95       	ret

000004a2 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     4a2:	31 e1       	ldi	r19, 0x11	; 17
     4a4:	fc 01       	movw	r30, r24
     4a6:	30 83       	st	Z, r19
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	22 e2       	ldi	r18, 0x22	; 34
     4ac:	20 83       	st	Z, r18
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	a3 e3       	ldi	r26, 0x33	; 51
     4b2:	a0 83       	st	Z, r26
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	60 83       	st	Z, r22
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	70 83       	st	Z, r23
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	10 82       	st	Z, r1
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	60 e8       	ldi	r22, 0x80	; 128
     4c4:	60 83       	st	Z, r22
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	10 82       	st	Z, r1
     4ca:	31 97       	sbiw	r30, 0x01	; 1
     4cc:	62 e0       	ldi	r22, 0x02	; 2
     4ce:	60 83       	st	Z, r22
     4d0:	31 97       	sbiw	r30, 0x01	; 1
     4d2:	63 e0       	ldi	r22, 0x03	; 3
     4d4:	60 83       	st	Z, r22
     4d6:	31 97       	sbiw	r30, 0x01	; 1
     4d8:	64 e0       	ldi	r22, 0x04	; 4
     4da:	60 83       	st	Z, r22
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	65 e0       	ldi	r22, 0x05	; 5
     4e0:	60 83       	st	Z, r22
     4e2:	31 97       	sbiw	r30, 0x01	; 1
     4e4:	66 e0       	ldi	r22, 0x06	; 6
     4e6:	60 83       	st	Z, r22
     4e8:	31 97       	sbiw	r30, 0x01	; 1
     4ea:	67 e0       	ldi	r22, 0x07	; 7
     4ec:	60 83       	st	Z, r22
     4ee:	31 97       	sbiw	r30, 0x01	; 1
     4f0:	68 e0       	ldi	r22, 0x08	; 8
     4f2:	60 83       	st	Z, r22
     4f4:	31 97       	sbiw	r30, 0x01	; 1
     4f6:	69 e0       	ldi	r22, 0x09	; 9
     4f8:	60 83       	st	Z, r22
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	60 e1       	ldi	r22, 0x10	; 16
     4fe:	60 83       	st	Z, r22
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	30 83       	st	Z, r19
     504:	31 97       	sbiw	r30, 0x01	; 1
     506:	32 e1       	ldi	r19, 0x12	; 18
     508:	30 83       	st	Z, r19
     50a:	31 97       	sbiw	r30, 0x01	; 1
     50c:	33 e1       	ldi	r19, 0x13	; 19
     50e:	30 83       	st	Z, r19
     510:	31 97       	sbiw	r30, 0x01	; 1
     512:	34 e1       	ldi	r19, 0x14	; 20
     514:	30 83       	st	Z, r19
     516:	31 97       	sbiw	r30, 0x01	; 1
     518:	35 e1       	ldi	r19, 0x15	; 21
     51a:	30 83       	st	Z, r19
     51c:	31 97       	sbiw	r30, 0x01	; 1
     51e:	36 e1       	ldi	r19, 0x16	; 22
     520:	30 83       	st	Z, r19
     522:	31 97       	sbiw	r30, 0x01	; 1
     524:	37 e1       	ldi	r19, 0x17	; 23
     526:	30 83       	st	Z, r19
     528:	31 97       	sbiw	r30, 0x01	; 1
     52a:	38 e1       	ldi	r19, 0x18	; 24
     52c:	30 83       	st	Z, r19
     52e:	31 97       	sbiw	r30, 0x01	; 1
     530:	39 e1       	ldi	r19, 0x19	; 25
     532:	30 83       	st	Z, r19
     534:	31 97       	sbiw	r30, 0x01	; 1
     536:	30 e2       	ldi	r19, 0x20	; 32
     538:	30 83       	st	Z, r19
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	31 e2       	ldi	r19, 0x21	; 33
     53e:	30 83       	st	Z, r19
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	20 83       	st	Z, r18
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	23 e2       	ldi	r18, 0x23	; 35
     548:	20 83       	st	Z, r18
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	40 83       	st	Z, r20
     54e:	31 97       	sbiw	r30, 0x01	; 1
     550:	50 83       	st	Z, r21
     552:	31 97       	sbiw	r30, 0x01	; 1
     554:	26 e2       	ldi	r18, 0x26	; 38
     556:	20 83       	st	Z, r18
     558:	31 97       	sbiw	r30, 0x01	; 1
     55a:	27 e2       	ldi	r18, 0x27	; 39
     55c:	20 83       	st	Z, r18
     55e:	31 97       	sbiw	r30, 0x01	; 1
     560:	28 e2       	ldi	r18, 0x28	; 40
     562:	20 83       	st	Z, r18
     564:	31 97       	sbiw	r30, 0x01	; 1
     566:	29 e2       	ldi	r18, 0x29	; 41
     568:	20 83       	st	Z, r18
     56a:	31 97       	sbiw	r30, 0x01	; 1
     56c:	20 e3       	ldi	r18, 0x30	; 48
     56e:	20 83       	st	Z, r18
     570:	31 97       	sbiw	r30, 0x01	; 1
     572:	21 e3       	ldi	r18, 0x31	; 49
     574:	20 83       	st	Z, r18
     576:	86 97       	sbiw	r24, 0x26	; 38
     578:	08 95       	ret

0000057a <xPortStartScheduler>:
     57a:	1b bc       	out	0x2b, r1	; 43
     57c:	8e e0       	ldi	r24, 0x0E	; 14
     57e:	8a bd       	out	0x2a, r24	; 42
     580:	8b e0       	ldi	r24, 0x0B	; 11
     582:	8e bd       	out	0x2e, r24	; 46
     584:	89 b7       	in	r24, 0x39	; 57
     586:	80 61       	ori	r24, 0x10	; 16
     588:	89 bf       	out	0x39, r24	; 57
     58a:	a0 91 1f 07 	lds	r26, 0x071F	; 0x80071f <pxCurrentTCB>
     58e:	b0 91 20 07 	lds	r27, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     592:	cd 91       	ld	r28, X+
     594:	cd bf       	out	0x3d, r28	; 61
     596:	dd 91       	ld	r29, X+
     598:	de bf       	out	0x3e, r29	; 62
     59a:	ff 91       	pop	r31
     59c:	ef 91       	pop	r30
     59e:	df 91       	pop	r29
     5a0:	cf 91       	pop	r28
     5a2:	bf 91       	pop	r27
     5a4:	af 91       	pop	r26
     5a6:	9f 91       	pop	r25
     5a8:	8f 91       	pop	r24
     5aa:	7f 91       	pop	r23
     5ac:	6f 91       	pop	r22
     5ae:	5f 91       	pop	r21
     5b0:	4f 91       	pop	r20
     5b2:	3f 91       	pop	r19
     5b4:	2f 91       	pop	r18
     5b6:	1f 91       	pop	r17
     5b8:	0f 91       	pop	r16
     5ba:	ff 90       	pop	r15
     5bc:	ef 90       	pop	r14
     5be:	df 90       	pop	r13
     5c0:	cf 90       	pop	r12
     5c2:	bf 90       	pop	r11
     5c4:	af 90       	pop	r10
     5c6:	9f 90       	pop	r9
     5c8:	8f 90       	pop	r8
     5ca:	7f 90       	pop	r7
     5cc:	6f 90       	pop	r6
     5ce:	5f 90       	pop	r5
     5d0:	4f 90       	pop	r4
     5d2:	3f 90       	pop	r3
     5d4:	2f 90       	pop	r2
     5d6:	1f 90       	pop	r1
     5d8:	0f 90       	pop	r0
     5da:	0f be       	out	0x3f, r0	; 63
     5dc:	0f 90       	pop	r0
     5de:	08 95       	ret
     5e0:	81 e0       	ldi	r24, 0x01	; 1
     5e2:	08 95       	ret

000005e4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5e4:	0f 92       	push	r0
     5e6:	0f b6       	in	r0, 0x3f	; 63
     5e8:	f8 94       	cli
     5ea:	0f 92       	push	r0
     5ec:	1f 92       	push	r1
     5ee:	11 24       	eor	r1, r1
     5f0:	2f 92       	push	r2
     5f2:	3f 92       	push	r3
     5f4:	4f 92       	push	r4
     5f6:	5f 92       	push	r5
     5f8:	6f 92       	push	r6
     5fa:	7f 92       	push	r7
     5fc:	8f 92       	push	r8
     5fe:	9f 92       	push	r9
     600:	af 92       	push	r10
     602:	bf 92       	push	r11
     604:	cf 92       	push	r12
     606:	df 92       	push	r13
     608:	ef 92       	push	r14
     60a:	ff 92       	push	r15
     60c:	0f 93       	push	r16
     60e:	1f 93       	push	r17
     610:	2f 93       	push	r18
     612:	3f 93       	push	r19
     614:	4f 93       	push	r20
     616:	5f 93       	push	r21
     618:	6f 93       	push	r22
     61a:	7f 93       	push	r23
     61c:	8f 93       	push	r24
     61e:	9f 93       	push	r25
     620:	af 93       	push	r26
     622:	bf 93       	push	r27
     624:	cf 93       	push	r28
     626:	df 93       	push	r29
     628:	ef 93       	push	r30
     62a:	ff 93       	push	r31
     62c:	a0 91 1f 07 	lds	r26, 0x071F	; 0x80071f <pxCurrentTCB>
     630:	b0 91 20 07 	lds	r27, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     634:	0d b6       	in	r0, 0x3d	; 61
     636:	0d 92       	st	X+, r0
     638:	0e b6       	in	r0, 0x3e	; 62
     63a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     63c:	0e 94 08 08 	call	0x1010	; 0x1010 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     640:	a0 91 1f 07 	lds	r26, 0x071F	; 0x80071f <pxCurrentTCB>
     644:	b0 91 20 07 	lds	r27, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     648:	cd 91       	ld	r28, X+
     64a:	cd bf       	out	0x3d, r28	; 61
     64c:	dd 91       	ld	r29, X+
     64e:	de bf       	out	0x3e, r29	; 62
     650:	ff 91       	pop	r31
     652:	ef 91       	pop	r30
     654:	df 91       	pop	r29
     656:	cf 91       	pop	r28
     658:	bf 91       	pop	r27
     65a:	af 91       	pop	r26
     65c:	9f 91       	pop	r25
     65e:	8f 91       	pop	r24
     660:	7f 91       	pop	r23
     662:	6f 91       	pop	r22
     664:	5f 91       	pop	r21
     666:	4f 91       	pop	r20
     668:	3f 91       	pop	r19
     66a:	2f 91       	pop	r18
     66c:	1f 91       	pop	r17
     66e:	0f 91       	pop	r16
     670:	ff 90       	pop	r15
     672:	ef 90       	pop	r14
     674:	df 90       	pop	r13
     676:	cf 90       	pop	r12
     678:	bf 90       	pop	r11
     67a:	af 90       	pop	r10
     67c:	9f 90       	pop	r9
     67e:	8f 90       	pop	r8
     680:	7f 90       	pop	r7
     682:	6f 90       	pop	r6
     684:	5f 90       	pop	r5
     686:	4f 90       	pop	r4
     688:	3f 90       	pop	r3
     68a:	2f 90       	pop	r2
     68c:	1f 90       	pop	r1
     68e:	0f 90       	pop	r0
     690:	0f be       	out	0x3f, r0	; 63
     692:	0f 90       	pop	r0

	asm volatile ( "ret" );
     694:	08 95       	ret

00000696 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     696:	0f 92       	push	r0
     698:	0f b6       	in	r0, 0x3f	; 63
     69a:	f8 94       	cli
     69c:	0f 92       	push	r0
     69e:	1f 92       	push	r1
     6a0:	11 24       	eor	r1, r1
     6a2:	2f 92       	push	r2
     6a4:	3f 92       	push	r3
     6a6:	4f 92       	push	r4
     6a8:	5f 92       	push	r5
     6aa:	6f 92       	push	r6
     6ac:	7f 92       	push	r7
     6ae:	8f 92       	push	r8
     6b0:	9f 92       	push	r9
     6b2:	af 92       	push	r10
     6b4:	bf 92       	push	r11
     6b6:	cf 92       	push	r12
     6b8:	df 92       	push	r13
     6ba:	ef 92       	push	r14
     6bc:	ff 92       	push	r15
     6be:	0f 93       	push	r16
     6c0:	1f 93       	push	r17
     6c2:	2f 93       	push	r18
     6c4:	3f 93       	push	r19
     6c6:	4f 93       	push	r20
     6c8:	5f 93       	push	r21
     6ca:	6f 93       	push	r22
     6cc:	7f 93       	push	r23
     6ce:	8f 93       	push	r24
     6d0:	9f 93       	push	r25
     6d2:	af 93       	push	r26
     6d4:	bf 93       	push	r27
     6d6:	cf 93       	push	r28
     6d8:	df 93       	push	r29
     6da:	ef 93       	push	r30
     6dc:	ff 93       	push	r31
     6de:	a0 91 1f 07 	lds	r26, 0x071F	; 0x80071f <pxCurrentTCB>
     6e2:	b0 91 20 07 	lds	r27, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     6e6:	0d b6       	in	r0, 0x3d	; 61
     6e8:	0d 92       	st	X+, r0
     6ea:	0e b6       	in	r0, 0x3e	; 62
     6ec:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     6ee:	0e 94 ba 06 	call	0xd74	; 0xd74 <xTaskIncrementTick>
     6f2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6f4:	0e 94 08 08 	call	0x1010	; 0x1010 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     6f8:	a0 91 1f 07 	lds	r26, 0x071F	; 0x80071f <pxCurrentTCB>
     6fc:	b0 91 20 07 	lds	r27, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     700:	cd 91       	ld	r28, X+
     702:	cd bf       	out	0x3d, r28	; 61
     704:	dd 91       	ld	r29, X+
     706:	de bf       	out	0x3e, r29	; 62
     708:	ff 91       	pop	r31
     70a:	ef 91       	pop	r30
     70c:	df 91       	pop	r29
     70e:	cf 91       	pop	r28
     710:	bf 91       	pop	r27
     712:	af 91       	pop	r26
     714:	9f 91       	pop	r25
     716:	8f 91       	pop	r24
     718:	7f 91       	pop	r23
     71a:	6f 91       	pop	r22
     71c:	5f 91       	pop	r21
     71e:	4f 91       	pop	r20
     720:	3f 91       	pop	r19
     722:	2f 91       	pop	r18
     724:	1f 91       	pop	r17
     726:	0f 91       	pop	r16
     728:	ff 90       	pop	r15
     72a:	ef 90       	pop	r14
     72c:	df 90       	pop	r13
     72e:	cf 90       	pop	r12
     730:	bf 90       	pop	r11
     732:	af 90       	pop	r10
     734:	9f 90       	pop	r9
     736:	8f 90       	pop	r8
     738:	7f 90       	pop	r7
     73a:	6f 90       	pop	r6
     73c:	5f 90       	pop	r5
     73e:	4f 90       	pop	r4
     740:	3f 90       	pop	r3
     742:	2f 90       	pop	r2
     744:	1f 90       	pop	r1
     746:	0f 90       	pop	r0
     748:	0f be       	out	0x3f, r0	; 63
     74a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     74c:	08 95       	ret

0000074e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     74e:	0e 94 4b 03 	call	0x696	; 0x696 <vPortYieldFromTick>
		asm volatile ( "reti" );
     752:	18 95       	reti

00000754 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	dc 01       	movw	r26, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     75a:	e4 ee       	ldi	r30, 0xE4	; 228
     75c:	f0 e0       	ldi	r31, 0x00	; 0
     75e:	01 c0       	rjmp	.+2      	; 0x762 <prvInsertBlockIntoFreeList+0xe>
     760:	f9 01       	movw	r30, r18
     762:	20 81       	ld	r18, Z
     764:	31 81       	ldd	r19, Z+1	; 0x01
     766:	2a 17       	cp	r18, r26
     768:	3b 07       	cpc	r19, r27
     76a:	d0 f3       	brcs	.-12     	; 0x760 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     76c:	82 81       	ldd	r24, Z+2	; 0x02
     76e:	93 81       	ldd	r25, Z+3	; 0x03
     770:	af 01       	movw	r20, r30
     772:	48 0f       	add	r20, r24
     774:	59 1f       	adc	r21, r25
     776:	a4 17       	cp	r26, r20
     778:	b5 07       	cpc	r27, r21
     77a:	49 f4       	brne	.+18     	; 0x78e <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     77c:	12 96       	adiw	r26, 0x02	; 2
     77e:	4d 91       	ld	r20, X+
     780:	5c 91       	ld	r21, X
     782:	13 97       	sbiw	r26, 0x03	; 3
     784:	84 0f       	add	r24, r20
     786:	95 1f       	adc	r25, r21
     788:	93 83       	std	Z+3, r25	; 0x03
     78a:	82 83       	std	Z+2, r24	; 0x02
     78c:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     78e:	12 96       	adiw	r26, 0x02	; 2
     790:	8d 91       	ld	r24, X+
     792:	9c 91       	ld	r25, X
     794:	13 97       	sbiw	r26, 0x03	; 3
     796:	ed 01       	movw	r28, r26
     798:	c8 0f       	add	r28, r24
     79a:	d9 1f       	adc	r29, r25
     79c:	2c 17       	cp	r18, r28
     79e:	3d 07       	cpc	r19, r29
     7a0:	d9 f4       	brne	.+54     	; 0x7d8 <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     7a2:	20 91 e2 00 	lds	r18, 0x00E2	; 0x8000e2 <pxEnd>
     7a6:	30 91 e3 00 	lds	r19, 0x00E3	; 0x8000e3 <pxEnd+0x1>
     7aa:	c2 17       	cp	r28, r18
     7ac:	d3 07       	cpc	r29, r19
     7ae:	81 f0       	breq	.+32     	; 0x7d0 <prvInsertBlockIntoFreeList+0x7c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     7b0:	2a 81       	ldd	r18, Y+2	; 0x02
     7b2:	3b 81       	ldd	r19, Y+3	; 0x03
     7b4:	82 0f       	add	r24, r18
     7b6:	93 1f       	adc	r25, r19
     7b8:	13 96       	adiw	r26, 0x03	; 3
     7ba:	9c 93       	st	X, r25
     7bc:	8e 93       	st	-X, r24
     7be:	12 97       	sbiw	r26, 0x02	; 2
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     7c0:	c0 81       	ld	r28, Z
     7c2:	d1 81       	ldd	r29, Z+1	; 0x01
     7c4:	88 81       	ld	r24, Y
     7c6:	99 81       	ldd	r25, Y+1	; 0x01
     7c8:	11 96       	adiw	r26, 0x01	; 1
     7ca:	9c 93       	st	X, r25
     7cc:	8e 93       	st	-X, r24
     7ce:	07 c0       	rjmp	.+14     	; 0x7de <prvInsertBlockIntoFreeList+0x8a>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     7d0:	11 96       	adiw	r26, 0x01	; 1
     7d2:	dc 93       	st	X, r29
     7d4:	ce 93       	st	-X, r28
     7d6:	03 c0       	rjmp	.+6      	; 0x7de <prvInsertBlockIntoFreeList+0x8a>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     7d8:	11 96       	adiw	r26, 0x01	; 1
     7da:	3c 93       	st	X, r19
     7dc:	2e 93       	st	-X, r18

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     7de:	ae 17       	cp	r26, r30
     7e0:	bf 07       	cpc	r27, r31
     7e2:	11 f0       	breq	.+4      	; 0x7e8 <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     7e4:	b1 83       	std	Z+1, r27	; 0x01
     7e6:	a0 83       	st	Z, r26
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     7e8:	df 91       	pop	r29
     7ea:	cf 91       	pop	r28
     7ec:	08 95       	ret

000007ee <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7ee:	cf 92       	push	r12
     7f0:	df 92       	push	r13
     7f2:	ef 92       	push	r14
     7f4:	ff 92       	push	r15
     7f6:	0f 93       	push	r16
     7f8:	1f 93       	push	r17
     7fa:	cf 93       	push	r28
     7fc:	df 93       	push	r29
     7fe:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     800:	0e 94 b4 06 	call	0xd68	; 0xd68 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     804:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <pxEnd>
     808:	90 91 e3 00 	lds	r25, 0x00E3	; 0x8000e3 <pxEnd+0x1>
     80c:	89 2b       	or	r24, r25
     80e:	41 f5       	brne	.+80     	; 0x860 <__stack+0x1>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     810:	e4 ee       	ldi	r30, 0xE4	; 228
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	a8 ee       	ldi	r26, 0xE8	; 232
     816:	b0 e0       	ldi	r27, 0x00	; 0
     818:	b1 83       	std	Z+1, r27	; 0x01
     81a:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     81c:	13 82       	std	Z+3, r1	; 0x03
     81e:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     820:	e0 ec       	ldi	r30, 0xC0	; 192
     822:	f6 e0       	ldi	r31, 0x06	; 6
     824:	f0 93 e3 00 	sts	0x00E3, r31	; 0x8000e3 <pxEnd+0x1>
     828:	e0 93 e2 00 	sts	0x00E2, r30	; 0x8000e2 <pxEnd>
	pxEnd->xBlockSize = 0;
     82c:	13 82       	std	Z+3, r1	; 0x03
     82e:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     830:	11 82       	std	Z+1, r1	; 0x01
     832:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     834:	88 ed       	ldi	r24, 0xD8	; 216
     836:	95 e0       	ldi	r25, 0x05	; 5
     838:	13 96       	adiw	r26, 0x03	; 3
     83a:	9c 93       	st	X, r25
     83c:	8e 93       	st	-X, r24
     83e:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     840:	ed 93       	st	X+, r30
     842:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     844:	90 93 df 00 	sts	0x00DF, r25	; 0x8000df <xMinimumEverFreeBytesRemaining+0x1>
     848:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     84c:	90 93 e1 00 	sts	0x00E1, r25	; 0x8000e1 <xFreeBytesRemaining+0x1>
     850:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	90 e8       	ldi	r25, 0x80	; 128
     858:	90 93 dd 00 	sts	0x00DD, r25	; 0x8000dd <xBlockAllocatedBit+0x1>
     85c:	80 93 dc 00 	sts	0x00DC, r24	; 0x8000dc <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     860:	e0 90 dc 00 	lds	r14, 0x00DC	; 0x8000dc <xBlockAllocatedBit>
     864:	f0 90 dd 00 	lds	r15, 0x00DD	; 0x8000dd <xBlockAllocatedBit+0x1>
     868:	c7 01       	movw	r24, r14
     86a:	8c 23       	and	r24, r28
     86c:	9d 23       	and	r25, r29
     86e:	89 2b       	or	r24, r25
     870:	09 f0       	breq	.+2      	; 0x874 <__stack+0x15>
     872:	5f c0       	rjmp	.+190    	; 0x932 <__stack+0xd3>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     874:	20 97       	sbiw	r28, 0x00	; 0
     876:	09 f4       	brne	.+2      	; 0x87a <__stack+0x1b>
     878:	5f c0       	rjmp	.+190    	; 0x938 <__stack+0xd9>
			{
				xWantedSize += xHeapStructSize;
     87a:	ae 01       	movw	r20, r28
     87c:	4c 5f       	subi	r20, 0xFC	; 252
     87e:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     880:	09 f4       	brne	.+2      	; 0x884 <__stack+0x25>
     882:	5d c0       	rjmp	.+186    	; 0x93e <__stack+0xdf>
     884:	00 91 e0 00 	lds	r16, 0x00E0	; 0x8000e0 <xFreeBytesRemaining>
     888:	10 91 e1 00 	lds	r17, 0x00E1	; 0x8000e1 <xFreeBytesRemaining+0x1>
     88c:	04 17       	cp	r16, r20
     88e:	15 07       	cpc	r17, r21
     890:	08 f4       	brcc	.+2      	; 0x894 <__stack+0x35>
     892:	58 c0       	rjmp	.+176    	; 0x944 <__stack+0xe5>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     894:	c0 91 e4 00 	lds	r28, 0x00E4	; 0x8000e4 <xStart>
     898:	d0 91 e5 00 	lds	r29, 0x00E5	; 0x8000e5 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     89c:	e4 ee       	ldi	r30, 0xE4	; 228
     89e:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     8a0:	02 c0       	rjmp	.+4      	; 0x8a6 <__stack+0x47>
     8a2:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
     8a4:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     8a6:	2a 81       	ldd	r18, Y+2	; 0x02
     8a8:	3b 81       	ldd	r19, Y+3	; 0x03
     8aa:	24 17       	cp	r18, r20
     8ac:	35 07       	cpc	r19, r21
     8ae:	28 f4       	brcc	.+10     	; 0x8ba <__stack+0x5b>
     8b0:	28 81       	ld	r18, Y
     8b2:	39 81       	ldd	r19, Y+1	; 0x01
     8b4:	21 15       	cp	r18, r1
     8b6:	31 05       	cpc	r19, r1
     8b8:	a1 f7       	brne	.-24     	; 0x8a2 <__stack+0x43>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     8ba:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <pxEnd>
     8be:	90 91 e3 00 	lds	r25, 0x00E3	; 0x8000e3 <pxEnd+0x1>
     8c2:	c8 17       	cp	r28, r24
     8c4:	d9 07       	cpc	r29, r25
     8c6:	09 f4       	brne	.+2      	; 0x8ca <__stack+0x6b>
     8c8:	40 c0       	rjmp	.+128    	; 0x94a <__stack+0xeb>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     8ca:	c0 80       	ld	r12, Z
     8cc:	d1 80       	ldd	r13, Z+1	; 0x01
     8ce:	84 e0       	ldi	r24, 0x04	; 4
     8d0:	c8 0e       	add	r12, r24
     8d2:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     8d4:	88 81       	ld	r24, Y
     8d6:	99 81       	ldd	r25, Y+1	; 0x01
     8d8:	91 83       	std	Z+1, r25	; 0x01
     8da:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     8dc:	2a 81       	ldd	r18, Y+2	; 0x02
     8de:	3b 81       	ldd	r19, Y+3	; 0x03
     8e0:	24 1b       	sub	r18, r20
     8e2:	35 0b       	sbc	r19, r21
     8e4:	29 30       	cpi	r18, 0x09	; 9
     8e6:	31 05       	cpc	r19, r1
     8e8:	50 f0       	brcs	.+20     	; 0x8fe <__stack+0x9f>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     8ea:	ce 01       	movw	r24, r28
     8ec:	84 0f       	add	r24, r20
     8ee:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     8f0:	fc 01       	movw	r30, r24
     8f2:	33 83       	std	Z+3, r19	; 0x03
     8f4:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     8f6:	5b 83       	std	Y+3, r21	; 0x03
     8f8:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     8fa:	0e 94 aa 03 	call	0x754	; 0x754 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     8fe:	8a 81       	ldd	r24, Y+2	; 0x02
     900:	9b 81       	ldd	r25, Y+3	; 0x03
     902:	08 1b       	sub	r16, r24
     904:	19 0b       	sbc	r17, r25
     906:	10 93 e1 00 	sts	0x00E1, r17	; 0x8000e1 <xFreeBytesRemaining+0x1>
     90a:	00 93 e0 00 	sts	0x00E0, r16	; 0x8000e0 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     90e:	20 91 de 00 	lds	r18, 0x00DE	; 0x8000de <xMinimumEverFreeBytesRemaining>
     912:	30 91 df 00 	lds	r19, 0x00DF	; 0x8000df <xMinimumEverFreeBytesRemaining+0x1>
     916:	02 17       	cp	r16, r18
     918:	13 07       	cpc	r17, r19
     91a:	20 f4       	brcc	.+8      	; 0x924 <__stack+0xc5>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     91c:	10 93 df 00 	sts	0x00DF, r17	; 0x8000df <xMinimumEverFreeBytesRemaining+0x1>
     920:	00 93 de 00 	sts	0x00DE, r16	; 0x8000de <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     924:	e8 2a       	or	r14, r24
     926:	f9 2a       	or	r15, r25
     928:	fb 82       	std	Y+3, r15	; 0x03
     92a:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     92c:	19 82       	std	Y+1, r1	; 0x01
     92e:	18 82       	st	Y, r1
     930:	0e c0       	rjmp	.+28     	; 0x94e <__stack+0xef>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     932:	c1 2c       	mov	r12, r1
     934:	d1 2c       	mov	r13, r1
     936:	0b c0       	rjmp	.+22     	; 0x94e <__stack+0xef>
     938:	c1 2c       	mov	r12, r1
     93a:	d1 2c       	mov	r13, r1
     93c:	08 c0       	rjmp	.+16     	; 0x94e <__stack+0xef>
     93e:	c1 2c       	mov	r12, r1
     940:	d1 2c       	mov	r13, r1
     942:	05 c0       	rjmp	.+10     	; 0x94e <__stack+0xef>
     944:	c1 2c       	mov	r12, r1
     946:	d1 2c       	mov	r13, r1
     948:	02 c0       	rjmp	.+4      	; 0x94e <__stack+0xef>
     94a:	c1 2c       	mov	r12, r1
     94c:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     94e:	0e 94 75 07 	call	0xeea	; 0xeea <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     952:	c6 01       	movw	r24, r12
     954:	df 91       	pop	r29
     956:	cf 91       	pop	r28
     958:	1f 91       	pop	r17
     95a:	0f 91       	pop	r16
     95c:	ff 90       	pop	r15
     95e:	ef 90       	pop	r14
     960:	df 90       	pop	r13
     962:	cf 90       	pop	r12
     964:	08 95       	ret

00000966 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     96a:	00 97       	sbiw	r24, 0x00	; 0
     96c:	59 f1       	breq	.+86     	; 0x9c4 <vPortFree+0x5e>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     96e:	fc 01       	movw	r30, r24
     970:	34 97       	sbiw	r30, 0x04	; 4
     972:	22 81       	ldd	r18, Z+2	; 0x02
     974:	33 81       	ldd	r19, Z+3	; 0x03
     976:	40 91 dc 00 	lds	r20, 0x00DC	; 0x8000dc <xBlockAllocatedBit>
     97a:	50 91 dd 00 	lds	r21, 0x00DD	; 0x8000dd <xBlockAllocatedBit+0x1>
     97e:	b9 01       	movw	r22, r18
     980:	64 23       	and	r22, r20
     982:	75 23       	and	r23, r21
     984:	67 2b       	or	r22, r23
     986:	f1 f0       	breq	.+60     	; 0x9c4 <vPortFree+0x5e>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     988:	60 81       	ld	r22, Z
     98a:	71 81       	ldd	r23, Z+1	; 0x01
     98c:	67 2b       	or	r22, r23
     98e:	d1 f4       	brne	.+52     	; 0x9c4 <vPortFree+0x5e>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     990:	ef 01       	movw	r28, r30
     992:	40 95       	com	r20
     994:	50 95       	com	r21
     996:	24 23       	and	r18, r20
     998:	35 23       	and	r19, r21
     99a:	33 83       	std	Z+3, r19	; 0x03
     99c:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
     99e:	0e 94 b4 06 	call	0xd68	; 0xd68 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     9a2:	20 91 e0 00 	lds	r18, 0x00E0	; 0x8000e0 <xFreeBytesRemaining>
     9a6:	30 91 e1 00 	lds	r19, 0x00E1	; 0x8000e1 <xFreeBytesRemaining+0x1>
     9aa:	8a 81       	ldd	r24, Y+2	; 0x02
     9ac:	9b 81       	ldd	r25, Y+3	; 0x03
     9ae:	82 0f       	add	r24, r18
     9b0:	93 1f       	adc	r25, r19
     9b2:	90 93 e1 00 	sts	0x00E1, r25	; 0x8000e1 <xFreeBytesRemaining+0x1>
     9b6:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     9ba:	ce 01       	movw	r24, r28
     9bc:	0e 94 aa 03 	call	0x754	; 0x754 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     9c0:	0e 94 75 07 	call	0xeea	; 0xeea <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     9c4:	df 91       	pop	r29
     9c6:	cf 91       	pop	r28
     9c8:	08 95       	ret

000009ca <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     9ca:	e0 91 e7 06 	lds	r30, 0x06E7	; 0x8006e7 <pxDelayedTaskList>
     9ce:	f0 91 e8 06 	lds	r31, 0x06E8	; 0x8006e8 <pxDelayedTaskList+0x1>
     9d2:	80 81       	ld	r24, Z
     9d4:	81 11       	cpse	r24, r1
     9d6:	07 c0       	rjmp	.+14     	; 0x9e6 <prvResetNextTaskUnblockTime+0x1c>
     9d8:	8f ef       	ldi	r24, 0xFF	; 255
     9da:	9f ef       	ldi	r25, 0xFF	; 255
     9dc:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     9e0:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     9e4:	08 95       	ret
     9e6:	e0 91 e7 06 	lds	r30, 0x06E7	; 0x8006e7 <pxDelayedTaskList>
     9ea:	f0 91 e8 06 	lds	r31, 0x06E8	; 0x8006e8 <pxDelayedTaskList+0x1>
     9ee:	05 80       	ldd	r0, Z+5	; 0x05
     9f0:	f6 81       	ldd	r31, Z+6	; 0x06
     9f2:	e0 2d       	mov	r30, r0
     9f4:	06 80       	ldd	r0, Z+6	; 0x06
     9f6:	f7 81       	ldd	r31, Z+7	; 0x07
     9f8:	e0 2d       	mov	r30, r0
     9fa:	82 81       	ldd	r24, Z+2	; 0x02
     9fc:	93 81       	ldd	r25, Z+3	; 0x03
     9fe:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     a02:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     a06:	08 95       	ret

00000a08 <prvAddCurrentTaskToDelayedList>:
     a08:	0f 93       	push	r16
     a0a:	1f 93       	push	r17
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	ec 01       	movw	r28, r24
     a12:	00 91 cf 06 	lds	r16, 0x06CF	; 0x8006cf <xTickCount>
     a16:	10 91 d0 06 	lds	r17, 0x06D0	; 0x8006d0 <xTickCount+0x1>
     a1a:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxCurrentTCB>
     a1e:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     a22:	02 96       	adiw	r24, 0x02	; 2
     a24:	0e 94 2a 02 	call	0x454	; 0x454 <uxListRemove>
     a28:	c0 0f       	add	r28, r16
     a2a:	d1 1f       	adc	r29, r17
     a2c:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxCurrentTCB>
     a30:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     a34:	d3 83       	std	Z+3, r29	; 0x03
     a36:	c2 83       	std	Z+2, r28	; 0x02
     a38:	c0 17       	cp	r28, r16
     a3a:	d1 07       	cpc	r29, r17
     a3c:	68 f4       	brcc	.+26     	; 0xa58 <prvAddCurrentTaskToDelayedList+0x50>
     a3e:	60 91 1f 07 	lds	r22, 0x071F	; 0x80071f <pxCurrentTCB>
     a42:	70 91 20 07 	lds	r23, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     a46:	80 91 e5 06 	lds	r24, 0x06E5	; 0x8006e5 <pxOverflowDelayedTaskList>
     a4a:	90 91 e6 06 	lds	r25, 0x06E6	; 0x8006e6 <pxOverflowDelayedTaskList+0x1>
     a4e:	6e 5f       	subi	r22, 0xFE	; 254
     a50:	7f 4f       	sbci	r23, 0xFF	; 255
     a52:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInsert>
     a56:	17 c0       	rjmp	.+46     	; 0xa86 <prvAddCurrentTaskToDelayedList+0x7e>
     a58:	60 91 1f 07 	lds	r22, 0x071F	; 0x80071f <pxCurrentTCB>
     a5c:	70 91 20 07 	lds	r23, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     a60:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <pxDelayedTaskList>
     a64:	90 91 e8 06 	lds	r25, 0x06E8	; 0x8006e8 <pxDelayedTaskList+0x1>
     a68:	6e 5f       	subi	r22, 0xFE	; 254
     a6a:	7f 4f       	sbci	r23, 0xFF	; 255
     a6c:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <vListInsert>
     a70:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <xNextTaskUnblockTime>
     a74:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     a78:	c8 17       	cp	r28, r24
     a7a:	d9 07       	cpc	r29, r25
     a7c:	20 f4       	brcc	.+8      	; 0xa86 <prvAddCurrentTaskToDelayedList+0x7e>
     a7e:	d0 93 c8 06 	sts	0x06C8, r29	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     a82:	c0 93 c7 06 	sts	0x06C7, r28	; 0x8006c7 <xNextTaskUnblockTime>
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	1f 91       	pop	r17
     a8c:	0f 91       	pop	r16
     a8e:	08 95       	ret

00000a90 <prvIdleTask>:
     a90:	03 ed       	ldi	r16, 0xD3	; 211
     a92:	16 e0       	ldi	r17, 0x06	; 6
     a94:	0f 2e       	mov	r0, r31
     a96:	fb ef       	ldi	r31, 0xFB	; 251
     a98:	ef 2e       	mov	r14, r31
     a9a:	f6 e0       	ldi	r31, 0x06	; 6
     a9c:	ff 2e       	mov	r15, r31
     a9e:	f0 2d       	mov	r31, r0
     aa0:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <uxDeletedTasksWaitingCleanUp>
     aa4:	88 23       	and	r24, r24
     aa6:	29 f1       	breq	.+74     	; 0xaf2 <prvIdleTask+0x62>
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	f8 94       	cli
     aac:	0f 92       	push	r0
     aae:	d8 01       	movw	r26, r16
     ab0:	15 96       	adiw	r26, 0x05	; 5
     ab2:	ed 91       	ld	r30, X+
     ab4:	fc 91       	ld	r31, X
     ab6:	16 97       	sbiw	r26, 0x06	; 6
     ab8:	c6 81       	ldd	r28, Z+6	; 0x06
     aba:	d7 81       	ldd	r29, Z+7	; 0x07
     abc:	ce 01       	movw	r24, r28
     abe:	02 96       	adiw	r24, 0x02	; 2
     ac0:	0e 94 2a 02 	call	0x454	; 0x454 <uxListRemove>
     ac4:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     ac8:	81 50       	subi	r24, 0x01	; 1
     aca:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <uxCurrentNumberOfTasks>
     ace:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <uxDeletedTasksWaitingCleanUp>
     ad2:	81 50       	subi	r24, 0x01	; 1
     ad4:	80 93 d2 06 	sts	0x06D2, r24	; 0x8006d2 <uxDeletedTasksWaitingCleanUp>
     ad8:	0f 90       	pop	r0
     ada:	0f be       	out	0x3f, r0	; 63
     adc:	8f 89       	ldd	r24, Y+23	; 0x17
     ade:	98 8d       	ldd	r25, Y+24	; 0x18
     ae0:	0e 94 b3 04 	call	0x966	; 0x966 <vPortFree>
     ae4:	ce 01       	movw	r24, r28
     ae6:	0e 94 b3 04 	call	0x966	; 0x966 <vPortFree>
     aea:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <uxDeletedTasksWaitingCleanUp>
     aee:	81 11       	cpse	r24, r1
     af0:	db cf       	rjmp	.-74     	; 0xaa8 <prvIdleTask+0x18>
     af2:	f7 01       	movw	r30, r14
     af4:	80 81       	ld	r24, Z
     af6:	82 30       	cpi	r24, 0x02	; 2
     af8:	10 f0       	brcs	.+4      	; 0xafe <prvIdleTask+0x6e>
     afa:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <vPortYield>
     afe:	0e 94 e6 08 	call	0x11cc	; 0x11cc <vApplicationIdleHook>
     b02:	ce cf       	rjmp	.-100    	; 0xaa0 <prvIdleTask+0x10>

00000b04 <xTaskCreate>:
     b04:	4f 92       	push	r4
     b06:	5f 92       	push	r5
     b08:	6f 92       	push	r6
     b0a:	7f 92       	push	r7
     b0c:	8f 92       	push	r8
     b0e:	9f 92       	push	r9
     b10:	af 92       	push	r10
     b12:	bf 92       	push	r11
     b14:	cf 92       	push	r12
     b16:	df 92       	push	r13
     b18:	ef 92       	push	r14
     b1a:	ff 92       	push	r15
     b1c:	0f 93       	push	r16
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	4c 01       	movw	r8, r24
     b24:	6b 01       	movw	r12, r22
     b26:	5a 01       	movw	r10, r20
     b28:	29 01       	movw	r4, r18
     b2a:	ca 01       	movw	r24, r20
     b2c:	0e 94 f7 03 	call	0x7ee	; 0x7ee <pvPortMalloc>
     b30:	3c 01       	movw	r6, r24
     b32:	89 2b       	or	r24, r25
     b34:	09 f4       	brne	.+2      	; 0xb38 <xTaskCreate+0x34>
     b36:	dd c0       	rjmp	.+442    	; 0xcf2 <xTaskCreate+0x1ee>
     b38:	86 e2       	ldi	r24, 0x26	; 38
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	0e 94 f7 03 	call	0x7ee	; 0x7ee <pvPortMalloc>
     b40:	ec 01       	movw	r28, r24
     b42:	89 2b       	or	r24, r25
     b44:	71 f0       	breq	.+28     	; 0xb62 <xTaskCreate+0x5e>
     b46:	78 8e       	std	Y+24, r7	; 0x18
     b48:	6f 8a       	std	Y+23, r6	; 0x17
     b4a:	81 e0       	ldi	r24, 0x01	; 1
     b4c:	a8 1a       	sub	r10, r24
     b4e:	b1 08       	sbc	r11, r1
     b50:	a6 0c       	add	r10, r6
     b52:	b7 1c       	adc	r11, r7
     b54:	d6 01       	movw	r26, r12
     b56:	8c 91       	ld	r24, X
     b58:	89 8f       	std	Y+25, r24	; 0x19
     b5a:	8c 91       	ld	r24, X
     b5c:	81 11       	cpse	r24, r1
     b5e:	05 c0       	rjmp	.+10     	; 0xb6a <xTaskCreate+0x66>
     b60:	18 c0       	rjmp	.+48     	; 0xb92 <xTaskCreate+0x8e>
     b62:	c3 01       	movw	r24, r6
     b64:	0e 94 b3 04 	call	0x966	; 0x966 <vPortFree>
     b68:	c4 c0       	rjmp	.+392    	; 0xcf2 <xTaskCreate+0x1ee>
     b6a:	ae 01       	movw	r20, r28
     b6c:	46 5e       	subi	r20, 0xE6	; 230
     b6e:	5f 4f       	sbci	r21, 0xFF	; 255
     b70:	f6 01       	movw	r30, r12
     b72:	31 96       	adiw	r30, 0x01	; 1
     b74:	b8 e0       	ldi	r27, 0x08	; 8
     b76:	cb 0e       	add	r12, r27
     b78:	d1 1c       	adc	r13, r1
     b7a:	cf 01       	movw	r24, r30
     b7c:	21 91       	ld	r18, Z+
     b7e:	da 01       	movw	r26, r20
     b80:	2d 93       	st	X+, r18
     b82:	ad 01       	movw	r20, r26
     b84:	dc 01       	movw	r26, r24
     b86:	8c 91       	ld	r24, X
     b88:	88 23       	and	r24, r24
     b8a:	19 f0       	breq	.+6      	; 0xb92 <xTaskCreate+0x8e>
     b8c:	ec 15       	cp	r30, r12
     b8e:	fd 05       	cpc	r31, r13
     b90:	a1 f7       	brne	.-24     	; 0xb7a <xTaskCreate+0x76>
     b92:	18 a2       	std	Y+32, r1	; 0x20
     b94:	04 30       	cpi	r16, 0x04	; 4
     b96:	08 f0       	brcs	.+2      	; 0xb9a <xTaskCreate+0x96>
     b98:	03 e0       	ldi	r16, 0x03	; 3
     b9a:	0e 8b       	std	Y+22, r16	; 0x16
     b9c:	6e 01       	movw	r12, r28
     b9e:	b2 e0       	ldi	r27, 0x02	; 2
     ba0:	cb 0e       	add	r12, r27
     ba2:	d1 1c       	adc	r13, r1
     ba4:	c6 01       	movw	r24, r12
     ba6:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <vListInitialiseItem>
     baa:	ce 01       	movw	r24, r28
     bac:	0c 96       	adiw	r24, 0x0c	; 12
     bae:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <vListInitialiseItem>
     bb2:	d9 87       	std	Y+9, r29	; 0x09
     bb4:	c8 87       	std	Y+8, r28	; 0x08
     bb6:	84 e0       	ldi	r24, 0x04	; 4
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	80 1b       	sub	r24, r16
     bbc:	91 09       	sbc	r25, r1
     bbe:	9d 87       	std	Y+13, r25	; 0x0d
     bc0:	8c 87       	std	Y+12, r24	; 0x0c
     bc2:	db 8b       	std	Y+19, r29	; 0x13
     bc4:	ca 8b       	std	Y+18, r28	; 0x12
     bc6:	19 a2       	std	Y+33, r1	; 0x21
     bc8:	1a a2       	std	Y+34, r1	; 0x22
     bca:	1b a2       	std	Y+35, r1	; 0x23
     bcc:	1c a2       	std	Y+36, r1	; 0x24
     bce:	1d a2       	std	Y+37, r1	; 0x25
     bd0:	a2 01       	movw	r20, r4
     bd2:	b4 01       	movw	r22, r8
     bd4:	c5 01       	movw	r24, r10
     bd6:	0e 94 51 02 	call	0x4a2	; 0x4a2 <pxPortInitialiseStack>
     bda:	99 83       	std	Y+1, r25	; 0x01
     bdc:	88 83       	st	Y, r24
     bde:	e1 14       	cp	r14, r1
     be0:	f1 04       	cpc	r15, r1
     be2:	19 f0       	breq	.+6      	; 0xbea <xTaskCreate+0xe6>
     be4:	f7 01       	movw	r30, r14
     be6:	d1 83       	std	Z+1, r29	; 0x01
     be8:	c0 83       	st	Z, r28
     bea:	0f b6       	in	r0, 0x3f	; 63
     bec:	f8 94       	cli
     bee:	0f 92       	push	r0
     bf0:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     bf4:	8f 5f       	subi	r24, 0xFF	; 255
     bf6:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <uxCurrentNumberOfTasks>
     bfa:	80 91 1f 07 	lds	r24, 0x071F	; 0x80071f <pxCurrentTCB>
     bfe:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     c02:	89 2b       	or	r24, r25
     c04:	a9 f5       	brne	.+106    	; 0xc70 <xTaskCreate+0x16c>
     c06:	d0 93 20 07 	sts	0x0720, r29	; 0x800720 <pxCurrentTCB+0x1>
     c0a:	c0 93 1f 07 	sts	0x071F, r28	; 0x80071f <pxCurrentTCB>
     c0e:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     c12:	81 30       	cpi	r24, 0x01	; 1
     c14:	e9 f5       	brne	.+122    	; 0xc90 <xTaskCreate+0x18c>
     c16:	8b ef       	ldi	r24, 0xFB	; 251
     c18:	96 e0       	ldi	r25, 0x06	; 6
     c1a:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c1e:	84 e0       	ldi	r24, 0x04	; 4
     c20:	97 e0       	ldi	r25, 0x07	; 7
     c22:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c26:	8d e0       	ldi	r24, 0x0D	; 13
     c28:	97 e0       	ldi	r25, 0x07	; 7
     c2a:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c2e:	86 e1       	ldi	r24, 0x16	; 22
     c30:	97 e0       	ldi	r25, 0x07	; 7
     c32:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c36:	82 ef       	ldi	r24, 0xF2	; 242
     c38:	96 e0       	ldi	r25, 0x06	; 6
     c3a:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c3e:	89 ee       	ldi	r24, 0xE9	; 233
     c40:	96 e0       	ldi	r25, 0x06	; 6
     c42:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c46:	8c ed       	ldi	r24, 0xDC	; 220
     c48:	96 e0       	ldi	r25, 0x06	; 6
     c4a:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c4e:	83 ed       	ldi	r24, 0xD3	; 211
     c50:	96 e0       	ldi	r25, 0x06	; 6
     c52:	0e 94 c6 01 	call	0x38c	; 0x38c <vListInitialise>
     c56:	82 ef       	ldi	r24, 0xF2	; 242
     c58:	96 e0       	ldi	r25, 0x06	; 6
     c5a:	90 93 e8 06 	sts	0x06E8, r25	; 0x8006e8 <pxDelayedTaskList+0x1>
     c5e:	80 93 e7 06 	sts	0x06E7, r24	; 0x8006e7 <pxDelayedTaskList>
     c62:	89 ee       	ldi	r24, 0xE9	; 233
     c64:	96 e0       	ldi	r25, 0x06	; 6
     c66:	90 93 e6 06 	sts	0x06E6, r25	; 0x8006e6 <pxOverflowDelayedTaskList+0x1>
     c6a:	80 93 e5 06 	sts	0x06E5, r24	; 0x8006e5 <pxOverflowDelayedTaskList>
     c6e:	10 c0       	rjmp	.+32     	; 0xc90 <xTaskCreate+0x18c>
     c70:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <xSchedulerRunning>
     c74:	81 11       	cpse	r24, r1
     c76:	0c c0       	rjmp	.+24     	; 0xc90 <xTaskCreate+0x18c>
     c78:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxCurrentTCB>
     c7c:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     c80:	96 89       	ldd	r25, Z+22	; 0x16
     c82:	8e 89       	ldd	r24, Y+22	; 0x16
     c84:	89 17       	cp	r24, r25
     c86:	20 f0       	brcs	.+8      	; 0xc90 <xTaskCreate+0x18c>
     c88:	d0 93 20 07 	sts	0x0720, r29	; 0x800720 <pxCurrentTCB+0x1>
     c8c:	c0 93 1f 07 	sts	0x071F, r28	; 0x80071f <pxCurrentTCB>
     c90:	80 91 c9 06 	lds	r24, 0x06C9	; 0x8006c9 <uxTaskNumber>
     c94:	8f 5f       	subi	r24, 0xFF	; 255
     c96:	80 93 c9 06 	sts	0x06C9, r24	; 0x8006c9 <uxTaskNumber>
     c9a:	8e 89       	ldd	r24, Y+22	; 0x16
     c9c:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
     ca0:	98 17       	cp	r25, r24
     ca2:	10 f4       	brcc	.+4      	; 0xca8 <xTaskCreate+0x1a4>
     ca4:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	9c 01       	movw	r18, r24
     cac:	22 0f       	add	r18, r18
     cae:	33 1f       	adc	r19, r19
     cb0:	22 0f       	add	r18, r18
     cb2:	33 1f       	adc	r19, r19
     cb4:	22 0f       	add	r18, r18
     cb6:	33 1f       	adc	r19, r19
     cb8:	82 0f       	add	r24, r18
     cba:	93 1f       	adc	r25, r19
     cbc:	b6 01       	movw	r22, r12
     cbe:	85 50       	subi	r24, 0x05	; 5
     cc0:	99 4f       	sbci	r25, 0xF9	; 249
     cc2:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <vListInsertEnd>
     cc6:	0f 90       	pop	r0
     cc8:	0f be       	out	0x3f, r0	; 63
     cca:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <xSchedulerRunning>
     cce:	88 23       	and	r24, r24
     cd0:	61 f0       	breq	.+24     	; 0xcea <xTaskCreate+0x1e6>
     cd2:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxCurrentTCB>
     cd6:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     cda:	96 89       	ldd	r25, Z+22	; 0x16
     cdc:	8e 89       	ldd	r24, Y+22	; 0x16
     cde:	98 17       	cp	r25, r24
     ce0:	30 f4       	brcc	.+12     	; 0xcee <xTaskCreate+0x1ea>
     ce2:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <vPortYield>
     ce6:	81 e0       	ldi	r24, 0x01	; 1
     ce8:	05 c0       	rjmp	.+10     	; 0xcf4 <xTaskCreate+0x1f0>
     cea:	81 e0       	ldi	r24, 0x01	; 1
     cec:	03 c0       	rjmp	.+6      	; 0xcf4 <xTaskCreate+0x1f0>
     cee:	81 e0       	ldi	r24, 0x01	; 1
     cf0:	01 c0       	rjmp	.+2      	; 0xcf4 <xTaskCreate+0x1f0>
     cf2:	8f ef       	ldi	r24, 0xFF	; 255
     cf4:	df 91       	pop	r29
     cf6:	cf 91       	pop	r28
     cf8:	0f 91       	pop	r16
     cfa:	ff 90       	pop	r15
     cfc:	ef 90       	pop	r14
     cfe:	df 90       	pop	r13
     d00:	cf 90       	pop	r12
     d02:	bf 90       	pop	r11
     d04:	af 90       	pop	r10
     d06:	9f 90       	pop	r9
     d08:	8f 90       	pop	r8
     d0a:	7f 90       	pop	r7
     d0c:	6f 90       	pop	r6
     d0e:	5f 90       	pop	r5
     d10:	4f 90       	pop	r4
     d12:	08 95       	ret

00000d14 <vTaskStartScheduler>:
     d14:	ef 92       	push	r14
     d16:	ff 92       	push	r15
     d18:	0f 93       	push	r16
     d1a:	0f 2e       	mov	r0, r31
     d1c:	f5 ec       	ldi	r31, 0xC5	; 197
     d1e:	ef 2e       	mov	r14, r31
     d20:	f6 e0       	ldi	r31, 0x06	; 6
     d22:	ff 2e       	mov	r15, r31
     d24:	f0 2d       	mov	r31, r0
     d26:	00 e0       	ldi	r16, 0x00	; 0
     d28:	20 e0       	ldi	r18, 0x00	; 0
     d2a:	30 e0       	ldi	r19, 0x00	; 0
     d2c:	45 e5       	ldi	r20, 0x55	; 85
     d2e:	50 e0       	ldi	r21, 0x00	; 0
     d30:	60 ed       	ldi	r22, 0xD0	; 208
     d32:	70 e0       	ldi	r23, 0x00	; 0
     d34:	88 e4       	ldi	r24, 0x48	; 72
     d36:	95 e0       	ldi	r25, 0x05	; 5
     d38:	0e 94 82 05 	call	0xb04	; 0xb04 <xTaskCreate>
     d3c:	81 30       	cpi	r24, 0x01	; 1
     d3e:	81 f4       	brne	.+32     	; 0xd60 <vTaskStartScheduler+0x4c>
     d40:	f8 94       	cli
     d42:	8f ef       	ldi	r24, 0xFF	; 255
     d44:	9f ef       	ldi	r25, 0xFF	; 255
     d46:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     d4a:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <xSchedulerRunning>
     d54:	10 92 d0 06 	sts	0x06D0, r1	; 0x8006d0 <xTickCount+0x1>
     d58:	10 92 cf 06 	sts	0x06CF, r1	; 0x8006cf <xTickCount>
     d5c:	0e 94 bd 02 	call	0x57a	; 0x57a <xPortStartScheduler>
     d60:	0f 91       	pop	r16
     d62:	ff 90       	pop	r15
     d64:	ef 90       	pop	r14
     d66:	08 95       	ret

00000d68 <vTaskSuspendAll>:
     d68:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     d6c:	8f 5f       	subi	r24, 0xFF	; 255
     d6e:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <uxSchedulerSuspended>
     d72:	08 95       	ret

00000d74 <xTaskIncrementTick>:
     d74:	cf 92       	push	r12
     d76:	df 92       	push	r13
     d78:	ef 92       	push	r14
     d7a:	ff 92       	push	r15
     d7c:	0f 93       	push	r16
     d7e:	1f 93       	push	r17
     d80:	cf 93       	push	r28
     d82:	df 93       	push	r29
     d84:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     d88:	81 11       	cpse	r24, r1
     d8a:	99 c0       	rjmp	.+306    	; 0xebe <xTaskIncrementTick+0x14a>
     d8c:	e0 90 cf 06 	lds	r14, 0x06CF	; 0x8006cf <xTickCount>
     d90:	f0 90 d0 06 	lds	r15, 0x06D0	; 0x8006d0 <xTickCount+0x1>
     d94:	8f ef       	ldi	r24, 0xFF	; 255
     d96:	e8 1a       	sub	r14, r24
     d98:	f8 0a       	sbc	r15, r24
     d9a:	f0 92 d0 06 	sts	0x06D0, r15	; 0x8006d0 <xTickCount+0x1>
     d9e:	e0 92 cf 06 	sts	0x06CF, r14	; 0x8006cf <xTickCount>
     da2:	e1 14       	cp	r14, r1
     da4:	f1 04       	cpc	r15, r1
     da6:	b9 f4       	brne	.+46     	; 0xdd6 <xTaskIncrementTick+0x62>
     da8:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <pxDelayedTaskList>
     dac:	90 91 e8 06 	lds	r25, 0x06E8	; 0x8006e8 <pxDelayedTaskList+0x1>
     db0:	20 91 e5 06 	lds	r18, 0x06E5	; 0x8006e5 <pxOverflowDelayedTaskList>
     db4:	30 91 e6 06 	lds	r19, 0x06E6	; 0x8006e6 <pxOverflowDelayedTaskList+0x1>
     db8:	30 93 e8 06 	sts	0x06E8, r19	; 0x8006e8 <pxDelayedTaskList+0x1>
     dbc:	20 93 e7 06 	sts	0x06E7, r18	; 0x8006e7 <pxDelayedTaskList>
     dc0:	90 93 e6 06 	sts	0x06E6, r25	; 0x8006e6 <pxOverflowDelayedTaskList+0x1>
     dc4:	80 93 e5 06 	sts	0x06E5, r24	; 0x8006e5 <pxOverflowDelayedTaskList>
     dc8:	80 91 ca 06 	lds	r24, 0x06CA	; 0x8006ca <xNumOfOverflows>
     dcc:	8f 5f       	subi	r24, 0xFF	; 255
     dce:	80 93 ca 06 	sts	0x06CA, r24	; 0x8006ca <xNumOfOverflows>
     dd2:	0e 94 e5 04 	call	0x9ca	; 0x9ca <prvResetNextTaskUnblockTime>
     dd6:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <xNextTaskUnblockTime>
     dda:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     dde:	e8 16       	cp	r14, r24
     de0:	f9 06       	cpc	r15, r25
     de2:	10 f4       	brcc	.+4      	; 0xde8 <xTaskIncrementTick+0x74>
     de4:	d1 2c       	mov	r13, r1
     de6:	53 c0       	rjmp	.+166    	; 0xe8e <xTaskIncrementTick+0x11a>
     de8:	d1 2c       	mov	r13, r1
     dea:	cc 24       	eor	r12, r12
     dec:	c3 94       	inc	r12
     dee:	e0 91 e7 06 	lds	r30, 0x06E7	; 0x8006e7 <pxDelayedTaskList>
     df2:	f0 91 e8 06 	lds	r31, 0x06E8	; 0x8006e8 <pxDelayedTaskList+0x1>
     df6:	80 81       	ld	r24, Z
     df8:	81 11       	cpse	r24, r1
     dfa:	07 c0       	rjmp	.+14     	; 0xe0a <xTaskIncrementTick+0x96>
     dfc:	8f ef       	ldi	r24, 0xFF	; 255
     dfe:	9f ef       	ldi	r25, 0xFF	; 255
     e00:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     e04:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     e08:	42 c0       	rjmp	.+132    	; 0xe8e <xTaskIncrementTick+0x11a>
     e0a:	e0 91 e7 06 	lds	r30, 0x06E7	; 0x8006e7 <pxDelayedTaskList>
     e0e:	f0 91 e8 06 	lds	r31, 0x06E8	; 0x8006e8 <pxDelayedTaskList+0x1>
     e12:	05 80       	ldd	r0, Z+5	; 0x05
     e14:	f6 81       	ldd	r31, Z+6	; 0x06
     e16:	e0 2d       	mov	r30, r0
     e18:	c6 81       	ldd	r28, Z+6	; 0x06
     e1a:	d7 81       	ldd	r29, Z+7	; 0x07
     e1c:	8a 81       	ldd	r24, Y+2	; 0x02
     e1e:	9b 81       	ldd	r25, Y+3	; 0x03
     e20:	e8 16       	cp	r14, r24
     e22:	f9 06       	cpc	r15, r25
     e24:	28 f4       	brcc	.+10     	; 0xe30 <xTaskIncrementTick+0xbc>
     e26:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <xNextTaskUnblockTime+0x1>
     e2a:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <xNextTaskUnblockTime>
     e2e:	2f c0       	rjmp	.+94     	; 0xe8e <xTaskIncrementTick+0x11a>
     e30:	8e 01       	movw	r16, r28
     e32:	0e 5f       	subi	r16, 0xFE	; 254
     e34:	1f 4f       	sbci	r17, 0xFF	; 255
     e36:	c8 01       	movw	r24, r16
     e38:	0e 94 2a 02 	call	0x454	; 0x454 <uxListRemove>
     e3c:	8c 89       	ldd	r24, Y+20	; 0x14
     e3e:	9d 89       	ldd	r25, Y+21	; 0x15
     e40:	89 2b       	or	r24, r25
     e42:	21 f0       	breq	.+8      	; 0xe4c <xTaskIncrementTick+0xd8>
     e44:	ce 01       	movw	r24, r28
     e46:	0c 96       	adiw	r24, 0x0c	; 12
     e48:	0e 94 2a 02 	call	0x454	; 0x454 <uxListRemove>
     e4c:	8e 89       	ldd	r24, Y+22	; 0x16
     e4e:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
     e52:	98 17       	cp	r25, r24
     e54:	10 f4       	brcc	.+4      	; 0xe5a <xTaskIncrementTick+0xe6>
     e56:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	9c 01       	movw	r18, r24
     e5e:	22 0f       	add	r18, r18
     e60:	33 1f       	adc	r19, r19
     e62:	22 0f       	add	r18, r18
     e64:	33 1f       	adc	r19, r19
     e66:	22 0f       	add	r18, r18
     e68:	33 1f       	adc	r19, r19
     e6a:	82 0f       	add	r24, r18
     e6c:	93 1f       	adc	r25, r19
     e6e:	b8 01       	movw	r22, r16
     e70:	85 50       	subi	r24, 0x05	; 5
     e72:	99 4f       	sbci	r25, 0xF9	; 249
     e74:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <vListInsertEnd>
     e78:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxCurrentTCB>
     e7c:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     e80:	9e 89       	ldd	r25, Y+22	; 0x16
     e82:	86 89       	ldd	r24, Z+22	; 0x16
     e84:	98 17       	cp	r25, r24
     e86:	08 f4       	brcc	.+2      	; 0xe8a <xTaskIncrementTick+0x116>
     e88:	b2 cf       	rjmp	.-156    	; 0xdee <xTaskIncrementTick+0x7a>
     e8a:	dc 2c       	mov	r13, r12
     e8c:	b0 cf       	rjmp	.-160    	; 0xdee <xTaskIncrementTick+0x7a>
     e8e:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxCurrentTCB>
     e92:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     e96:	86 89       	ldd	r24, Z+22	; 0x16
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	fc 01       	movw	r30, r24
     e9c:	ee 0f       	add	r30, r30
     e9e:	ff 1f       	adc	r31, r31
     ea0:	ee 0f       	add	r30, r30
     ea2:	ff 1f       	adc	r31, r31
     ea4:	ee 0f       	add	r30, r30
     ea6:	ff 1f       	adc	r31, r31
     ea8:	8e 0f       	add	r24, r30
     eaa:	9f 1f       	adc	r25, r31
     eac:	fc 01       	movw	r30, r24
     eae:	e5 50       	subi	r30, 0x05	; 5
     eb0:	f9 4f       	sbci	r31, 0xF9	; 249
     eb2:	80 81       	ld	r24, Z
     eb4:	82 30       	cpi	r24, 0x02	; 2
     eb6:	48 f0       	brcs	.+18     	; 0xeca <xTaskIncrementTick+0x156>
     eb8:	dd 24       	eor	r13, r13
     eba:	d3 94       	inc	r13
     ebc:	06 c0       	rjmp	.+12     	; 0xeca <xTaskIncrementTick+0x156>
     ebe:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxPendedTicks>
     ec2:	8f 5f       	subi	r24, 0xFF	; 255
     ec4:	80 93 cc 06 	sts	0x06CC, r24	; 0x8006cc <uxPendedTicks>
     ec8:	d1 2c       	mov	r13, r1
     eca:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xYieldPending>
     ece:	88 23       	and	r24, r24
     ed0:	11 f0       	breq	.+4      	; 0xed6 <xTaskIncrementTick+0x162>
     ed2:	dd 24       	eor	r13, r13
     ed4:	d3 94       	inc	r13
     ed6:	8d 2d       	mov	r24, r13
     ed8:	df 91       	pop	r29
     eda:	cf 91       	pop	r28
     edc:	1f 91       	pop	r17
     ede:	0f 91       	pop	r16
     ee0:	ff 90       	pop	r15
     ee2:	ef 90       	pop	r14
     ee4:	df 90       	pop	r13
     ee6:	cf 90       	pop	r12
     ee8:	08 95       	ret

00000eea <xTaskResumeAll>:
     eea:	df 92       	push	r13
     eec:	ef 92       	push	r14
     eee:	ff 92       	push	r15
     ef0:	0f 93       	push	r16
     ef2:	1f 93       	push	r17
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	0f 92       	push	r0
     efe:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     f02:	81 50       	subi	r24, 0x01	; 1
     f04:	80 93 c4 06 	sts	0x06C4, r24	; 0x8006c4 <uxSchedulerSuspended>
     f08:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
     f0c:	81 11       	cpse	r24, r1
     f0e:	5f c0       	rjmp	.+190    	; 0xfce <xTaskResumeAll+0xe4>
     f10:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxCurrentNumberOfTasks>
     f14:	81 11       	cpse	r24, r1
     f16:	33 c0       	rjmp	.+102    	; 0xf7e <xTaskResumeAll+0x94>
     f18:	5d c0       	rjmp	.+186    	; 0xfd4 <xTaskResumeAll+0xea>
     f1a:	d7 01       	movw	r26, r14
     f1c:	15 96       	adiw	r26, 0x05	; 5
     f1e:	ed 91       	ld	r30, X+
     f20:	fc 91       	ld	r31, X
     f22:	16 97       	sbiw	r26, 0x06	; 6
     f24:	c6 81       	ldd	r28, Z+6	; 0x06
     f26:	d7 81       	ldd	r29, Z+7	; 0x07
     f28:	ce 01       	movw	r24, r28
     f2a:	0c 96       	adiw	r24, 0x0c	; 12
     f2c:	0e 94 2a 02 	call	0x454	; 0x454 <uxListRemove>
     f30:	8e 01       	movw	r16, r28
     f32:	0e 5f       	subi	r16, 0xFE	; 254
     f34:	1f 4f       	sbci	r17, 0xFF	; 255
     f36:	c8 01       	movw	r24, r16
     f38:	0e 94 2a 02 	call	0x454	; 0x454 <uxListRemove>
     f3c:	8e 89       	ldd	r24, Y+22	; 0x16
     f3e:	90 91 ce 06 	lds	r25, 0x06CE	; 0x8006ce <uxTopReadyPriority>
     f42:	98 17       	cp	r25, r24
     f44:	10 f4       	brcc	.+4      	; 0xf4a <xTaskResumeAll+0x60>
     f46:	80 93 ce 06 	sts	0x06CE, r24	; 0x8006ce <uxTopReadyPriority>
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	9c 01       	movw	r18, r24
     f4e:	22 0f       	add	r18, r18
     f50:	33 1f       	adc	r19, r19
     f52:	22 0f       	add	r18, r18
     f54:	33 1f       	adc	r19, r19
     f56:	22 0f       	add	r18, r18
     f58:	33 1f       	adc	r19, r19
     f5a:	82 0f       	add	r24, r18
     f5c:	93 1f       	adc	r25, r19
     f5e:	b8 01       	movw	r22, r16
     f60:	85 50       	subi	r24, 0x05	; 5
     f62:	99 4f       	sbci	r25, 0xF9	; 249
     f64:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <vListInsertEnd>
     f68:	e0 91 1f 07 	lds	r30, 0x071F	; 0x80071f <pxCurrentTCB>
     f6c:	f0 91 20 07 	lds	r31, 0x0720	; 0x800720 <pxCurrentTCB+0x1>
     f70:	9e 89       	ldd	r25, Y+22	; 0x16
     f72:	86 89       	ldd	r24, Z+22	; 0x16
     f74:	98 17       	cp	r25, r24
     f76:	68 f0       	brcs	.+26     	; 0xf92 <xTaskResumeAll+0xa8>
     f78:	d0 92 cb 06 	sts	0x06CB, r13	; 0x8006cb <xYieldPending>
     f7c:	0a c0       	rjmp	.+20     	; 0xf92 <xTaskResumeAll+0xa8>
     f7e:	c0 e0       	ldi	r28, 0x00	; 0
     f80:	d0 e0       	ldi	r29, 0x00	; 0
     f82:	0f 2e       	mov	r0, r31
     f84:	fc ed       	ldi	r31, 0xDC	; 220
     f86:	ef 2e       	mov	r14, r31
     f88:	f6 e0       	ldi	r31, 0x06	; 6
     f8a:	ff 2e       	mov	r15, r31
     f8c:	f0 2d       	mov	r31, r0
     f8e:	dd 24       	eor	r13, r13
     f90:	d3 94       	inc	r13
     f92:	f7 01       	movw	r30, r14
     f94:	80 81       	ld	r24, Z
     f96:	81 11       	cpse	r24, r1
     f98:	c0 cf       	rjmp	.-128    	; 0xf1a <xTaskResumeAll+0x30>
     f9a:	cd 2b       	or	r28, r29
     f9c:	11 f0       	breq	.+4      	; 0xfa2 <xTaskResumeAll+0xb8>
     f9e:	0e 94 e5 04 	call	0x9ca	; 0x9ca <prvResetNextTaskUnblockTime>
     fa2:	c0 91 cc 06 	lds	r28, 0x06CC	; 0x8006cc <uxPendedTicks>
     fa6:	cc 23       	and	r28, r28
     fa8:	51 f0       	breq	.+20     	; 0xfbe <xTaskResumeAll+0xd4>
     faa:	d1 e0       	ldi	r29, 0x01	; 1
     fac:	0e 94 ba 06 	call	0xd74	; 0xd74 <xTaskIncrementTick>
     fb0:	81 11       	cpse	r24, r1
     fb2:	d0 93 cb 06 	sts	0x06CB, r29	; 0x8006cb <xYieldPending>
     fb6:	c1 50       	subi	r28, 0x01	; 1
     fb8:	c9 f7       	brne	.-14     	; 0xfac <xTaskResumeAll+0xc2>
     fba:	10 92 cc 06 	sts	0x06CC, r1	; 0x8006cc <uxPendedTicks>
     fbe:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xYieldPending>
     fc2:	88 23       	and	r24, r24
     fc4:	31 f0       	breq	.+12     	; 0xfd2 <xTaskResumeAll+0xe8>
     fc6:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <vPortYield>
     fca:	81 e0       	ldi	r24, 0x01	; 1
     fcc:	03 c0       	rjmp	.+6      	; 0xfd4 <xTaskResumeAll+0xea>
     fce:	80 e0       	ldi	r24, 0x00	; 0
     fd0:	01 c0       	rjmp	.+2      	; 0xfd4 <xTaskResumeAll+0xea>
     fd2:	80 e0       	ldi	r24, 0x00	; 0
     fd4:	0f 90       	pop	r0
     fd6:	0f be       	out	0x3f, r0	; 63
     fd8:	df 91       	pop	r29
     fda:	cf 91       	pop	r28
     fdc:	1f 91       	pop	r17
     fde:	0f 91       	pop	r16
     fe0:	ff 90       	pop	r15
     fe2:	ef 90       	pop	r14
     fe4:	df 90       	pop	r13
     fe6:	08 95       	ret

00000fe8 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     fe8:	cf 93       	push	r28
     fea:	df 93       	push	r29
     fec:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     fee:	89 2b       	or	r24, r25
     ff0:	51 f0       	breq	.+20     	; 0x1006 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     ff2:	0e 94 b4 06 	call	0xd68	; 0xd68 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     ff6:	60 e0       	ldi	r22, 0x00	; 0
     ff8:	ce 01       	movw	r24, r28
     ffa:	0e 94 04 05 	call	0xa08	; 0xa08 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     ffe:	0e 94 75 07 	call	0xeea	; 0xeea <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1002:	81 11       	cpse	r24, r1
    1004:	02 c0       	rjmp	.+4      	; 0x100a <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    1006:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    100a:	df 91       	pop	r29
    100c:	cf 91       	pop	r28
    100e:	08 95       	ret

00001010 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1010:	80 91 c4 06 	lds	r24, 0x06C4	; 0x8006c4 <uxSchedulerSuspended>
    1014:	88 23       	and	r24, r24
    1016:	21 f0       	breq	.+8      	; 0x1020 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <xYieldPending>
    101e:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1020:	10 92 cb 06 	sts	0x06CB, r1	; 0x8006cb <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1024:	20 91 ce 06 	lds	r18, 0x06CE	; 0x8006ce <uxTopReadyPriority>
    1028:	82 2f       	mov	r24, r18
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	fc 01       	movw	r30, r24
    102e:	ee 0f       	add	r30, r30
    1030:	ff 1f       	adc	r31, r31
    1032:	ee 0f       	add	r30, r30
    1034:	ff 1f       	adc	r31, r31
    1036:	ee 0f       	add	r30, r30
    1038:	ff 1f       	adc	r31, r31
    103a:	e8 0f       	add	r30, r24
    103c:	f9 1f       	adc	r31, r25
    103e:	e5 50       	subi	r30, 0x05	; 5
    1040:	f9 4f       	sbci	r31, 0xF9	; 249
    1042:	30 81       	ld	r19, Z
    1044:	31 11       	cpse	r19, r1
    1046:	11 c0       	rjmp	.+34     	; 0x106a <vTaskSwitchContext+0x5a>
    1048:	21 50       	subi	r18, 0x01	; 1
    104a:	82 2f       	mov	r24, r18
    104c:	90 e0       	ldi	r25, 0x00	; 0
    104e:	fc 01       	movw	r30, r24
    1050:	ee 0f       	add	r30, r30
    1052:	ff 1f       	adc	r31, r31
    1054:	ee 0f       	add	r30, r30
    1056:	ff 1f       	adc	r31, r31
    1058:	ee 0f       	add	r30, r30
    105a:	ff 1f       	adc	r31, r31
    105c:	e8 0f       	add	r30, r24
    105e:	f9 1f       	adc	r31, r25
    1060:	e5 50       	subi	r30, 0x05	; 5
    1062:	f9 4f       	sbci	r31, 0xF9	; 249
    1064:	30 81       	ld	r19, Z
    1066:	33 23       	and	r19, r19
    1068:	79 f3       	breq	.-34     	; 0x1048 <vTaskSwitchContext+0x38>
    106a:	ac 01       	movw	r20, r24
    106c:	44 0f       	add	r20, r20
    106e:	55 1f       	adc	r21, r21
    1070:	44 0f       	add	r20, r20
    1072:	55 1f       	adc	r21, r21
    1074:	44 0f       	add	r20, r20
    1076:	55 1f       	adc	r21, r21
    1078:	48 0f       	add	r20, r24
    107a:	59 1f       	adc	r21, r25
    107c:	da 01       	movw	r26, r20
    107e:	a5 50       	subi	r26, 0x05	; 5
    1080:	b9 4f       	sbci	r27, 0xF9	; 249
    1082:	11 96       	adiw	r26, 0x01	; 1
    1084:	ed 91       	ld	r30, X+
    1086:	fc 91       	ld	r31, X
    1088:	12 97       	sbiw	r26, 0x02	; 2
    108a:	02 80       	ldd	r0, Z+2	; 0x02
    108c:	f3 81       	ldd	r31, Z+3	; 0x03
    108e:	e0 2d       	mov	r30, r0
    1090:	12 96       	adiw	r26, 0x02	; 2
    1092:	fc 93       	st	X, r31
    1094:	ee 93       	st	-X, r30
    1096:	11 97       	sbiw	r26, 0x01	; 1
    1098:	42 50       	subi	r20, 0x02	; 2
    109a:	59 4f       	sbci	r21, 0xF9	; 249
    109c:	e4 17       	cp	r30, r20
    109e:	f5 07       	cpc	r31, r21
    10a0:	29 f4       	brne	.+10     	; 0x10ac <vTaskSwitchContext+0x9c>
    10a2:	42 81       	ldd	r20, Z+2	; 0x02
    10a4:	53 81       	ldd	r21, Z+3	; 0x03
    10a6:	fd 01       	movw	r30, r26
    10a8:	52 83       	std	Z+2, r21	; 0x02
    10aa:	41 83       	std	Z+1, r20	; 0x01
    10ac:	fc 01       	movw	r30, r24
    10ae:	ee 0f       	add	r30, r30
    10b0:	ff 1f       	adc	r31, r31
    10b2:	ee 0f       	add	r30, r30
    10b4:	ff 1f       	adc	r31, r31
    10b6:	ee 0f       	add	r30, r30
    10b8:	ff 1f       	adc	r31, r31
    10ba:	8e 0f       	add	r24, r30
    10bc:	9f 1f       	adc	r25, r31
    10be:	fc 01       	movw	r30, r24
    10c0:	e5 50       	subi	r30, 0x05	; 5
    10c2:	f9 4f       	sbci	r31, 0xF9	; 249
    10c4:	01 80       	ldd	r0, Z+1	; 0x01
    10c6:	f2 81       	ldd	r31, Z+2	; 0x02
    10c8:	e0 2d       	mov	r30, r0
    10ca:	86 81       	ldd	r24, Z+6	; 0x06
    10cc:	97 81       	ldd	r25, Z+7	; 0x07
    10ce:	90 93 20 07 	sts	0x0720, r25	; 0x800720 <pxCurrentTCB+0x1>
    10d2:	80 93 1f 07 	sts	0x071F, r24	; 0x80071f <pxCurrentTCB>
    10d6:	20 93 ce 06 	sts	0x06CE, r18	; 0x8006ce <uxTopReadyPriority>
    10da:	08 95       	ret

000010dc <LCDWriteByte>:
	_delay_ms(100);
}

void LCDWriteByte(_LCDRegister reg, uint8_t data)
{
	LCD_PORT&=LCD_MASK;
    10dc:	9b b3       	in	r25, 0x1b	; 27
    10de:	90 7c       	andi	r25, 0xC0	; 192
    10e0:	9b bb       	out	0x1b, r25	; 27
	
	if(reg)LCD_PORT|=LCD_RS;
    10e2:	81 11       	cpse	r24, r1
    10e4:	dc 9a       	sbi	0x1b, 4	; 27
	
	LCD_PORT|=data>>4;
    10e6:	8b b3       	in	r24, 0x1b	; 27
    10e8:	96 2f       	mov	r25, r22
    10ea:	92 95       	swap	r25
    10ec:	9f 70       	andi	r25, 0x0F	; 15
    10ee:	89 2b       	or	r24, r25
    10f0:	8b bb       	out	0x1b, r24	; 27
	LCD_PORT|=LCD_E;
    10f2:	dd 9a       	sbi	0x1b, 5	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10f4:	8d e0       	ldi	r24, 0x0D	; 13
    10f6:	8a 95       	dec	r24
    10f8:	f1 f7       	brne	.-4      	; 0x10f6 <LCDWriteByte+0x1a>
    10fa:	00 00       	nop
	_delay_us(40);
	LCD_PORT&=~LCD_E;
    10fc:	dd 98       	cbi	0x1b, 5	; 27
    10fe:	8d e0       	ldi	r24, 0x0D	; 13
    1100:	8a 95       	dec	r24
    1102:	f1 f7       	brne	.-4      	; 0x1100 <LCDWriteByte+0x24>
    1104:	00 00       	nop
	_delay_us(40);
	
	LCD_PORT&=0xf0;
    1106:	8b b3       	in	r24, 0x1b	; 27
    1108:	80 7f       	andi	r24, 0xF0	; 240
    110a:	8b bb       	out	0x1b, r24	; 27
	
	LCD_PORT|=data&0x0f;
    110c:	8b b3       	in	r24, 0x1b	; 27
    110e:	6f 70       	andi	r22, 0x0F	; 15
    1110:	68 2b       	or	r22, r24
    1112:	6b bb       	out	0x1b, r22	; 27
	LCD_PORT|=LCD_E;
    1114:	dd 9a       	sbi	0x1b, 5	; 27
    1116:	8d e0       	ldi	r24, 0x0D	; 13
    1118:	8a 95       	dec	r24
    111a:	f1 f7       	brne	.-4      	; 0x1118 <LCDWriteByte+0x3c>
    111c:	00 00       	nop
	_delay_us(40);
	LCD_PORT&=~LCD_E;
    111e:	dd 98       	cbi	0x1b, 5	; 27
    1120:	8d e0       	ldi	r24, 0x0D	; 13
    1122:	8a 95       	dec	r24
    1124:	f1 f7       	brne	.-4      	; 0x1122 <LCDWriteByte+0x46>
    1126:	00 00       	nop
    1128:	08 95       	ret

0000112a <LCDInit>:
#define LCD_E (1<<5)
#define LCD_MASK 0xC0

void LCDInit()
{
	DDRA|=~LCD_MASK;
    112a:	8a b3       	in	r24, 0x1a	; 26
    112c:	8f 63       	ori	r24, 0x3F	; 63
    112e:	8a bb       	out	0x1a, r24	; 26
	LCDWriteByte(LCD_IR, 0x33);
    1130:	63 e3       	ldi	r22, 0x33	; 51
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1138:	87 ea       	ldi	r24, 0xA7	; 167
    113a:	91 e6       	ldi	r25, 0x61	; 97
    113c:	01 97       	sbiw	r24, 0x01	; 1
    113e:	f1 f7       	brne	.-4      	; 0x113c <LCDInit+0x12>
    1140:	00 c0       	rjmp	.+0      	; 0x1142 <LCDInit+0x18>
    1142:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x32);
    1144:	62 e3       	ldi	r22, 0x32	; 50
    1146:	80 e0       	ldi	r24, 0x00	; 0
    1148:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
    114c:	87 ea       	ldi	r24, 0xA7	; 167
    114e:	91 e6       	ldi	r25, 0x61	; 97
    1150:	01 97       	sbiw	r24, 0x01	; 1
    1152:	f1 f7       	brne	.-4      	; 0x1150 <LCDInit+0x26>
    1154:	00 c0       	rjmp	.+0      	; 0x1156 <LCDInit+0x2c>
    1156:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x28);
    1158:	68 e2       	ldi	r22, 0x28	; 40
    115a:	80 e0       	ldi	r24, 0x00	; 0
    115c:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
    1160:	87 ea       	ldi	r24, 0xA7	; 167
    1162:	91 e6       	ldi	r25, 0x61	; 97
    1164:	01 97       	sbiw	r24, 0x01	; 1
    1166:	f1 f7       	brne	.-4      	; 0x1164 <LCDInit+0x3a>
    1168:	00 c0       	rjmp	.+0      	; 0x116a <LCDInit+0x40>
    116a:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x01);
    116c:	61 e0       	ldi	r22, 0x01	; 1
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
    1174:	87 ea       	ldi	r24, 0xA7	; 167
    1176:	91 e6       	ldi	r25, 0x61	; 97
    1178:	01 97       	sbiw	r24, 0x01	; 1
    117a:	f1 f7       	brne	.-4      	; 0x1178 <LCDInit+0x4e>
    117c:	00 c0       	rjmp	.+0      	; 0x117e <LCDInit+0x54>
    117e:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x0c);
    1180:	6c e0       	ldi	r22, 0x0C	; 12
    1182:	80 e0       	ldi	r24, 0x00	; 0
    1184:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
    1188:	87 ea       	ldi	r24, 0xA7	; 167
    118a:	91 e6       	ldi	r25, 0x61	; 97
    118c:	01 97       	sbiw	r24, 0x01	; 1
    118e:	f1 f7       	brne	.-4      	; 0x118c <LCDInit+0x62>
    1190:	00 c0       	rjmp	.+0      	; 0x1192 <LCDInit+0x68>
    1192:	00 00       	nop
    1194:	08 95       	ret

00001196 <LCDKursorPosihin>:
	_delay_us(40);
}

void LCDKursorPosihin(uint8_t row, uint8_t col)
{
	if(!row) {
    1196:	81 11       	cpse	r24, r1
    1198:	04 c0       	rjmp	.+8      	; 0x11a2 <LCDKursorPosihin+0xc>
		LCDWriteByte(LCD_IR, (1<<7)|col);
    119a:	60 68       	ori	r22, 0x80	; 128
    119c:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
    11a0:	08 95       	ret
	}
	else{
		LCDWriteByte(LCD_IR, (3<<6)|col);
    11a2:	60 6c       	ori	r22, 0xC0	; 192
    11a4:	80 e0       	ldi	r24, 0x00	; 0
    11a6:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
    11aa:	08 95       	ret

000011ac <main>:

void vClockHandler (void *pvParameters);

int main(void)
{
	xTaskCreate(vClockHandler, (char*) "Task", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
    11ac:	e1 2c       	mov	r14, r1
    11ae:	f1 2c       	mov	r15, r1
    11b0:	01 e0       	ldi	r16, 0x01	; 1
    11b2:	20 e0       	ldi	r18, 0x00	; 0
    11b4:	30 e0       	ldi	r19, 0x00	; 0
    11b6:	45 e5       	ldi	r20, 0x55	; 85
    11b8:	50 e0       	ldi	r21, 0x00	; 0
    11ba:	65 ed       	ldi	r22, 0xD5	; 213
    11bc:	70 e0       	ldi	r23, 0x00	; 0
    11be:	8f e6       	ldi	r24, 0x6F	; 111
    11c0:	99 e0       	ldi	r25, 0x09	; 9
    11c2:	0e 94 82 05 	call	0xb04	; 0xb04 <xTaskCreate>
	vTaskStartScheduler();
    11c6:	0e 94 8a 06 	call	0xd14	; 0xd14 <vTaskStartScheduler>
    11ca:	ff cf       	rjmp	.-2      	; 0x11ca <main+0x1e>

000011cc <vApplicationIdleHook>:
    while (1)
    {
    }
}

void vApplicationIdleHook() {} // ???????? ??? idle ??????
    11cc:	08 95       	ret

000011ce <initTimerCounter>:
    } 
}

void initTimerCounter() // ????????????? ??????
{
	TCNT1 = 0;
    11ce:	1d bc       	out	0x2d, r1	; 45
    11d0:	1c bc       	out	0x2c, r1	; 44
	TCCR1B |= (1<<CS10) | (1<<CS11) | (0<<CS12);
    11d2:	8e b5       	in	r24, 0x2e	; 46
    11d4:	83 60       	ori	r24, 0x03	; 3
    11d6:	8e bd       	out	0x2e, r24	; 46
	TIMSK |= (1 << OCIE1B);
    11d8:	89 b7       	in	r24, 0x39	; 57
    11da:	88 60       	ori	r24, 0x08	; 8
    11dc:	89 bf       	out	0x39, r24	; 57
	OCR1BH = 0b00111101;
    11de:	8d e3       	ldi	r24, 0x3D	; 61
    11e0:	89 bd       	out	0x29, r24	; 41
	OCR1BL = 0b00001001;
    11e2:	89 e0       	ldi	r24, 0x09	; 9
    11e4:	88 bd       	out	0x28, r24	; 40

	//fast mode: 1 second = 1 hour
	//OCR1BH = 0b00000001;
	//OCR1BL = 0b00000100;
	sei();
    11e6:	78 94       	sei
    11e8:	08 95       	ret

000011ea <__vector_8>:
}


ISR(TIMER1_COMPB_vect) { // ?????????? ??????-????????
    11ea:	1f 92       	push	r1
    11ec:	0f 92       	push	r0
    11ee:	0f b6       	in	r0, 0x3f	; 63
    11f0:	0f 92       	push	r0
    11f2:	11 24       	eor	r1, r1
    11f4:	2f 93       	push	r18
    11f6:	3f 93       	push	r19
    11f8:	4f 93       	push	r20
    11fa:	5f 93       	push	r21
    11fc:	6f 93       	push	r22
    11fe:	7f 93       	push	r23
    1200:	8f 93       	push	r24
    1202:	9f 93       	push	r25
    1204:	af 93       	push	r26
    1206:	bf 93       	push	r27
    1208:	ef 93       	push	r30
    120a:	ff 93       	push	r31
	computeTimeArray();
    120c:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <computeTimeArray>
	TCNT1 = 0;
    1210:	1d bc       	out	0x2d, r1	; 45
    1212:	1c bc       	out	0x2c, r1	; 44
}
    1214:	ff 91       	pop	r31
    1216:	ef 91       	pop	r30
    1218:	bf 91       	pop	r27
    121a:	af 91       	pop	r26
    121c:	9f 91       	pop	r25
    121e:	8f 91       	pop	r24
    1220:	7f 91       	pop	r23
    1222:	6f 91       	pop	r22
    1224:	5f 91       	pop	r21
    1226:	4f 91       	pop	r20
    1228:	3f 91       	pop	r19
    122a:	2f 91       	pop	r18
    122c:	0f 90       	pop	r0
    122e:	0f be       	out	0x3f, r0	; 63
    1230:	0f 90       	pop	r0
    1232:	1f 90       	pop	r1
    1234:	18 95       	reti

00001236 <computePosition>:


void computePosition()
{
	switch(PIND)
    1236:	80 b3       	in	r24, 0x10	; 16
    1238:	8f 3b       	cpi	r24, 0xBF	; 191
    123a:	51 f0       	breq	.+20     	; 0x1250 <computePosition+0x1a>
    123c:	8f 3d       	cpi	r24, 0xDF	; 223
    123e:	19 f0       	breq	.+6      	; 0x1246 <computePosition+0x10>
    1240:	8f 37       	cpi	r24, 0x7F	; 127
    1242:	a1 f4       	brne	.+40     	; 0x126c <computePosition+0x36>
    1244:	0c c0       	rjmp	.+24     	; 0x125e <computePosition+0x28>
	{
		case CHANGING:
		flagMoovingSpeed = 0;
    1246:	10 92 22 07 	sts	0x0722, r1	; 0x800722 <flagMoovingSpeed+0x1>
    124a:	10 92 21 07 	sts	0x0721, r1	; 0x800721 <flagMoovingSpeed>
    124e:	1a c0       	rjmp	.+52     	; 0x1284 <computePosition+0x4e>
		break;
		case RIGHT:
		flagMoovingSpeed = 1;
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <flagMoovingSpeed+0x1>
    1258:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <flagMoovingSpeed>
    125c:	18 c0       	rjmp	.+48     	; 0x128e <computePosition+0x58>
		break;
		case LEFT:
		flagMoovingSpeed = 2;
    125e:	82 e0       	ldi	r24, 0x02	; 2
    1260:	90 e0       	ldi	r25, 0x00	; 0
    1262:	90 93 22 07 	sts	0x0722, r25	; 0x800722 <flagMoovingSpeed+0x1>
    1266:	80 93 21 07 	sts	0x0721, r24	; 0x800721 <flagMoovingSpeed>
    126a:	16 c0       	rjmp	.+44     	; 0x1298 <computePosition+0x62>
		break;
	}
	
	switch(flagMoovingSpeed)
    126c:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <flagMoovingSpeed>
    1270:	90 91 22 07 	lds	r25, 0x0722	; 0x800722 <flagMoovingSpeed+0x1>
    1274:	81 30       	cpi	r24, 0x01	; 1
    1276:	91 05       	cpc	r25, r1
    1278:	51 f0       	breq	.+20     	; 0x128e <computePosition+0x58>
    127a:	82 30       	cpi	r24, 0x02	; 2
    127c:	91 05       	cpc	r25, r1
    127e:	61 f0       	breq	.+24     	; 0x1298 <computePosition+0x62>
    1280:	89 2b       	or	r24, r25
    1282:	71 f4       	brne	.+28     	; 0x12a0 <computePosition+0x6a>
	{
		case 0:
		 vTaskDelay(150);
    1284:	86 e9       	ldi	r24, 0x96	; 150
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vTaskDelay>
		break;
    128c:	09 c0       	rjmp	.+18     	; 0x12a0 <computePosition+0x6a>
		case 1:
		 vTaskDelay(500);
    128e:	84 ef       	ldi	r24, 0xF4	; 244
    1290:	91 e0       	ldi	r25, 0x01	; 1
    1292:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vTaskDelay>
		break;
    1296:	04 c0       	rjmp	.+8      	; 0x12a0 <computePosition+0x6a>
		case 2:
		 vTaskDelay(1000);
    1298:	88 ee       	ldi	r24, 0xE8	; 232
    129a:	93 e0       	ldi	r25, 0x03	; 3
    129c:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vTaskDelay>
		break;
	}
	if (positionOnDisplay == 5 || positionOnDisplay == 0)
    12a0:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <positionOnDisplay>
    12a4:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <positionOnDisplay+0x1>
    12a8:	85 30       	cpi	r24, 0x05	; 5
    12aa:	91 05       	cpc	r25, r1
    12ac:	11 f0       	breq	.+4      	; 0x12b2 <computePosition+0x7c>
    12ae:	00 97       	sbiw	r24, 0x00	; 0
    12b0:	31 f4       	brne	.+12     	; 0x12be <computePosition+0x88>
	isGoingLeft = !isGoingLeft;
    12b2:	30 91 90 00 	lds	r19, 0x0090	; 0x800090 <isGoingLeft>
    12b6:	21 e0       	ldi	r18, 0x01	; 1
    12b8:	23 27       	eor	r18, r19
    12ba:	20 93 90 00 	sts	0x0090, r18	; 0x800090 <isGoingLeft>

	isGoingLeft ? positionOnDisplay-- : positionOnDisplay++;
    12be:	20 91 90 00 	lds	r18, 0x0090	; 0x800090 <isGoingLeft>
    12c2:	22 23       	and	r18, r18
    12c4:	31 f0       	breq	.+12     	; 0x12d2 <computePosition+0x9c>
    12c6:	01 97       	sbiw	r24, 0x01	; 1
    12c8:	90 93 24 07 	sts	0x0724, r25	; 0x800724 <positionOnDisplay+0x1>
    12cc:	80 93 23 07 	sts	0x0723, r24	; 0x800723 <positionOnDisplay>
    12d0:	08 95       	ret
    12d2:	01 96       	adiw	r24, 0x01	; 1
    12d4:	90 93 24 07 	sts	0x0724, r25	; 0x800724 <positionOnDisplay+0x1>
    12d8:	80 93 23 07 	sts	0x0723, r24	; 0x800723 <positionOnDisplay>
    12dc:	08 95       	ret

000012de <vClockHandler>:

void vApplicationIdleHook() {} // ???????? ??? idle ??????

void vClockHandler(void *pvParameters) 
{ 
    initTimerCounter(); 
    12de:	0e 94 e7 08 	call	0x11ce	; 0x11ce <initTimerCounter>

    LCDInit(); 
    12e2:	0e 94 95 08 	call	0x112a	; 0x112a <LCDInit>
    nullifyTimeArray(); 
    12e6:	0e 94 c6 09 	call	0x138c	; 0x138c <nullifyTimeArray>
    nullifyDataArray(); 
    12ea:	0e 94 49 00 	call	0x92	; 0x92 <nullifyDataArray>
    while (1) 
    { 
        computePosition(); 
    12ee:	0e 94 1b 09 	call	0x1236	; 0x1236 <computePosition>
        displayTime(positionOnDisplay); 
    12f2:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <positionOnDisplay>
    12f6:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <positionOnDisplay+0x1>
    12fa:	0e 94 b5 09 	call	0x136a	; 0x136a <displayTime>
        displayData(positionOnDisplay); 
    12fe:	80 91 23 07 	lds	r24, 0x0723	; 0x800723 <positionOnDisplay>
    1302:	90 91 24 07 	lds	r25, 0x0724	; 0x800724 <positionOnDisplay+0x1>
    1306:	0e 94 c4 00 	call	0x188	; 0x188 <displayData>
        vTaskDelay(100); 
    130a:	84 e6       	ldi	r24, 0x64	; 100
    130c:	90 e0       	ldi	r25, 0x00	; 0
    130e:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vTaskDelay>
    1312:	ed cf       	rjmp	.-38     	; 0x12ee <vClockHandler+0x10>

00001314 <clearDisplayFirstLine>:
	timeArrayToDisplayFirstLine(positionOnDisplay);
	showDisplayFirstLine();
}

void clearDisplayFirstLine() //  
{
    1314:	eb e5       	ldi	r30, 0x5B	; 91
    1316:	f7 e0       	ldi	r31, 0x07	; 7
    1318:	2b e6       	ldi	r18, 0x6B	; 107
    131a:	37 e0       	ldi	r19, 0x07	; 7
	for (int i = 0; i < 16; i++)
	{
		displayFirstLine[i] = ' ';
    131c:	80 e2       	ldi	r24, 0x20	; 32
    131e:	81 93       	st	Z+, r24
	showDisplayFirstLine();
}

void clearDisplayFirstLine() //  
{
	for (int i = 0; i < 16; i++)
    1320:	e2 17       	cp	r30, r18
    1322:	f3 07       	cpc	r31, r19
    1324:	e1 f7       	brne	.-8      	; 0x131e <clearDisplayFirstLine+0xa>
	{
		displayFirstLine[i] = ' ';
	}
}
    1326:	08 95       	ret

00001328 <timeArrayToDisplayFirstLine>:

void timeArrayToDisplayFirstLine(int positionOnDisplay)
{
    1328:	eb e6       	ldi	r30, 0x6B	; 107
    132a:	f7 e0       	ldi	r31, 0x07	; 7
    132c:	dc 01       	movw	r26, r24
    132e:	a2 5a       	subi	r26, 0xA2	; 162
    1330:	b8 4f       	sbci	r27, 0xF8	; 248
    1332:	23 e7       	ldi	r18, 0x73	; 115
    1334:	37 e0       	ldi	r19, 0x07	; 7
	for(int i = 0; i<8; i++)
	{
		// +3     ,  
		displayFirstLine[positionOnDisplay + i + 3] = time[i];
    1336:	81 91       	ld	r24, Z+
    1338:	8d 93       	st	X+, r24
	}
}

void timeArrayToDisplayFirstLine(int positionOnDisplay)
{
	for(int i = 0; i<8; i++)
    133a:	e2 17       	cp	r30, r18
    133c:	f3 07       	cpc	r31, r19
    133e:	d9 f7       	brne	.-10     	; 0x1336 <timeArrayToDisplayFirstLine+0xe>
	{
		// +3     ,  
		displayFirstLine[positionOnDisplay + i + 3] = time[i];
	}
}
    1340:	08 95       	ret

00001342 <showDisplayFirstLine>:

void showDisplayFirstLine()
{
    1342:	0f 93       	push	r16
    1344:	1f 93       	push	r17
    1346:	cf 93       	push	r28
    1348:	df 93       	push	r29
    134a:	cb e5       	ldi	r28, 0x5B	; 91
    134c:	d7 e0       	ldi	r29, 0x07	; 7
    134e:	0b e6       	ldi	r16, 0x6B	; 107
    1350:	17 e0       	ldi	r17, 0x07	; 7
	for(int i = 0; i < 16; i++)
	{
		LCDWriteByte(LCD_DR, displayFirstLine[i]);
    1352:	69 91       	ld	r22, Y+
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
	}
}

void showDisplayFirstLine()
{
	for(int i = 0; i < 16; i++)
    135a:	c0 17       	cp	r28, r16
    135c:	d1 07       	cpc	r29, r17
    135e:	c9 f7       	brne	.-14     	; 0x1352 <showDisplayFirstLine+0x10>
	{
		LCDWriteByte(LCD_DR, displayFirstLine[i]);
	}
}
    1360:	df 91       	pop	r29
    1362:	cf 91       	pop	r28
    1364:	1f 91       	pop	r17
    1366:	0f 91       	pop	r16
    1368:	08 95       	ret

0000136a <displayTime>:
#include "LCD.h"

uint8_t displayFirstLine[16], count_timer = 0, time[8];

void displayTime(int positionOnDisplay)
{
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	ec 01       	movw	r28, r24
	LCDWriteByte(LCD_IR, 0b10000000);
    1370:	60 e8       	ldi	r22, 0x80	; 128
    1372:	80 e0       	ldi	r24, 0x00	; 0
    1374:	0e 94 6e 08 	call	0x10dc	; 0x10dc <LCDWriteByte>
	clearDisplayFirstLine();
    1378:	0e 94 8a 09 	call	0x1314	; 0x1314 <clearDisplayFirstLine>
	timeArrayToDisplayFirstLine(positionOnDisplay);
    137c:	ce 01       	movw	r24, r28
    137e:	0e 94 94 09 	call	0x1328	; 0x1328 <timeArrayToDisplayFirstLine>
	showDisplayFirstLine();
    1382:	0e 94 a1 09 	call	0x1342	; 0x1342 <showDisplayFirstLine>
}
    1386:	df 91       	pop	r29
    1388:	cf 91       	pop	r28
    138a:	08 95       	ret

0000138c <nullifyTimeArray>:
	time[0]++;
}

void nullifyTimeArray()
{
	time[0] = '0';
    138c:	eb e6       	ldi	r30, 0x6B	; 107
    138e:	f7 e0       	ldi	r31, 0x07	; 7
    1390:	80 e3       	ldi	r24, 0x30	; 48
    1392:	80 83       	st	Z, r24
	time[1] = '0';
    1394:	81 83       	std	Z+1, r24	; 0x01
	time[2] = ':';
    1396:	9a e3       	ldi	r25, 0x3A	; 58
    1398:	92 83       	std	Z+2, r25	; 0x02
	time[3] = '0';
    139a:	83 83       	std	Z+3, r24	; 0x03
	time[4] = '0';
    139c:	84 83       	std	Z+4, r24	; 0x04
	time[5] = ':';
    139e:	95 83       	std	Z+5, r25	; 0x05
	time[6] = '0';
    13a0:	86 83       	std	Z+6, r24	; 0x06
	time[7] = '0';
    13a2:	87 83       	std	Z+7, r24	; 0x07
    13a4:	08 95       	ret

000013a6 <computeTimeArray>:
	}
}

void computeTimeArray() //    
{
	time[7]++;
    13a6:	80 91 72 07 	lds	r24, 0x0772	; 0x800772 <time+0x7>
    13aa:	8f 5f       	subi	r24, 0xFF	; 255
	if (time[7] <= '9')	return;
    13ac:	8a 33       	cpi	r24, 0x3A	; 58
    13ae:	18 f4       	brcc	.+6      	; 0x13b6 <computeTimeArray+0x10>
	}
}

void computeTimeArray() //    
{
	time[7]++;
    13b0:	80 93 72 07 	sts	0x0772, r24	; 0x800772 <time+0x7>
    13b4:	08 95       	ret
	if (time[7] <= '9')	return;
	
	time[7] = '0';
    13b6:	eb e6       	ldi	r30, 0x6B	; 107
    13b8:	f7 e0       	ldi	r31, 0x07	; 7
    13ba:	80 e3       	ldi	r24, 0x30	; 48
    13bc:	87 83       	std	Z+7, r24	; 0x07
	time[6]++;
    13be:	86 81       	ldd	r24, Z+6	; 0x06
    13c0:	8f 5f       	subi	r24, 0xFF	; 255
	if (time[6] < '6') return;
    13c2:	86 33       	cpi	r24, 0x36	; 54
    13c4:	18 f4       	brcc	.+6      	; 0x13cc <computeTimeArray+0x26>
{
	time[7]++;
	if (time[7] <= '9')	return;
	
	time[7] = '0';
	time[6]++;
    13c6:	80 93 71 07 	sts	0x0771, r24	; 0x800771 <time+0x6>
    13ca:	08 95       	ret
	if (time[6] < '6') return;

	time[6] = '0';
    13cc:	eb e6       	ldi	r30, 0x6B	; 107
    13ce:	f7 e0       	ldi	r31, 0x07	; 7
    13d0:	80 e3       	ldi	r24, 0x30	; 48
    13d2:	86 83       	std	Z+6, r24	; 0x06
	time[4]++;
    13d4:	84 81       	ldd	r24, Z+4	; 0x04
    13d6:	8f 5f       	subi	r24, 0xFF	; 255
	if (time[4] <= '9')	return;
    13d8:	8a 33       	cpi	r24, 0x3A	; 58
    13da:	18 f4       	brcc	.+6      	; 0x13e2 <computeTimeArray+0x3c>
	time[7] = '0';
	time[6]++;
	if (time[6] < '6') return;

	time[6] = '0';
	time[4]++;
    13dc:	80 93 6f 07 	sts	0x076F, r24	; 0x80076f <time+0x4>
    13e0:	08 95       	ret
	if (time[4] <= '9')	return;
	
	time[4] = '0';
    13e2:	eb e6       	ldi	r30, 0x6B	; 107
    13e4:	f7 e0       	ldi	r31, 0x07	; 7
    13e6:	80 e3       	ldi	r24, 0x30	; 48
    13e8:	84 83       	std	Z+4, r24	; 0x04
	time[3]++;
    13ea:	83 81       	ldd	r24, Z+3	; 0x03
    13ec:	8f 5f       	subi	r24, 0xFF	; 255
	if (time[3] < '6') return;
    13ee:	86 33       	cpi	r24, 0x36	; 54
    13f0:	18 f4       	brcc	.+6      	; 0x13f8 <computeTimeArray+0x52>
	time[6] = '0';
	time[4]++;
	if (time[4] <= '9')	return;
	
	time[4] = '0';
	time[3]++;
    13f2:	80 93 6e 07 	sts	0x076E, r24	; 0x80076e <time+0x3>
    13f6:	08 95       	ret
	if (time[3] < '6') return;
	
	time[3] = '0';
    13f8:	eb e6       	ldi	r30, 0x6B	; 107
    13fa:	f7 e0       	ldi	r31, 0x07	; 7
    13fc:	80 e3       	ldi	r24, 0x30	; 48
    13fe:	83 83       	std	Z+3, r24	; 0x03
	time[1]++;
    1400:	81 81       	ldd	r24, Z+1	; 0x01
    1402:	8f 5f       	subi	r24, 0xFF	; 255
    1404:	81 83       	std	Z+1, r24	; 0x01
	if (time[0] == '2' && time[1] == '4')
    1406:	90 81       	ld	r25, Z
    1408:	92 33       	cpi	r25, 0x32	; 50
    140a:	31 f4       	brne	.+12     	; 0x1418 <computeTimeArray+0x72>
    140c:	84 33       	cpi	r24, 0x34	; 52
    140e:	21 f4       	brne	.+8      	; 0x1418 <computeTimeArray+0x72>
	{
		nullifyTimeArray();
    1410:	0e 94 c6 09 	call	0x138c	; 0x138c <nullifyTimeArray>
		computeDay();	
    1414:	0e 94 3e 01 	call	0x27c	; 0x27c <computeDay>
	}
	if (time[1] <= '9')	return;
    1418:	80 91 6c 07 	lds	r24, 0x076C	; 0x80076c <time+0x1>
    141c:	8a 33       	cpi	r24, 0x3A	; 58
    141e:	38 f0       	brcs	.+14     	; 0x142e <computeTimeArray+0x88>
	
	time[1] = '0';
    1420:	eb e6       	ldi	r30, 0x6B	; 107
    1422:	f7 e0       	ldi	r31, 0x07	; 7
    1424:	80 e3       	ldi	r24, 0x30	; 48
    1426:	81 83       	std	Z+1, r24	; 0x01
	time[0]++;
    1428:	80 81       	ld	r24, Z
    142a:	8f 5f       	subi	r24, 0xFF	; 255
    142c:	80 83       	st	Z, r24
    142e:	08 95       	ret

00001430 <__divmodhi4>:
    1430:	97 fb       	bst	r25, 7
    1432:	07 2e       	mov	r0, r23
    1434:	16 f4       	brtc	.+4      	; 0x143a <__divmodhi4+0xa>
    1436:	00 94       	com	r0
    1438:	07 d0       	rcall	.+14     	; 0x1448 <__divmodhi4_neg1>
    143a:	77 fd       	sbrc	r23, 7
    143c:	09 d0       	rcall	.+18     	; 0x1450 <__divmodhi4_neg2>
    143e:	0e 94 2c 0a 	call	0x1458	; 0x1458 <__udivmodhi4>
    1442:	07 fc       	sbrc	r0, 7
    1444:	05 d0       	rcall	.+10     	; 0x1450 <__divmodhi4_neg2>
    1446:	3e f4       	brtc	.+14     	; 0x1456 <__divmodhi4_exit>

00001448 <__divmodhi4_neg1>:
    1448:	90 95       	com	r25
    144a:	81 95       	neg	r24
    144c:	9f 4f       	sbci	r25, 0xFF	; 255
    144e:	08 95       	ret

00001450 <__divmodhi4_neg2>:
    1450:	70 95       	com	r23
    1452:	61 95       	neg	r22
    1454:	7f 4f       	sbci	r23, 0xFF	; 255

00001456 <__divmodhi4_exit>:
    1456:	08 95       	ret

00001458 <__udivmodhi4>:
    1458:	aa 1b       	sub	r26, r26
    145a:	bb 1b       	sub	r27, r27
    145c:	51 e1       	ldi	r21, 0x11	; 17
    145e:	07 c0       	rjmp	.+14     	; 0x146e <__udivmodhi4_ep>

00001460 <__udivmodhi4_loop>:
    1460:	aa 1f       	adc	r26, r26
    1462:	bb 1f       	adc	r27, r27
    1464:	a6 17       	cp	r26, r22
    1466:	b7 07       	cpc	r27, r23
    1468:	10 f0       	brcs	.+4      	; 0x146e <__udivmodhi4_ep>
    146a:	a6 1b       	sub	r26, r22
    146c:	b7 0b       	sbc	r27, r23

0000146e <__udivmodhi4_ep>:
    146e:	88 1f       	adc	r24, r24
    1470:	99 1f       	adc	r25, r25
    1472:	5a 95       	dec	r21
    1474:	a9 f7       	brne	.-22     	; 0x1460 <__udivmodhi4_loop>
    1476:	80 95       	com	r24
    1478:	90 95       	com	r25
    147a:	bc 01       	movw	r22, r24
    147c:	cd 01       	movw	r24, r26
    147e:	08 95       	ret

00001480 <strtol>:
    1480:	a0 e0       	ldi	r26, 0x00	; 0
    1482:	b0 e0       	ldi	r27, 0x00	; 0
    1484:	e6 e4       	ldi	r30, 0x46	; 70
    1486:	fa e0       	ldi	r31, 0x0A	; 10
    1488:	0c 94 53 0e 	jmp	0x1ca6	; 0x1ca6 <__prologue_saves__+0x2>
    148c:	5c 01       	movw	r10, r24
    148e:	6b 01       	movw	r12, r22
    1490:	7a 01       	movw	r14, r20
    1492:	61 15       	cp	r22, r1
    1494:	71 05       	cpc	r23, r1
    1496:	19 f0       	breq	.+6      	; 0x149e <strtol+0x1e>
    1498:	fb 01       	movw	r30, r22
    149a:	91 83       	std	Z+1, r25	; 0x01
    149c:	80 83       	st	Z, r24
    149e:	e1 14       	cp	r14, r1
    14a0:	f1 04       	cpc	r15, r1
    14a2:	29 f0       	breq	.+10     	; 0x14ae <strtol+0x2e>
    14a4:	c7 01       	movw	r24, r14
    14a6:	02 97       	sbiw	r24, 0x02	; 2
    14a8:	83 97       	sbiw	r24, 0x23	; 35
    14aa:	08 f0       	brcs	.+2      	; 0x14ae <strtol+0x2e>
    14ac:	e5 c0       	rjmp	.+458    	; 0x1678 <strtol+0x1f8>
    14ae:	e5 01       	movw	r28, r10
    14b0:	21 96       	adiw	r28, 0x01	; 1
    14b2:	f5 01       	movw	r30, r10
    14b4:	10 81       	ld	r17, Z
    14b6:	81 2f       	mov	r24, r17
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	0e 94 56 0b 	call	0x16ac	; 0x16ac <isspace>
    14be:	89 2b       	or	r24, r25
    14c0:	11 f0       	breq	.+4      	; 0x14c6 <strtol+0x46>
    14c2:	5e 01       	movw	r10, r28
    14c4:	f4 cf       	rjmp	.-24     	; 0x14ae <strtol+0x2e>
    14c6:	1d 32       	cpi	r17, 0x2D	; 45
    14c8:	29 f4       	brne	.+10     	; 0x14d4 <strtol+0x54>
    14ca:	21 96       	adiw	r28, 0x01	; 1
    14cc:	f5 01       	movw	r30, r10
    14ce:	11 81       	ldd	r17, Z+1	; 0x01
    14d0:	01 e0       	ldi	r16, 0x01	; 1
    14d2:	07 c0       	rjmp	.+14     	; 0x14e2 <strtol+0x62>
    14d4:	1b 32       	cpi	r17, 0x2B	; 43
    14d6:	21 f4       	brne	.+8      	; 0x14e0 <strtol+0x60>
    14d8:	e5 01       	movw	r28, r10
    14da:	22 96       	adiw	r28, 0x02	; 2
    14dc:	f5 01       	movw	r30, r10
    14de:	11 81       	ldd	r17, Z+1	; 0x01
    14e0:	00 e0       	ldi	r16, 0x00	; 0
    14e2:	e1 14       	cp	r14, r1
    14e4:	f1 04       	cpc	r15, r1
    14e6:	09 f1       	breq	.+66     	; 0x152a <strtol+0xaa>
    14e8:	f0 e1       	ldi	r31, 0x10	; 16
    14ea:	ef 16       	cp	r14, r31
    14ec:	f1 04       	cpc	r15, r1
    14ee:	29 f4       	brne	.+10     	; 0x14fa <strtol+0x7a>
    14f0:	3f c0       	rjmp	.+126    	; 0x1570 <strtol+0xf0>
    14f2:	10 e3       	ldi	r17, 0x30	; 48
    14f4:	e1 14       	cp	r14, r1
    14f6:	f1 04       	cpc	r15, r1
    14f8:	21 f1       	breq	.+72     	; 0x1542 <strtol+0xc2>
    14fa:	28 e0       	ldi	r18, 0x08	; 8
    14fc:	e2 16       	cp	r14, r18
    14fe:	f1 04       	cpc	r15, r1
    1500:	01 f1       	breq	.+64     	; 0x1542 <strtol+0xc2>
    1502:	54 f4       	brge	.+20     	; 0x1518 <strtol+0x98>
    1504:	e2 e0       	ldi	r30, 0x02	; 2
    1506:	ee 16       	cp	r14, r30
    1508:	f1 04       	cpc	r15, r1
    150a:	21 f5       	brne	.+72     	; 0x1554 <strtol+0xd4>
    150c:	81 2c       	mov	r8, r1
    150e:	91 2c       	mov	r9, r1
    1510:	a1 2c       	mov	r10, r1
    1512:	b0 e4       	ldi	r27, 0x40	; 64
    1514:	bb 2e       	mov	r11, r27
    1516:	3e c0       	rjmp	.+124    	; 0x1594 <strtol+0x114>
    1518:	fa e0       	ldi	r31, 0x0A	; 10
    151a:	ef 16       	cp	r14, r31
    151c:	f1 04       	cpc	r15, r1
    151e:	39 f0       	breq	.+14     	; 0x152e <strtol+0xae>
    1520:	20 e1       	ldi	r18, 0x10	; 16
    1522:	e2 16       	cp	r14, r18
    1524:	f1 04       	cpc	r15, r1
    1526:	b1 f4       	brne	.+44     	; 0x1554 <strtol+0xd4>
    1528:	30 c0       	rjmp	.+96     	; 0x158a <strtol+0x10a>
    152a:	10 33       	cpi	r17, 0x30	; 48
    152c:	19 f1       	breq	.+70     	; 0x1574 <strtol+0xf4>
    152e:	fa e0       	ldi	r31, 0x0A	; 10
    1530:	ef 2e       	mov	r14, r31
    1532:	f1 2c       	mov	r15, r1
    1534:	ac ec       	ldi	r26, 0xCC	; 204
    1536:	8a 2e       	mov	r8, r26
    1538:	98 2c       	mov	r9, r8
    153a:	a8 2c       	mov	r10, r8
    153c:	ac e0       	ldi	r26, 0x0C	; 12
    153e:	ba 2e       	mov	r11, r26
    1540:	29 c0       	rjmp	.+82     	; 0x1594 <strtol+0x114>
    1542:	78 e0       	ldi	r23, 0x08	; 8
    1544:	e7 2e       	mov	r14, r23
    1546:	f1 2c       	mov	r15, r1
    1548:	81 2c       	mov	r8, r1
    154a:	91 2c       	mov	r9, r1
    154c:	a1 2c       	mov	r10, r1
    154e:	e0 e1       	ldi	r30, 0x10	; 16
    1550:	be 2e       	mov	r11, r30
    1552:	20 c0       	rjmp	.+64     	; 0x1594 <strtol+0x114>
    1554:	60 e0       	ldi	r22, 0x00	; 0
    1556:	70 e0       	ldi	r23, 0x00	; 0
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	90 e8       	ldi	r25, 0x80	; 128
    155c:	97 01       	movw	r18, r14
    155e:	0f 2c       	mov	r0, r15
    1560:	00 0c       	add	r0, r0
    1562:	44 0b       	sbc	r20, r20
    1564:	55 0b       	sbc	r21, r21
    1566:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <__udivmodsi4>
    156a:	49 01       	movw	r8, r18
    156c:	5a 01       	movw	r10, r20
    156e:	12 c0       	rjmp	.+36     	; 0x1594 <strtol+0x114>
    1570:	10 33       	cpi	r17, 0x30	; 48
    1572:	59 f4       	brne	.+22     	; 0x158a <strtol+0x10a>
    1574:	88 81       	ld	r24, Y
    1576:	8f 7d       	andi	r24, 0xDF	; 223
    1578:	88 35       	cpi	r24, 0x58	; 88
    157a:	09 f0       	breq	.+2      	; 0x157e <strtol+0xfe>
    157c:	ba cf       	rjmp	.-140    	; 0x14f2 <strtol+0x72>
    157e:	19 81       	ldd	r17, Y+1	; 0x01
    1580:	22 96       	adiw	r28, 0x02	; 2
    1582:	02 60       	ori	r16, 0x02	; 2
    1584:	80 e1       	ldi	r24, 0x10	; 16
    1586:	e8 2e       	mov	r14, r24
    1588:	f1 2c       	mov	r15, r1
    158a:	81 2c       	mov	r8, r1
    158c:	91 2c       	mov	r9, r1
    158e:	a1 2c       	mov	r10, r1
    1590:	68 e0       	ldi	r22, 0x08	; 8
    1592:	b6 2e       	mov	r11, r22
    1594:	40 e0       	ldi	r20, 0x00	; 0
    1596:	60 e0       	ldi	r22, 0x00	; 0
    1598:	70 e0       	ldi	r23, 0x00	; 0
    159a:	cb 01       	movw	r24, r22
    159c:	27 01       	movw	r4, r14
    159e:	0f 2c       	mov	r0, r15
    15a0:	00 0c       	add	r0, r0
    15a2:	66 08       	sbc	r6, r6
    15a4:	77 08       	sbc	r7, r7
    15a6:	fe 01       	movw	r30, r28
    15a8:	50 ed       	ldi	r21, 0xD0	; 208
    15aa:	35 2e       	mov	r3, r21
    15ac:	31 0e       	add	r3, r17
    15ae:	29 e0       	ldi	r18, 0x09	; 9
    15b0:	23 15       	cp	r18, r3
    15b2:	70 f4       	brcc	.+28     	; 0x15d0 <strtol+0x150>
    15b4:	2f eb       	ldi	r18, 0xBF	; 191
    15b6:	21 0f       	add	r18, r17
    15b8:	2a 31       	cpi	r18, 0x1A	; 26
    15ba:	18 f4       	brcc	.+6      	; 0x15c2 <strtol+0x142>
    15bc:	39 ec       	ldi	r19, 0xC9	; 201
    15be:	33 2e       	mov	r3, r19
    15c0:	06 c0       	rjmp	.+12     	; 0x15ce <strtol+0x14e>
    15c2:	2f e9       	ldi	r18, 0x9F	; 159
    15c4:	21 0f       	add	r18, r17
    15c6:	2a 31       	cpi	r18, 0x1A	; 26
    15c8:	18 f5       	brcc	.+70     	; 0x1610 <strtol+0x190>
    15ca:	29 ea       	ldi	r18, 0xA9	; 169
    15cc:	32 2e       	mov	r3, r18
    15ce:	31 0e       	add	r3, r17
    15d0:	23 2d       	mov	r18, r3
    15d2:	30 e0       	ldi	r19, 0x00	; 0
    15d4:	2e 15       	cp	r18, r14
    15d6:	3f 05       	cpc	r19, r15
    15d8:	dc f4       	brge	.+54     	; 0x1610 <strtol+0x190>
    15da:	47 fd       	sbrc	r20, 7
    15dc:	16 c0       	rjmp	.+44     	; 0x160a <strtol+0x18a>
    15de:	86 16       	cp	r8, r22
    15e0:	97 06       	cpc	r9, r23
    15e2:	a8 06       	cpc	r10, r24
    15e4:	b9 06       	cpc	r11, r25
    15e6:	70 f0       	brcs	.+28     	; 0x1604 <strtol+0x184>
    15e8:	a3 01       	movw	r20, r6
    15ea:	92 01       	movw	r18, r4
    15ec:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <__mulsi3>
    15f0:	63 0d       	add	r22, r3
    15f2:	71 1d       	adc	r23, r1
    15f4:	81 1d       	adc	r24, r1
    15f6:	91 1d       	adc	r25, r1
    15f8:	61 30       	cpi	r22, 0x01	; 1
    15fa:	71 05       	cpc	r23, r1
    15fc:	81 05       	cpc	r24, r1
    15fe:	20 e8       	ldi	r18, 0x80	; 128
    1600:	92 07       	cpc	r25, r18
    1602:	10 f0       	brcs	.+4      	; 0x1608 <strtol+0x188>
    1604:	4f ef       	ldi	r20, 0xFF	; 255
    1606:	01 c0       	rjmp	.+2      	; 0x160a <strtol+0x18a>
    1608:	41 e0       	ldi	r20, 0x01	; 1
    160a:	21 96       	adiw	r28, 0x01	; 1
    160c:	10 81       	ld	r17, Z
    160e:	cb cf       	rjmp	.-106    	; 0x15a6 <strtol+0x126>
    1610:	20 2f       	mov	r18, r16
    1612:	21 70       	andi	r18, 0x01	; 1
    1614:	c1 14       	cp	r12, r1
    1616:	d1 04       	cpc	r13, r1
    1618:	71 f0       	breq	.+28     	; 0x1636 <strtol+0x1b6>
    161a:	44 23       	and	r20, r20
    161c:	29 f0       	breq	.+10     	; 0x1628 <strtol+0x1a8>
    161e:	21 97       	sbiw	r28, 0x01	; 1
    1620:	f6 01       	movw	r30, r12
    1622:	d1 83       	std	Z+1, r29	; 0x01
    1624:	c0 83       	st	Z, r28
    1626:	07 c0       	rjmp	.+14     	; 0x1636 <strtol+0x1b6>
    1628:	01 ff       	sbrs	r16, 1
    162a:	19 c0       	rjmp	.+50     	; 0x165e <strtol+0x1de>
    162c:	22 97       	sbiw	r28, 0x02	; 2
    162e:	f6 01       	movw	r30, r12
    1630:	d1 83       	std	Z+1, r29	; 0x01
    1632:	c0 83       	st	Z, r28
    1634:	14 c0       	rjmp	.+40     	; 0x165e <strtol+0x1de>
    1636:	47 ff       	sbrs	r20, 7
    1638:	12 c0       	rjmp	.+36     	; 0x165e <strtol+0x1de>
    163a:	22 23       	and	r18, r18
    163c:	29 f0       	breq	.+10     	; 0x1648 <strtol+0x1c8>
    163e:	60 e0       	ldi	r22, 0x00	; 0
    1640:	70 e0       	ldi	r23, 0x00	; 0
    1642:	80 e0       	ldi	r24, 0x00	; 0
    1644:	90 e8       	ldi	r25, 0x80	; 128
    1646:	04 c0       	rjmp	.+8      	; 0x1650 <strtol+0x1d0>
    1648:	6f ef       	ldi	r22, 0xFF	; 255
    164a:	7f ef       	ldi	r23, 0xFF	; 255
    164c:	8f ef       	ldi	r24, 0xFF	; 255
    164e:	9f e7       	ldi	r25, 0x7F	; 127
    1650:	22 e2       	ldi	r18, 0x22	; 34
    1652:	30 e0       	ldi	r19, 0x00	; 0
    1654:	30 93 74 07 	sts	0x0774, r19	; 0x800774 <errno+0x1>
    1658:	20 93 73 07 	sts	0x0773, r18	; 0x800773 <errno>
    165c:	09 c0       	rjmp	.+18     	; 0x1670 <strtol+0x1f0>
    165e:	22 23       	and	r18, r18
    1660:	81 f0       	breq	.+32     	; 0x1682 <strtol+0x202>
    1662:	90 95       	com	r25
    1664:	80 95       	com	r24
    1666:	70 95       	com	r23
    1668:	61 95       	neg	r22
    166a:	7f 4f       	sbci	r23, 0xFF	; 255
    166c:	8f 4f       	sbci	r24, 0xFF	; 255
    166e:	9f 4f       	sbci	r25, 0xFF	; 255
    1670:	46 2f       	mov	r20, r22
    1672:	37 2f       	mov	r19, r23
    1674:	28 2f       	mov	r18, r24
    1676:	12 c0       	rjmp	.+36     	; 0x169c <strtol+0x21c>
    1678:	40 e0       	ldi	r20, 0x00	; 0
    167a:	30 e0       	ldi	r19, 0x00	; 0
    167c:	20 e0       	ldi	r18, 0x00	; 0
    167e:	90 e0       	ldi	r25, 0x00	; 0
    1680:	0d c0       	rjmp	.+26     	; 0x169c <strtol+0x21c>
    1682:	97 ff       	sbrs	r25, 7
    1684:	f5 cf       	rjmp	.-22     	; 0x1670 <strtol+0x1f0>
    1686:	82 e2       	ldi	r24, 0x22	; 34
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	90 93 74 07 	sts	0x0774, r25	; 0x800774 <errno+0x1>
    168e:	80 93 73 07 	sts	0x0773, r24	; 0x800773 <errno>
    1692:	6f ef       	ldi	r22, 0xFF	; 255
    1694:	7f ef       	ldi	r23, 0xFF	; 255
    1696:	8f ef       	ldi	r24, 0xFF	; 255
    1698:	9f e7       	ldi	r25, 0x7F	; 127
    169a:	ea cf       	rjmp	.-44     	; 0x1670 <strtol+0x1f0>
    169c:	64 2f       	mov	r22, r20
    169e:	73 2f       	mov	r23, r19
    16a0:	82 2f       	mov	r24, r18
    16a2:	cd b7       	in	r28, 0x3d	; 61
    16a4:	de b7       	in	r29, 0x3e	; 62
    16a6:	e1 e1       	ldi	r30, 0x11	; 17
    16a8:	0c 94 6f 0e 	jmp	0x1cde	; 0x1cde <__epilogue_restores__+0x2>

000016ac <isspace>:
    16ac:	91 11       	cpse	r25, r1
    16ae:	0c 94 62 0d 	jmp	0x1ac4	; 0x1ac4 <__ctype_isfalse>
    16b2:	80 32       	cpi	r24, 0x20	; 32
    16b4:	19 f0       	breq	.+6      	; 0x16bc <isspace+0x10>
    16b6:	89 50       	subi	r24, 0x09	; 9
    16b8:	85 50       	subi	r24, 0x05	; 5
    16ba:	c8 f7       	brcc	.-14     	; 0x16ae <isspace+0x2>
    16bc:	08 95       	ret

000016be <sprintf>:
    16be:	ae e0       	ldi	r26, 0x0E	; 14
    16c0:	b0 e0       	ldi	r27, 0x00	; 0
    16c2:	e5 e6       	ldi	r30, 0x65	; 101
    16c4:	fb e0       	ldi	r31, 0x0B	; 11
    16c6:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <__prologue_saves__+0x1c>
    16ca:	0d 89       	ldd	r16, Y+21	; 0x15
    16cc:	1e 89       	ldd	r17, Y+22	; 0x16
    16ce:	86 e0       	ldi	r24, 0x06	; 6
    16d0:	8c 83       	std	Y+4, r24	; 0x04
    16d2:	1a 83       	std	Y+2, r17	; 0x02
    16d4:	09 83       	std	Y+1, r16	; 0x01
    16d6:	8f ef       	ldi	r24, 0xFF	; 255
    16d8:	9f e7       	ldi	r25, 0x7F	; 127
    16da:	9e 83       	std	Y+6, r25	; 0x06
    16dc:	8d 83       	std	Y+5, r24	; 0x05
    16de:	ae 01       	movw	r20, r28
    16e0:	47 5e       	subi	r20, 0xE7	; 231
    16e2:	5f 4f       	sbci	r21, 0xFF	; 255
    16e4:	6f 89       	ldd	r22, Y+23	; 0x17
    16e6:	78 8d       	ldd	r23, Y+24	; 0x18
    16e8:	ce 01       	movw	r24, r28
    16ea:	01 96       	adiw	r24, 0x01	; 1
    16ec:	0e 94 81 0b 	call	0x1702	; 0x1702 <vfprintf>
    16f0:	ef 81       	ldd	r30, Y+7	; 0x07
    16f2:	f8 85       	ldd	r31, Y+8	; 0x08
    16f4:	e0 0f       	add	r30, r16
    16f6:	f1 1f       	adc	r31, r17
    16f8:	10 82       	st	Z, r1
    16fa:	2e 96       	adiw	r28, 0x0e	; 14
    16fc:	e4 e0       	ldi	r30, 0x04	; 4
    16fe:	0c 94 7c 0e 	jmp	0x1cf8	; 0x1cf8 <__epilogue_restores__+0x1c>

00001702 <vfprintf>:
    1702:	ab e0       	ldi	r26, 0x0B	; 11
    1704:	b0 e0       	ldi	r27, 0x00	; 0
    1706:	e7 e8       	ldi	r30, 0x87	; 135
    1708:	fb e0       	ldi	r31, 0x0B	; 11
    170a:	0c 94 52 0e 	jmp	0x1ca4	; 0x1ca4 <__prologue_saves__>
    170e:	6c 01       	movw	r12, r24
    1710:	7b 01       	movw	r14, r22
    1712:	8a 01       	movw	r16, r20
    1714:	fc 01       	movw	r30, r24
    1716:	17 82       	std	Z+7, r1	; 0x07
    1718:	16 82       	std	Z+6, r1	; 0x06
    171a:	83 81       	ldd	r24, Z+3	; 0x03
    171c:	81 ff       	sbrs	r24, 1
    171e:	cc c1       	rjmp	.+920    	; 0x1ab8 <vfprintf+0x3b6>
    1720:	ce 01       	movw	r24, r28
    1722:	01 96       	adiw	r24, 0x01	; 1
    1724:	3c 01       	movw	r6, r24
    1726:	f6 01       	movw	r30, r12
    1728:	93 81       	ldd	r25, Z+3	; 0x03
    172a:	f7 01       	movw	r30, r14
    172c:	93 fd       	sbrc	r25, 3
    172e:	85 91       	lpm	r24, Z+
    1730:	93 ff       	sbrs	r25, 3
    1732:	81 91       	ld	r24, Z+
    1734:	7f 01       	movw	r14, r30
    1736:	88 23       	and	r24, r24
    1738:	09 f4       	brne	.+2      	; 0x173c <vfprintf+0x3a>
    173a:	ba c1       	rjmp	.+884    	; 0x1ab0 <vfprintf+0x3ae>
    173c:	85 32       	cpi	r24, 0x25	; 37
    173e:	39 f4       	brne	.+14     	; 0x174e <vfprintf+0x4c>
    1740:	93 fd       	sbrc	r25, 3
    1742:	85 91       	lpm	r24, Z+
    1744:	93 ff       	sbrs	r25, 3
    1746:	81 91       	ld	r24, Z+
    1748:	7f 01       	movw	r14, r30
    174a:	85 32       	cpi	r24, 0x25	; 37
    174c:	29 f4       	brne	.+10     	; 0x1758 <vfprintf+0x56>
    174e:	b6 01       	movw	r22, r12
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    1756:	e7 cf       	rjmp	.-50     	; 0x1726 <vfprintf+0x24>
    1758:	91 2c       	mov	r9, r1
    175a:	21 2c       	mov	r2, r1
    175c:	31 2c       	mov	r3, r1
    175e:	ff e1       	ldi	r31, 0x1F	; 31
    1760:	f3 15       	cp	r31, r3
    1762:	d8 f0       	brcs	.+54     	; 0x179a <vfprintf+0x98>
    1764:	8b 32       	cpi	r24, 0x2B	; 43
    1766:	79 f0       	breq	.+30     	; 0x1786 <vfprintf+0x84>
    1768:	38 f4       	brcc	.+14     	; 0x1778 <vfprintf+0x76>
    176a:	80 32       	cpi	r24, 0x20	; 32
    176c:	79 f0       	breq	.+30     	; 0x178c <vfprintf+0x8a>
    176e:	83 32       	cpi	r24, 0x23	; 35
    1770:	a1 f4       	brne	.+40     	; 0x179a <vfprintf+0x98>
    1772:	23 2d       	mov	r18, r3
    1774:	20 61       	ori	r18, 0x10	; 16
    1776:	1d c0       	rjmp	.+58     	; 0x17b2 <vfprintf+0xb0>
    1778:	8d 32       	cpi	r24, 0x2D	; 45
    177a:	61 f0       	breq	.+24     	; 0x1794 <vfprintf+0x92>
    177c:	80 33       	cpi	r24, 0x30	; 48
    177e:	69 f4       	brne	.+26     	; 0x179a <vfprintf+0x98>
    1780:	23 2d       	mov	r18, r3
    1782:	21 60       	ori	r18, 0x01	; 1
    1784:	16 c0       	rjmp	.+44     	; 0x17b2 <vfprintf+0xb0>
    1786:	83 2d       	mov	r24, r3
    1788:	82 60       	ori	r24, 0x02	; 2
    178a:	38 2e       	mov	r3, r24
    178c:	e3 2d       	mov	r30, r3
    178e:	e4 60       	ori	r30, 0x04	; 4
    1790:	3e 2e       	mov	r3, r30
    1792:	2a c0       	rjmp	.+84     	; 0x17e8 <vfprintf+0xe6>
    1794:	f3 2d       	mov	r31, r3
    1796:	f8 60       	ori	r31, 0x08	; 8
    1798:	1d c0       	rjmp	.+58     	; 0x17d4 <vfprintf+0xd2>
    179a:	37 fc       	sbrc	r3, 7
    179c:	2d c0       	rjmp	.+90     	; 0x17f8 <vfprintf+0xf6>
    179e:	20 ed       	ldi	r18, 0xD0	; 208
    17a0:	28 0f       	add	r18, r24
    17a2:	2a 30       	cpi	r18, 0x0A	; 10
    17a4:	40 f0       	brcs	.+16     	; 0x17b6 <vfprintf+0xb4>
    17a6:	8e 32       	cpi	r24, 0x2E	; 46
    17a8:	b9 f4       	brne	.+46     	; 0x17d8 <vfprintf+0xd6>
    17aa:	36 fc       	sbrc	r3, 6
    17ac:	81 c1       	rjmp	.+770    	; 0x1ab0 <vfprintf+0x3ae>
    17ae:	23 2d       	mov	r18, r3
    17b0:	20 64       	ori	r18, 0x40	; 64
    17b2:	32 2e       	mov	r3, r18
    17b4:	19 c0       	rjmp	.+50     	; 0x17e8 <vfprintf+0xe6>
    17b6:	36 fe       	sbrs	r3, 6
    17b8:	06 c0       	rjmp	.+12     	; 0x17c6 <vfprintf+0xc4>
    17ba:	8a e0       	ldi	r24, 0x0A	; 10
    17bc:	98 9e       	mul	r9, r24
    17be:	20 0d       	add	r18, r0
    17c0:	11 24       	eor	r1, r1
    17c2:	92 2e       	mov	r9, r18
    17c4:	11 c0       	rjmp	.+34     	; 0x17e8 <vfprintf+0xe6>
    17c6:	ea e0       	ldi	r30, 0x0A	; 10
    17c8:	2e 9e       	mul	r2, r30
    17ca:	20 0d       	add	r18, r0
    17cc:	11 24       	eor	r1, r1
    17ce:	22 2e       	mov	r2, r18
    17d0:	f3 2d       	mov	r31, r3
    17d2:	f0 62       	ori	r31, 0x20	; 32
    17d4:	3f 2e       	mov	r3, r31
    17d6:	08 c0       	rjmp	.+16     	; 0x17e8 <vfprintf+0xe6>
    17d8:	8c 36       	cpi	r24, 0x6C	; 108
    17da:	21 f4       	brne	.+8      	; 0x17e4 <vfprintf+0xe2>
    17dc:	83 2d       	mov	r24, r3
    17de:	80 68       	ori	r24, 0x80	; 128
    17e0:	38 2e       	mov	r3, r24
    17e2:	02 c0       	rjmp	.+4      	; 0x17e8 <vfprintf+0xe6>
    17e4:	88 36       	cpi	r24, 0x68	; 104
    17e6:	41 f4       	brne	.+16     	; 0x17f8 <vfprintf+0xf6>
    17e8:	f7 01       	movw	r30, r14
    17ea:	93 fd       	sbrc	r25, 3
    17ec:	85 91       	lpm	r24, Z+
    17ee:	93 ff       	sbrs	r25, 3
    17f0:	81 91       	ld	r24, Z+
    17f2:	7f 01       	movw	r14, r30
    17f4:	81 11       	cpse	r24, r1
    17f6:	b3 cf       	rjmp	.-154    	; 0x175e <vfprintf+0x5c>
    17f8:	98 2f       	mov	r25, r24
    17fa:	9f 7d       	andi	r25, 0xDF	; 223
    17fc:	95 54       	subi	r25, 0x45	; 69
    17fe:	93 30       	cpi	r25, 0x03	; 3
    1800:	28 f4       	brcc	.+10     	; 0x180c <vfprintf+0x10a>
    1802:	0c 5f       	subi	r16, 0xFC	; 252
    1804:	1f 4f       	sbci	r17, 0xFF	; 255
    1806:	9f e3       	ldi	r25, 0x3F	; 63
    1808:	99 83       	std	Y+1, r25	; 0x01
    180a:	0d c0       	rjmp	.+26     	; 0x1826 <vfprintf+0x124>
    180c:	83 36       	cpi	r24, 0x63	; 99
    180e:	31 f0       	breq	.+12     	; 0x181c <vfprintf+0x11a>
    1810:	83 37       	cpi	r24, 0x73	; 115
    1812:	71 f0       	breq	.+28     	; 0x1830 <vfprintf+0x12e>
    1814:	83 35       	cpi	r24, 0x53	; 83
    1816:	09 f0       	breq	.+2      	; 0x181a <vfprintf+0x118>
    1818:	59 c0       	rjmp	.+178    	; 0x18cc <vfprintf+0x1ca>
    181a:	21 c0       	rjmp	.+66     	; 0x185e <vfprintf+0x15c>
    181c:	f8 01       	movw	r30, r16
    181e:	80 81       	ld	r24, Z
    1820:	89 83       	std	Y+1, r24	; 0x01
    1822:	0e 5f       	subi	r16, 0xFE	; 254
    1824:	1f 4f       	sbci	r17, 0xFF	; 255
    1826:	88 24       	eor	r8, r8
    1828:	83 94       	inc	r8
    182a:	91 2c       	mov	r9, r1
    182c:	53 01       	movw	r10, r6
    182e:	13 c0       	rjmp	.+38     	; 0x1856 <vfprintf+0x154>
    1830:	28 01       	movw	r4, r16
    1832:	f2 e0       	ldi	r31, 0x02	; 2
    1834:	4f 0e       	add	r4, r31
    1836:	51 1c       	adc	r5, r1
    1838:	f8 01       	movw	r30, r16
    183a:	a0 80       	ld	r10, Z
    183c:	b1 80       	ldd	r11, Z+1	; 0x01
    183e:	36 fe       	sbrs	r3, 6
    1840:	03 c0       	rjmp	.+6      	; 0x1848 <vfprintf+0x146>
    1842:	69 2d       	mov	r22, r9
    1844:	70 e0       	ldi	r23, 0x00	; 0
    1846:	02 c0       	rjmp	.+4      	; 0x184c <vfprintf+0x14a>
    1848:	6f ef       	ldi	r22, 0xFF	; 255
    184a:	7f ef       	ldi	r23, 0xFF	; 255
    184c:	c5 01       	movw	r24, r10
    184e:	0e 94 70 0d 	call	0x1ae0	; 0x1ae0 <strnlen>
    1852:	4c 01       	movw	r8, r24
    1854:	82 01       	movw	r16, r4
    1856:	f3 2d       	mov	r31, r3
    1858:	ff 77       	andi	r31, 0x7F	; 127
    185a:	3f 2e       	mov	r3, r31
    185c:	16 c0       	rjmp	.+44     	; 0x188a <vfprintf+0x188>
    185e:	28 01       	movw	r4, r16
    1860:	22 e0       	ldi	r18, 0x02	; 2
    1862:	42 0e       	add	r4, r18
    1864:	51 1c       	adc	r5, r1
    1866:	f8 01       	movw	r30, r16
    1868:	a0 80       	ld	r10, Z
    186a:	b1 80       	ldd	r11, Z+1	; 0x01
    186c:	36 fe       	sbrs	r3, 6
    186e:	03 c0       	rjmp	.+6      	; 0x1876 <vfprintf+0x174>
    1870:	69 2d       	mov	r22, r9
    1872:	70 e0       	ldi	r23, 0x00	; 0
    1874:	02 c0       	rjmp	.+4      	; 0x187a <vfprintf+0x178>
    1876:	6f ef       	ldi	r22, 0xFF	; 255
    1878:	7f ef       	ldi	r23, 0xFF	; 255
    187a:	c5 01       	movw	r24, r10
    187c:	0e 94 65 0d 	call	0x1aca	; 0x1aca <strnlen_P>
    1880:	4c 01       	movw	r8, r24
    1882:	f3 2d       	mov	r31, r3
    1884:	f0 68       	ori	r31, 0x80	; 128
    1886:	3f 2e       	mov	r3, r31
    1888:	82 01       	movw	r16, r4
    188a:	33 fc       	sbrc	r3, 3
    188c:	1b c0       	rjmp	.+54     	; 0x18c4 <vfprintf+0x1c2>
    188e:	82 2d       	mov	r24, r2
    1890:	90 e0       	ldi	r25, 0x00	; 0
    1892:	88 16       	cp	r8, r24
    1894:	99 06       	cpc	r9, r25
    1896:	b0 f4       	brcc	.+44     	; 0x18c4 <vfprintf+0x1c2>
    1898:	b6 01       	movw	r22, r12
    189a:	80 e2       	ldi	r24, 0x20	; 32
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    18a2:	2a 94       	dec	r2
    18a4:	f4 cf       	rjmp	.-24     	; 0x188e <vfprintf+0x18c>
    18a6:	f5 01       	movw	r30, r10
    18a8:	37 fc       	sbrc	r3, 7
    18aa:	85 91       	lpm	r24, Z+
    18ac:	37 fe       	sbrs	r3, 7
    18ae:	81 91       	ld	r24, Z+
    18b0:	5f 01       	movw	r10, r30
    18b2:	b6 01       	movw	r22, r12
    18b4:	90 e0       	ldi	r25, 0x00	; 0
    18b6:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    18ba:	21 10       	cpse	r2, r1
    18bc:	2a 94       	dec	r2
    18be:	21 e0       	ldi	r18, 0x01	; 1
    18c0:	82 1a       	sub	r8, r18
    18c2:	91 08       	sbc	r9, r1
    18c4:	81 14       	cp	r8, r1
    18c6:	91 04       	cpc	r9, r1
    18c8:	71 f7       	brne	.-36     	; 0x18a6 <vfprintf+0x1a4>
    18ca:	e8 c0       	rjmp	.+464    	; 0x1a9c <vfprintf+0x39a>
    18cc:	84 36       	cpi	r24, 0x64	; 100
    18ce:	11 f0       	breq	.+4      	; 0x18d4 <vfprintf+0x1d2>
    18d0:	89 36       	cpi	r24, 0x69	; 105
    18d2:	41 f5       	brne	.+80     	; 0x1924 <vfprintf+0x222>
    18d4:	f8 01       	movw	r30, r16
    18d6:	37 fe       	sbrs	r3, 7
    18d8:	07 c0       	rjmp	.+14     	; 0x18e8 <vfprintf+0x1e6>
    18da:	60 81       	ld	r22, Z
    18dc:	71 81       	ldd	r23, Z+1	; 0x01
    18de:	82 81       	ldd	r24, Z+2	; 0x02
    18e0:	93 81       	ldd	r25, Z+3	; 0x03
    18e2:	0c 5f       	subi	r16, 0xFC	; 252
    18e4:	1f 4f       	sbci	r17, 0xFF	; 255
    18e6:	08 c0       	rjmp	.+16     	; 0x18f8 <vfprintf+0x1f6>
    18e8:	60 81       	ld	r22, Z
    18ea:	71 81       	ldd	r23, Z+1	; 0x01
    18ec:	07 2e       	mov	r0, r23
    18ee:	00 0c       	add	r0, r0
    18f0:	88 0b       	sbc	r24, r24
    18f2:	99 0b       	sbc	r25, r25
    18f4:	0e 5f       	subi	r16, 0xFE	; 254
    18f6:	1f 4f       	sbci	r17, 0xFF	; 255
    18f8:	f3 2d       	mov	r31, r3
    18fa:	ff 76       	andi	r31, 0x6F	; 111
    18fc:	3f 2e       	mov	r3, r31
    18fe:	97 ff       	sbrs	r25, 7
    1900:	09 c0       	rjmp	.+18     	; 0x1914 <vfprintf+0x212>
    1902:	90 95       	com	r25
    1904:	80 95       	com	r24
    1906:	70 95       	com	r23
    1908:	61 95       	neg	r22
    190a:	7f 4f       	sbci	r23, 0xFF	; 255
    190c:	8f 4f       	sbci	r24, 0xFF	; 255
    190e:	9f 4f       	sbci	r25, 0xFF	; 255
    1910:	f0 68       	ori	r31, 0x80	; 128
    1912:	3f 2e       	mov	r3, r31
    1914:	2a e0       	ldi	r18, 0x0A	; 10
    1916:	30 e0       	ldi	r19, 0x00	; 0
    1918:	a3 01       	movw	r20, r6
    191a:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <__ultoa_invert>
    191e:	88 2e       	mov	r8, r24
    1920:	86 18       	sub	r8, r6
    1922:	45 c0       	rjmp	.+138    	; 0x19ae <vfprintf+0x2ac>
    1924:	85 37       	cpi	r24, 0x75	; 117
    1926:	31 f4       	brne	.+12     	; 0x1934 <vfprintf+0x232>
    1928:	23 2d       	mov	r18, r3
    192a:	2f 7e       	andi	r18, 0xEF	; 239
    192c:	b2 2e       	mov	r11, r18
    192e:	2a e0       	ldi	r18, 0x0A	; 10
    1930:	30 e0       	ldi	r19, 0x00	; 0
    1932:	25 c0       	rjmp	.+74     	; 0x197e <vfprintf+0x27c>
    1934:	93 2d       	mov	r25, r3
    1936:	99 7f       	andi	r25, 0xF9	; 249
    1938:	b9 2e       	mov	r11, r25
    193a:	8f 36       	cpi	r24, 0x6F	; 111
    193c:	c1 f0       	breq	.+48     	; 0x196e <vfprintf+0x26c>
    193e:	18 f4       	brcc	.+6      	; 0x1946 <vfprintf+0x244>
    1940:	88 35       	cpi	r24, 0x58	; 88
    1942:	79 f0       	breq	.+30     	; 0x1962 <vfprintf+0x260>
    1944:	b5 c0       	rjmp	.+362    	; 0x1ab0 <vfprintf+0x3ae>
    1946:	80 37       	cpi	r24, 0x70	; 112
    1948:	19 f0       	breq	.+6      	; 0x1950 <vfprintf+0x24e>
    194a:	88 37       	cpi	r24, 0x78	; 120
    194c:	21 f0       	breq	.+8      	; 0x1956 <vfprintf+0x254>
    194e:	b0 c0       	rjmp	.+352    	; 0x1ab0 <vfprintf+0x3ae>
    1950:	e9 2f       	mov	r30, r25
    1952:	e0 61       	ori	r30, 0x10	; 16
    1954:	be 2e       	mov	r11, r30
    1956:	b4 fe       	sbrs	r11, 4
    1958:	0d c0       	rjmp	.+26     	; 0x1974 <vfprintf+0x272>
    195a:	fb 2d       	mov	r31, r11
    195c:	f4 60       	ori	r31, 0x04	; 4
    195e:	bf 2e       	mov	r11, r31
    1960:	09 c0       	rjmp	.+18     	; 0x1974 <vfprintf+0x272>
    1962:	34 fe       	sbrs	r3, 4
    1964:	0a c0       	rjmp	.+20     	; 0x197a <vfprintf+0x278>
    1966:	29 2f       	mov	r18, r25
    1968:	26 60       	ori	r18, 0x06	; 6
    196a:	b2 2e       	mov	r11, r18
    196c:	06 c0       	rjmp	.+12     	; 0x197a <vfprintf+0x278>
    196e:	28 e0       	ldi	r18, 0x08	; 8
    1970:	30 e0       	ldi	r19, 0x00	; 0
    1972:	05 c0       	rjmp	.+10     	; 0x197e <vfprintf+0x27c>
    1974:	20 e1       	ldi	r18, 0x10	; 16
    1976:	30 e0       	ldi	r19, 0x00	; 0
    1978:	02 c0       	rjmp	.+4      	; 0x197e <vfprintf+0x27c>
    197a:	20 e1       	ldi	r18, 0x10	; 16
    197c:	32 e0       	ldi	r19, 0x02	; 2
    197e:	f8 01       	movw	r30, r16
    1980:	b7 fe       	sbrs	r11, 7
    1982:	07 c0       	rjmp	.+14     	; 0x1992 <vfprintf+0x290>
    1984:	60 81       	ld	r22, Z
    1986:	71 81       	ldd	r23, Z+1	; 0x01
    1988:	82 81       	ldd	r24, Z+2	; 0x02
    198a:	93 81       	ldd	r25, Z+3	; 0x03
    198c:	0c 5f       	subi	r16, 0xFC	; 252
    198e:	1f 4f       	sbci	r17, 0xFF	; 255
    1990:	06 c0       	rjmp	.+12     	; 0x199e <vfprintf+0x29c>
    1992:	60 81       	ld	r22, Z
    1994:	71 81       	ldd	r23, Z+1	; 0x01
    1996:	80 e0       	ldi	r24, 0x00	; 0
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	0e 5f       	subi	r16, 0xFE	; 254
    199c:	1f 4f       	sbci	r17, 0xFF	; 255
    199e:	a3 01       	movw	r20, r6
    19a0:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <__ultoa_invert>
    19a4:	88 2e       	mov	r8, r24
    19a6:	86 18       	sub	r8, r6
    19a8:	fb 2d       	mov	r31, r11
    19aa:	ff 77       	andi	r31, 0x7F	; 127
    19ac:	3f 2e       	mov	r3, r31
    19ae:	36 fe       	sbrs	r3, 6
    19b0:	0d c0       	rjmp	.+26     	; 0x19cc <vfprintf+0x2ca>
    19b2:	23 2d       	mov	r18, r3
    19b4:	2e 7f       	andi	r18, 0xFE	; 254
    19b6:	a2 2e       	mov	r10, r18
    19b8:	89 14       	cp	r8, r9
    19ba:	58 f4       	brcc	.+22     	; 0x19d2 <vfprintf+0x2d0>
    19bc:	34 fe       	sbrs	r3, 4
    19be:	0b c0       	rjmp	.+22     	; 0x19d6 <vfprintf+0x2d4>
    19c0:	32 fc       	sbrc	r3, 2
    19c2:	09 c0       	rjmp	.+18     	; 0x19d6 <vfprintf+0x2d4>
    19c4:	83 2d       	mov	r24, r3
    19c6:	8e 7e       	andi	r24, 0xEE	; 238
    19c8:	a8 2e       	mov	r10, r24
    19ca:	05 c0       	rjmp	.+10     	; 0x19d6 <vfprintf+0x2d4>
    19cc:	b8 2c       	mov	r11, r8
    19ce:	a3 2c       	mov	r10, r3
    19d0:	03 c0       	rjmp	.+6      	; 0x19d8 <vfprintf+0x2d6>
    19d2:	b8 2c       	mov	r11, r8
    19d4:	01 c0       	rjmp	.+2      	; 0x19d8 <vfprintf+0x2d6>
    19d6:	b9 2c       	mov	r11, r9
    19d8:	a4 fe       	sbrs	r10, 4
    19da:	0f c0       	rjmp	.+30     	; 0x19fa <vfprintf+0x2f8>
    19dc:	fe 01       	movw	r30, r28
    19de:	e8 0d       	add	r30, r8
    19e0:	f1 1d       	adc	r31, r1
    19e2:	80 81       	ld	r24, Z
    19e4:	80 33       	cpi	r24, 0x30	; 48
    19e6:	21 f4       	brne	.+8      	; 0x19f0 <vfprintf+0x2ee>
    19e8:	9a 2d       	mov	r25, r10
    19ea:	99 7e       	andi	r25, 0xE9	; 233
    19ec:	a9 2e       	mov	r10, r25
    19ee:	09 c0       	rjmp	.+18     	; 0x1a02 <vfprintf+0x300>
    19f0:	a2 fe       	sbrs	r10, 2
    19f2:	06 c0       	rjmp	.+12     	; 0x1a00 <vfprintf+0x2fe>
    19f4:	b3 94       	inc	r11
    19f6:	b3 94       	inc	r11
    19f8:	04 c0       	rjmp	.+8      	; 0x1a02 <vfprintf+0x300>
    19fa:	8a 2d       	mov	r24, r10
    19fc:	86 78       	andi	r24, 0x86	; 134
    19fe:	09 f0       	breq	.+2      	; 0x1a02 <vfprintf+0x300>
    1a00:	b3 94       	inc	r11
    1a02:	a3 fc       	sbrc	r10, 3
    1a04:	11 c0       	rjmp	.+34     	; 0x1a28 <vfprintf+0x326>
    1a06:	a0 fe       	sbrs	r10, 0
    1a08:	06 c0       	rjmp	.+12     	; 0x1a16 <vfprintf+0x314>
    1a0a:	b2 14       	cp	r11, r2
    1a0c:	88 f4       	brcc	.+34     	; 0x1a30 <vfprintf+0x32e>
    1a0e:	28 0c       	add	r2, r8
    1a10:	92 2c       	mov	r9, r2
    1a12:	9b 18       	sub	r9, r11
    1a14:	0e c0       	rjmp	.+28     	; 0x1a32 <vfprintf+0x330>
    1a16:	b2 14       	cp	r11, r2
    1a18:	60 f4       	brcc	.+24     	; 0x1a32 <vfprintf+0x330>
    1a1a:	b6 01       	movw	r22, r12
    1a1c:	80 e2       	ldi	r24, 0x20	; 32
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    1a24:	b3 94       	inc	r11
    1a26:	f7 cf       	rjmp	.-18     	; 0x1a16 <vfprintf+0x314>
    1a28:	b2 14       	cp	r11, r2
    1a2a:	18 f4       	brcc	.+6      	; 0x1a32 <vfprintf+0x330>
    1a2c:	2b 18       	sub	r2, r11
    1a2e:	02 c0       	rjmp	.+4      	; 0x1a34 <vfprintf+0x332>
    1a30:	98 2c       	mov	r9, r8
    1a32:	21 2c       	mov	r2, r1
    1a34:	a4 fe       	sbrs	r10, 4
    1a36:	10 c0       	rjmp	.+32     	; 0x1a58 <vfprintf+0x356>
    1a38:	b6 01       	movw	r22, r12
    1a3a:	80 e3       	ldi	r24, 0x30	; 48
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
    1a3e:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    1a42:	a2 fe       	sbrs	r10, 2
    1a44:	17 c0       	rjmp	.+46     	; 0x1a74 <vfprintf+0x372>
    1a46:	a1 fc       	sbrc	r10, 1
    1a48:	03 c0       	rjmp	.+6      	; 0x1a50 <vfprintf+0x34e>
    1a4a:	88 e7       	ldi	r24, 0x78	; 120
    1a4c:	90 e0       	ldi	r25, 0x00	; 0
    1a4e:	02 c0       	rjmp	.+4      	; 0x1a54 <vfprintf+0x352>
    1a50:	88 e5       	ldi	r24, 0x58	; 88
    1a52:	90 e0       	ldi	r25, 0x00	; 0
    1a54:	b6 01       	movw	r22, r12
    1a56:	0c c0       	rjmp	.+24     	; 0x1a70 <vfprintf+0x36e>
    1a58:	8a 2d       	mov	r24, r10
    1a5a:	86 78       	andi	r24, 0x86	; 134
    1a5c:	59 f0       	breq	.+22     	; 0x1a74 <vfprintf+0x372>
    1a5e:	a1 fe       	sbrs	r10, 1
    1a60:	02 c0       	rjmp	.+4      	; 0x1a66 <vfprintf+0x364>
    1a62:	8b e2       	ldi	r24, 0x2B	; 43
    1a64:	01 c0       	rjmp	.+2      	; 0x1a68 <vfprintf+0x366>
    1a66:	80 e2       	ldi	r24, 0x20	; 32
    1a68:	a7 fc       	sbrc	r10, 7
    1a6a:	8d e2       	ldi	r24, 0x2D	; 45
    1a6c:	b6 01       	movw	r22, r12
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    1a74:	89 14       	cp	r8, r9
    1a76:	38 f4       	brcc	.+14     	; 0x1a86 <vfprintf+0x384>
    1a78:	b6 01       	movw	r22, r12
    1a7a:	80 e3       	ldi	r24, 0x30	; 48
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    1a82:	9a 94       	dec	r9
    1a84:	f7 cf       	rjmp	.-18     	; 0x1a74 <vfprintf+0x372>
    1a86:	8a 94       	dec	r8
    1a88:	f3 01       	movw	r30, r6
    1a8a:	e8 0d       	add	r30, r8
    1a8c:	f1 1d       	adc	r31, r1
    1a8e:	80 81       	ld	r24, Z
    1a90:	b6 01       	movw	r22, r12
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    1a98:	81 10       	cpse	r8, r1
    1a9a:	f5 cf       	rjmp	.-22     	; 0x1a86 <vfprintf+0x384>
    1a9c:	22 20       	and	r2, r2
    1a9e:	09 f4       	brne	.+2      	; 0x1aa2 <vfprintf+0x3a0>
    1aa0:	42 ce       	rjmp	.-892    	; 0x1726 <vfprintf+0x24>
    1aa2:	b6 01       	movw	r22, r12
    1aa4:	80 e2       	ldi	r24, 0x20	; 32
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	0e 94 7b 0d 	call	0x1af6	; 0x1af6 <fputc>
    1aac:	2a 94       	dec	r2
    1aae:	f6 cf       	rjmp	.-20     	; 0x1a9c <vfprintf+0x39a>
    1ab0:	f6 01       	movw	r30, r12
    1ab2:	86 81       	ldd	r24, Z+6	; 0x06
    1ab4:	97 81       	ldd	r25, Z+7	; 0x07
    1ab6:	02 c0       	rjmp	.+4      	; 0x1abc <vfprintf+0x3ba>
    1ab8:	8f ef       	ldi	r24, 0xFF	; 255
    1aba:	9f ef       	ldi	r25, 0xFF	; 255
    1abc:	2b 96       	adiw	r28, 0x0b	; 11
    1abe:	e2 e1       	ldi	r30, 0x12	; 18
    1ac0:	0c 94 6e 0e 	jmp	0x1cdc	; 0x1cdc <__epilogue_restores__>

00001ac4 <__ctype_isfalse>:
    1ac4:	99 27       	eor	r25, r25
    1ac6:	88 27       	eor	r24, r24

00001ac8 <__ctype_istrue>:
    1ac8:	08 95       	ret

00001aca <strnlen_P>:
    1aca:	fc 01       	movw	r30, r24
    1acc:	05 90       	lpm	r0, Z+
    1ace:	61 50       	subi	r22, 0x01	; 1
    1ad0:	70 40       	sbci	r23, 0x00	; 0
    1ad2:	01 10       	cpse	r0, r1
    1ad4:	d8 f7       	brcc	.-10     	; 0x1acc <strnlen_P+0x2>
    1ad6:	80 95       	com	r24
    1ad8:	90 95       	com	r25
    1ada:	8e 0f       	add	r24, r30
    1adc:	9f 1f       	adc	r25, r31
    1ade:	08 95       	ret

00001ae0 <strnlen>:
    1ae0:	fc 01       	movw	r30, r24
    1ae2:	61 50       	subi	r22, 0x01	; 1
    1ae4:	70 40       	sbci	r23, 0x00	; 0
    1ae6:	01 90       	ld	r0, Z+
    1ae8:	01 10       	cpse	r0, r1
    1aea:	d8 f7       	brcc	.-10     	; 0x1ae2 <strnlen+0x2>
    1aec:	80 95       	com	r24
    1aee:	90 95       	com	r25
    1af0:	8e 0f       	add	r24, r30
    1af2:	9f 1f       	adc	r25, r31
    1af4:	08 95       	ret

00001af6 <fputc>:
    1af6:	0f 93       	push	r16
    1af8:	1f 93       	push	r17
    1afa:	cf 93       	push	r28
    1afc:	df 93       	push	r29
    1afe:	fb 01       	movw	r30, r22
    1b00:	23 81       	ldd	r18, Z+3	; 0x03
    1b02:	21 fd       	sbrc	r18, 1
    1b04:	03 c0       	rjmp	.+6      	; 0x1b0c <fputc+0x16>
    1b06:	8f ef       	ldi	r24, 0xFF	; 255
    1b08:	9f ef       	ldi	r25, 0xFF	; 255
    1b0a:	2c c0       	rjmp	.+88     	; 0x1b64 <fputc+0x6e>
    1b0c:	22 ff       	sbrs	r18, 2
    1b0e:	16 c0       	rjmp	.+44     	; 0x1b3c <fputc+0x46>
    1b10:	46 81       	ldd	r20, Z+6	; 0x06
    1b12:	57 81       	ldd	r21, Z+7	; 0x07
    1b14:	24 81       	ldd	r18, Z+4	; 0x04
    1b16:	35 81       	ldd	r19, Z+5	; 0x05
    1b18:	42 17       	cp	r20, r18
    1b1a:	53 07       	cpc	r21, r19
    1b1c:	44 f4       	brge	.+16     	; 0x1b2e <fputc+0x38>
    1b1e:	a0 81       	ld	r26, Z
    1b20:	b1 81       	ldd	r27, Z+1	; 0x01
    1b22:	9d 01       	movw	r18, r26
    1b24:	2f 5f       	subi	r18, 0xFF	; 255
    1b26:	3f 4f       	sbci	r19, 0xFF	; 255
    1b28:	31 83       	std	Z+1, r19	; 0x01
    1b2a:	20 83       	st	Z, r18
    1b2c:	8c 93       	st	X, r24
    1b2e:	26 81       	ldd	r18, Z+6	; 0x06
    1b30:	37 81       	ldd	r19, Z+7	; 0x07
    1b32:	2f 5f       	subi	r18, 0xFF	; 255
    1b34:	3f 4f       	sbci	r19, 0xFF	; 255
    1b36:	37 83       	std	Z+7, r19	; 0x07
    1b38:	26 83       	std	Z+6, r18	; 0x06
    1b3a:	14 c0       	rjmp	.+40     	; 0x1b64 <fputc+0x6e>
    1b3c:	8b 01       	movw	r16, r22
    1b3e:	ec 01       	movw	r28, r24
    1b40:	fb 01       	movw	r30, r22
    1b42:	00 84       	ldd	r0, Z+8	; 0x08
    1b44:	f1 85       	ldd	r31, Z+9	; 0x09
    1b46:	e0 2d       	mov	r30, r0
    1b48:	09 95       	icall
    1b4a:	89 2b       	or	r24, r25
    1b4c:	e1 f6       	brne	.-72     	; 0x1b06 <fputc+0x10>
    1b4e:	d8 01       	movw	r26, r16
    1b50:	16 96       	adiw	r26, 0x06	; 6
    1b52:	8d 91       	ld	r24, X+
    1b54:	9c 91       	ld	r25, X
    1b56:	17 97       	sbiw	r26, 0x07	; 7
    1b58:	01 96       	adiw	r24, 0x01	; 1
    1b5a:	17 96       	adiw	r26, 0x07	; 7
    1b5c:	9c 93       	st	X, r25
    1b5e:	8e 93       	st	-X, r24
    1b60:	16 97       	sbiw	r26, 0x06	; 6
    1b62:	ce 01       	movw	r24, r28
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
    1b68:	1f 91       	pop	r17
    1b6a:	0f 91       	pop	r16
    1b6c:	08 95       	ret

00001b6e <__ultoa_invert>:
    1b6e:	fa 01       	movw	r30, r20
    1b70:	aa 27       	eor	r26, r26
    1b72:	28 30       	cpi	r18, 0x08	; 8
    1b74:	51 f1       	breq	.+84     	; 0x1bca <__ultoa_invert+0x5c>
    1b76:	20 31       	cpi	r18, 0x10	; 16
    1b78:	81 f1       	breq	.+96     	; 0x1bda <__ultoa_invert+0x6c>
    1b7a:	e8 94       	clt
    1b7c:	6f 93       	push	r22
    1b7e:	6e 7f       	andi	r22, 0xFE	; 254
    1b80:	6e 5f       	subi	r22, 0xFE	; 254
    1b82:	7f 4f       	sbci	r23, 0xFF	; 255
    1b84:	8f 4f       	sbci	r24, 0xFF	; 255
    1b86:	9f 4f       	sbci	r25, 0xFF	; 255
    1b88:	af 4f       	sbci	r26, 0xFF	; 255
    1b8a:	b1 e0       	ldi	r27, 0x01	; 1
    1b8c:	3e d0       	rcall	.+124    	; 0x1c0a <__ultoa_invert+0x9c>
    1b8e:	b4 e0       	ldi	r27, 0x04	; 4
    1b90:	3c d0       	rcall	.+120    	; 0x1c0a <__ultoa_invert+0x9c>
    1b92:	67 0f       	add	r22, r23
    1b94:	78 1f       	adc	r23, r24
    1b96:	89 1f       	adc	r24, r25
    1b98:	9a 1f       	adc	r25, r26
    1b9a:	a1 1d       	adc	r26, r1
    1b9c:	68 0f       	add	r22, r24
    1b9e:	79 1f       	adc	r23, r25
    1ba0:	8a 1f       	adc	r24, r26
    1ba2:	91 1d       	adc	r25, r1
    1ba4:	a1 1d       	adc	r26, r1
    1ba6:	6a 0f       	add	r22, r26
    1ba8:	71 1d       	adc	r23, r1
    1baa:	81 1d       	adc	r24, r1
    1bac:	91 1d       	adc	r25, r1
    1bae:	a1 1d       	adc	r26, r1
    1bb0:	20 d0       	rcall	.+64     	; 0x1bf2 <__ultoa_invert+0x84>
    1bb2:	09 f4       	brne	.+2      	; 0x1bb6 <__ultoa_invert+0x48>
    1bb4:	68 94       	set
    1bb6:	3f 91       	pop	r19
    1bb8:	2a e0       	ldi	r18, 0x0A	; 10
    1bba:	26 9f       	mul	r18, r22
    1bbc:	11 24       	eor	r1, r1
    1bbe:	30 19       	sub	r19, r0
    1bc0:	30 5d       	subi	r19, 0xD0	; 208
    1bc2:	31 93       	st	Z+, r19
    1bc4:	de f6       	brtc	.-74     	; 0x1b7c <__ultoa_invert+0xe>
    1bc6:	cf 01       	movw	r24, r30
    1bc8:	08 95       	ret
    1bca:	46 2f       	mov	r20, r22
    1bcc:	47 70       	andi	r20, 0x07	; 7
    1bce:	40 5d       	subi	r20, 0xD0	; 208
    1bd0:	41 93       	st	Z+, r20
    1bd2:	b3 e0       	ldi	r27, 0x03	; 3
    1bd4:	0f d0       	rcall	.+30     	; 0x1bf4 <__ultoa_invert+0x86>
    1bd6:	c9 f7       	brne	.-14     	; 0x1bca <__ultoa_invert+0x5c>
    1bd8:	f6 cf       	rjmp	.-20     	; 0x1bc6 <__ultoa_invert+0x58>
    1bda:	46 2f       	mov	r20, r22
    1bdc:	4f 70       	andi	r20, 0x0F	; 15
    1bde:	40 5d       	subi	r20, 0xD0	; 208
    1be0:	4a 33       	cpi	r20, 0x3A	; 58
    1be2:	18 f0       	brcs	.+6      	; 0x1bea <__ultoa_invert+0x7c>
    1be4:	49 5d       	subi	r20, 0xD9	; 217
    1be6:	31 fd       	sbrc	r19, 1
    1be8:	40 52       	subi	r20, 0x20	; 32
    1bea:	41 93       	st	Z+, r20
    1bec:	02 d0       	rcall	.+4      	; 0x1bf2 <__ultoa_invert+0x84>
    1bee:	a9 f7       	brne	.-22     	; 0x1bda <__ultoa_invert+0x6c>
    1bf0:	ea cf       	rjmp	.-44     	; 0x1bc6 <__ultoa_invert+0x58>
    1bf2:	b4 e0       	ldi	r27, 0x04	; 4
    1bf4:	a6 95       	lsr	r26
    1bf6:	97 95       	ror	r25
    1bf8:	87 95       	ror	r24
    1bfa:	77 95       	ror	r23
    1bfc:	67 95       	ror	r22
    1bfe:	ba 95       	dec	r27
    1c00:	c9 f7       	brne	.-14     	; 0x1bf4 <__ultoa_invert+0x86>
    1c02:	00 97       	sbiw	r24, 0x00	; 0
    1c04:	61 05       	cpc	r22, r1
    1c06:	71 05       	cpc	r23, r1
    1c08:	08 95       	ret
    1c0a:	9b 01       	movw	r18, r22
    1c0c:	ac 01       	movw	r20, r24
    1c0e:	0a 2e       	mov	r0, r26
    1c10:	06 94       	lsr	r0
    1c12:	57 95       	ror	r21
    1c14:	47 95       	ror	r20
    1c16:	37 95       	ror	r19
    1c18:	27 95       	ror	r18
    1c1a:	ba 95       	dec	r27
    1c1c:	c9 f7       	brne	.-14     	; 0x1c10 <__ultoa_invert+0xa2>
    1c1e:	62 0f       	add	r22, r18
    1c20:	73 1f       	adc	r23, r19
    1c22:	84 1f       	adc	r24, r20
    1c24:	95 1f       	adc	r25, r21
    1c26:	a0 1d       	adc	r26, r0
    1c28:	08 95       	ret

00001c2a <__mulsi3>:
    1c2a:	db 01       	movw	r26, r22
    1c2c:	8f 93       	push	r24
    1c2e:	9f 93       	push	r25
    1c30:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <__muluhisi3>
    1c34:	bf 91       	pop	r27
    1c36:	af 91       	pop	r26
    1c38:	a2 9f       	mul	r26, r18
    1c3a:	80 0d       	add	r24, r0
    1c3c:	91 1d       	adc	r25, r1
    1c3e:	a3 9f       	mul	r26, r19
    1c40:	90 0d       	add	r25, r0
    1c42:	b2 9f       	mul	r27, r18
    1c44:	90 0d       	add	r25, r0
    1c46:	11 24       	eor	r1, r1
    1c48:	08 95       	ret

00001c4a <__udivmodsi4>:
    1c4a:	a1 e2       	ldi	r26, 0x21	; 33
    1c4c:	1a 2e       	mov	r1, r26
    1c4e:	aa 1b       	sub	r26, r26
    1c50:	bb 1b       	sub	r27, r27
    1c52:	fd 01       	movw	r30, r26
    1c54:	0d c0       	rjmp	.+26     	; 0x1c70 <__udivmodsi4_ep>

00001c56 <__udivmodsi4_loop>:
    1c56:	aa 1f       	adc	r26, r26
    1c58:	bb 1f       	adc	r27, r27
    1c5a:	ee 1f       	adc	r30, r30
    1c5c:	ff 1f       	adc	r31, r31
    1c5e:	a2 17       	cp	r26, r18
    1c60:	b3 07       	cpc	r27, r19
    1c62:	e4 07       	cpc	r30, r20
    1c64:	f5 07       	cpc	r31, r21
    1c66:	20 f0       	brcs	.+8      	; 0x1c70 <__udivmodsi4_ep>
    1c68:	a2 1b       	sub	r26, r18
    1c6a:	b3 0b       	sbc	r27, r19
    1c6c:	e4 0b       	sbc	r30, r20
    1c6e:	f5 0b       	sbc	r31, r21

00001c70 <__udivmodsi4_ep>:
    1c70:	66 1f       	adc	r22, r22
    1c72:	77 1f       	adc	r23, r23
    1c74:	88 1f       	adc	r24, r24
    1c76:	99 1f       	adc	r25, r25
    1c78:	1a 94       	dec	r1
    1c7a:	69 f7       	brne	.-38     	; 0x1c56 <__udivmodsi4_loop>
    1c7c:	60 95       	com	r22
    1c7e:	70 95       	com	r23
    1c80:	80 95       	com	r24
    1c82:	90 95       	com	r25
    1c84:	9b 01       	movw	r18, r22
    1c86:	ac 01       	movw	r20, r24
    1c88:	bd 01       	movw	r22, r26
    1c8a:	cf 01       	movw	r24, r30
    1c8c:	08 95       	ret

00001c8e <__muluhisi3>:
    1c8e:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <__umulhisi3>
    1c92:	a5 9f       	mul	r26, r21
    1c94:	90 0d       	add	r25, r0
    1c96:	b4 9f       	mul	r27, r20
    1c98:	90 0d       	add	r25, r0
    1c9a:	a4 9f       	mul	r26, r20
    1c9c:	80 0d       	add	r24, r0
    1c9e:	91 1d       	adc	r25, r1
    1ca0:	11 24       	eor	r1, r1
    1ca2:	08 95       	ret

00001ca4 <__prologue_saves__>:
    1ca4:	2f 92       	push	r2
    1ca6:	3f 92       	push	r3
    1ca8:	4f 92       	push	r4
    1caa:	5f 92       	push	r5
    1cac:	6f 92       	push	r6
    1cae:	7f 92       	push	r7
    1cb0:	8f 92       	push	r8
    1cb2:	9f 92       	push	r9
    1cb4:	af 92       	push	r10
    1cb6:	bf 92       	push	r11
    1cb8:	cf 92       	push	r12
    1cba:	df 92       	push	r13
    1cbc:	ef 92       	push	r14
    1cbe:	ff 92       	push	r15
    1cc0:	0f 93       	push	r16
    1cc2:	1f 93       	push	r17
    1cc4:	cf 93       	push	r28
    1cc6:	df 93       	push	r29
    1cc8:	cd b7       	in	r28, 0x3d	; 61
    1cca:	de b7       	in	r29, 0x3e	; 62
    1ccc:	ca 1b       	sub	r28, r26
    1cce:	db 0b       	sbc	r29, r27
    1cd0:	0f b6       	in	r0, 0x3f	; 63
    1cd2:	f8 94       	cli
    1cd4:	de bf       	out	0x3e, r29	; 62
    1cd6:	0f be       	out	0x3f, r0	; 63
    1cd8:	cd bf       	out	0x3d, r28	; 61
    1cda:	09 94       	ijmp

00001cdc <__epilogue_restores__>:
    1cdc:	2a 88       	ldd	r2, Y+18	; 0x12
    1cde:	39 88       	ldd	r3, Y+17	; 0x11
    1ce0:	48 88       	ldd	r4, Y+16	; 0x10
    1ce2:	5f 84       	ldd	r5, Y+15	; 0x0f
    1ce4:	6e 84       	ldd	r6, Y+14	; 0x0e
    1ce6:	7d 84       	ldd	r7, Y+13	; 0x0d
    1ce8:	8c 84       	ldd	r8, Y+12	; 0x0c
    1cea:	9b 84       	ldd	r9, Y+11	; 0x0b
    1cec:	aa 84       	ldd	r10, Y+10	; 0x0a
    1cee:	b9 84       	ldd	r11, Y+9	; 0x09
    1cf0:	c8 84       	ldd	r12, Y+8	; 0x08
    1cf2:	df 80       	ldd	r13, Y+7	; 0x07
    1cf4:	ee 80       	ldd	r14, Y+6	; 0x06
    1cf6:	fd 80       	ldd	r15, Y+5	; 0x05
    1cf8:	0c 81       	ldd	r16, Y+4	; 0x04
    1cfa:	1b 81       	ldd	r17, Y+3	; 0x03
    1cfc:	aa 81       	ldd	r26, Y+2	; 0x02
    1cfe:	b9 81       	ldd	r27, Y+1	; 0x01
    1d00:	ce 0f       	add	r28, r30
    1d02:	d1 1d       	adc	r29, r1
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	de bf       	out	0x3e, r29	; 62
    1d0a:	0f be       	out	0x3f, r0	; 63
    1d0c:	cd bf       	out	0x3d, r28	; 61
    1d0e:	ed 01       	movw	r28, r26
    1d10:	08 95       	ret

00001d12 <__umulhisi3>:
    1d12:	a2 9f       	mul	r26, r18
    1d14:	b0 01       	movw	r22, r0
    1d16:	b3 9f       	mul	r27, r19
    1d18:	c0 01       	movw	r24, r0
    1d1a:	a3 9f       	mul	r26, r19
    1d1c:	70 0d       	add	r23, r0
    1d1e:	81 1d       	adc	r24, r1
    1d20:	11 24       	eor	r1, r1
    1d22:	91 1d       	adc	r25, r1
    1d24:	b2 9f       	mul	r27, r18
    1d26:	70 0d       	add	r23, r0
    1d28:	81 1d       	adc	r24, r1
    1d2a:	11 24       	eor	r1, r1
    1d2c:	91 1d       	adc	r25, r1
    1d2e:	08 95       	ret

00001d30 <_exit>:
    1d30:	f8 94       	cli

00001d32 <__stop_program>:
    1d32:	ff cf       	rjmp	.-2      	; 0x1d32 <__stop_program>
