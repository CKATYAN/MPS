
laba4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000011ca  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  000011ca  0000125e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000069b  00800078  00800078  00001276  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001276  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000012a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000330  00000000  00000000  000012e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003781  00000000  00000000  00001614  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001259  00000000  00000000  00004d95  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002187  00000000  00000000  00005fee  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000083c  00000000  00000000  00008178  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000012b8  00000000  00000000  000089b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002e4e  00000000  00000000  00009c6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000328  00000000  00000000  0000caba  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 96 02 	jmp	0x52c	; 0x52c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 d8 07 	jmp	0xfb0	; 0xfb0 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ec       	ldi	r30, 0xCA	; 202
      68:	f1 e1       	ldi	r31, 0x11	; 17
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 37       	cpi	r26, 0x78	; 120
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a8 e7       	ldi	r26, 0x78	; 120
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 31       	cpi	r26, 0x13	; 19
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e7 07 	call	0xfce	; 0xfce <main>
      8a:	0c 94 e3 08 	jmp	0x11c6	; 0x11c6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <nullifyDataArray>:
void setMonthDataArray()
{
	const char* monthStr = months[month];
	for (int i = 0; i < 3; i++)
	{
		data[i + 3] = monthStr[i];
      92:	e5 ee       	ldi	r30, 0xE5	; 229
      94:	f6 e0       	ldi	r31, 0x06	; 6
      96:	20 e3       	ldi	r18, 0x30	; 48
      98:	30 e0       	ldi	r19, 0x00	; 0
      9a:	31 83       	std	Z+1, r19	; 0x01
      9c:	20 83       	st	Z, r18
      9e:	81 e3       	ldi	r24, 0x31	; 49
      a0:	90 e0       	ldi	r25, 0x00	; 0
      a2:	93 83       	std	Z+3, r25	; 0x03
      a4:	82 83       	std	Z+2, r24	; 0x02
      a6:	80 e2       	ldi	r24, 0x20	; 32
      a8:	90 e0       	ldi	r25, 0x00	; 0
      aa:	95 83       	std	Z+5, r25	; 0x05
      ac:	84 83       	std	Z+4, r24	; 0x04
      ae:	4a e4       	ldi	r20, 0x4A	; 74
      b0:	50 e0       	ldi	r21, 0x00	; 0
      b2:	57 83       	std	Z+7, r21	; 0x07
      b4:	46 83       	std	Z+6, r20	; 0x06
      b6:	41 e6       	ldi	r20, 0x61	; 97
      b8:	50 e0       	ldi	r21, 0x00	; 0
      ba:	51 87       	std	Z+9, r21	; 0x09
      bc:	40 87       	std	Z+8, r20	; 0x08
      be:	4e e6       	ldi	r20, 0x6E	; 110
      c0:	50 e0       	ldi	r21, 0x00	; 0
      c2:	53 87       	std	Z+11, r21	; 0x0b
      c4:	42 87       	std	Z+10, r20	; 0x0a
      c6:	95 87       	std	Z+13, r25	; 0x0d
      c8:	84 87       	std	Z+12, r24	; 0x0c
      ca:	82 e3       	ldi	r24, 0x32	; 50
      cc:	90 e0       	ldi	r25, 0x00	; 0
      ce:	97 87       	std	Z+15, r25	; 0x0f
      d0:	86 87       	std	Z+14, r24	; 0x0e
      d2:	31 8b       	std	Z+17, r19	; 0x11
      d4:	20 8b       	std	Z+16, r18	; 0x10
      d6:	93 8b       	std	Z+19, r25	; 0x13
      d8:	82 8b       	std	Z+18, r24	; 0x12
      da:	84 e3       	ldi	r24, 0x34	; 52
      dc:	90 e0       	ldi	r25, 0x00	; 0
      de:	95 8b       	std	Z+21, r25	; 0x15
      e0:	84 8b       	std	Z+20, r24	; 0x14
      e2:	08 95       	ret

000000e4 <clearDisplaySecondLine>:
	dataArrayToDisplaySecondLine(positionOnDisplay);
	showDisplaySecondLine();
}

void clearDisplaySecondLine()
{
      e4:	e5 ec       	ldi	r30, 0xC5	; 197
      e6:	f6 e0       	ldi	r31, 0x06	; 6
      e8:	25 ee       	ldi	r18, 0xE5	; 229
      ea:	36 e0       	ldi	r19, 0x06	; 6
	for (int i = 0; i < 16; i++)
	{
		displaySecondLine[i] = ' ';
      ec:	80 e2       	ldi	r24, 0x20	; 32
      ee:	90 e0       	ldi	r25, 0x00	; 0
      f0:	81 93       	st	Z+, r24
      f2:	91 93       	st	Z+, r25
	showDisplaySecondLine();
}

void clearDisplaySecondLine()
{
	for (int i = 0; i < 16; i++)
      f4:	e2 17       	cp	r30, r18
      f6:	f3 07       	cpc	r31, r19
      f8:	d9 f7       	brne	.-10     	; 0xf0 <clearDisplaySecondLine+0xc>
	{
		displaySecondLine[i] = ' ';
	}
}
      fa:	08 95       	ret

000000fc <dataArrayToDisplaySecondLine>:

void dataArrayToDisplaySecondLine(int positionOnDisplay)
{
      fc:	e5 ee       	ldi	r30, 0xE5	; 229
      fe:	f6 e0       	ldi	r31, 0x06	; 6
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	dc 01       	movw	r26, r24
     106:	ab 53       	subi	r26, 0x3B	; 59
     108:	b9 4f       	sbci	r27, 0xF9	; 249
     10a:	2b ef       	ldi	r18, 0xFB	; 251
     10c:	36 e0       	ldi	r19, 0x06	; 6
	for(int i = 0; i<11; i++)
	{
		displaySecondLine[positionOnDisplay + i] = data[i];
     10e:	81 91       	ld	r24, Z+
     110:	91 91       	ld	r25, Z+
     112:	8d 93       	st	X+, r24
     114:	9d 93       	st	X+, r25
	}
}

void dataArrayToDisplaySecondLine(int positionOnDisplay)
{
	for(int i = 0; i<11; i++)
     116:	e2 17       	cp	r30, r18
     118:	f3 07       	cpc	r31, r19
     11a:	c9 f7       	brne	.-14     	; 0x10e <dataArrayToDisplaySecondLine+0x12>
	{
		displaySecondLine[positionOnDisplay + i] = data[i];
	}
}
     11c:	08 95       	ret

0000011e <showDisplaySecondLine>:

void showDisplaySecondLine()
{
     11e:	0f 93       	push	r16
     120:	1f 93       	push	r17
     122:	cf 93       	push	r28
     124:	df 93       	push	r29
	LCDKursorPosihin(1, 0);
     126:	60 e0       	ldi	r22, 0x00	; 0
     128:	81 e0       	ldi	r24, 0x01	; 1
     12a:	0e 94 c4 07 	call	0xf88	; 0xf88 <LCDKursorPosihin>
     12e:	c5 ec       	ldi	r28, 0xC5	; 197
     130:	d6 e0       	ldi	r29, 0x06	; 6
     132:	05 ee       	ldi	r16, 0xE5	; 229
     134:	16 e0       	ldi	r17, 0x06	; 6
	for (int i = 0; i < 16; i++)
	{
		LCDWriteByte(LCD_DR, displaySecondLine[i]);
     136:	68 81       	ld	r22, Y
     138:	22 96       	adiw	r28, 0x02	; 2
     13a:	81 e0       	ldi	r24, 0x01	; 1
     13c:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
}

void showDisplaySecondLine()
{
	LCDKursorPosihin(1, 0);
	for (int i = 0; i < 16; i++)
     140:	c0 17       	cp	r28, r16
     142:	d1 07       	cpc	r29, r17
     144:	c1 f7       	brne	.-16     	; 0x136 <showDisplaySecondLine+0x18>
	{
		LCDWriteByte(LCD_DR, displaySecondLine[i]);
	}
}
     146:	df 91       	pop	r29
     148:	cf 91       	pop	r28
     14a:	1f 91       	pop	r17
     14c:	0f 91       	pop	r16
     14e:	08 95       	ret

00000150 <displayData>:
		data[i + 3] = monthStr[i];
	}
}

void displayData(int positionOnDisplay)
{
     150:	cf 93       	push	r28
     152:	df 93       	push	r29
     154:	ec 01       	movw	r28, r24
	clearDisplaySecondLine();
     156:	0e 94 72 00 	call	0xe4	; 0xe4 <clearDisplaySecondLine>
	dataArrayToDisplaySecondLine(positionOnDisplay);
     15a:	ce 01       	movw	r24, r28
     15c:	0e 94 7e 00 	call	0xfc	; 0xfc <dataArrayToDisplaySecondLine>
	showDisplaySecondLine();
     160:	0e 94 8f 00 	call	0x11e	; 0x11e <showDisplaySecondLine>
}
     164:	df 91       	pop	r29
     166:	cf 91       	pop	r28
     168:	08 95       	ret

0000016a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     16a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     16c:	03 96       	adiw	r24, 0x03	; 3
     16e:	92 83       	std	Z+2, r25	; 0x02
     170:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     172:	2f ef       	ldi	r18, 0xFF	; 255
     174:	3f ef       	ldi	r19, 0xFF	; 255
     176:	34 83       	std	Z+4, r19	; 0x04
     178:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     17a:	96 83       	std	Z+6, r25	; 0x06
     17c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     17e:	90 87       	std	Z+8, r25	; 0x08
     180:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     182:	10 82       	st	Z, r1
     184:	08 95       	ret

00000186 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     186:	fc 01       	movw	r30, r24
     188:	11 86       	std	Z+9, r1	; 0x09
     18a:	10 86       	std	Z+8, r1	; 0x08
     18c:	08 95       	ret

0000018e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     18e:	cf 93       	push	r28
     190:	df 93       	push	r29
     192:	9c 01       	movw	r18, r24
     194:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     196:	dc 01       	movw	r26, r24
     198:	11 96       	adiw	r26, 0x01	; 1
     19a:	cd 91       	ld	r28, X+
     19c:	dc 91       	ld	r29, X
     19e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     1a0:	d3 83       	std	Z+3, r29	; 0x03
     1a2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     1a4:	8c 81       	ldd	r24, Y+4	; 0x04
     1a6:	9d 81       	ldd	r25, Y+5	; 0x05
     1a8:	95 83       	std	Z+5, r25	; 0x05
     1aa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     1ac:	8c 81       	ldd	r24, Y+4	; 0x04
     1ae:	9d 81       	ldd	r25, Y+5	; 0x05
     1b0:	dc 01       	movw	r26, r24
     1b2:	13 96       	adiw	r26, 0x03	; 3
     1b4:	7c 93       	st	X, r23
     1b6:	6e 93       	st	-X, r22
     1b8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     1ba:	7d 83       	std	Y+5, r23	; 0x05
     1bc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     1be:	31 87       	std	Z+9, r19	; 0x09
     1c0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     1c2:	f9 01       	movw	r30, r18
     1c4:	80 81       	ld	r24, Z
     1c6:	8f 5f       	subi	r24, 0xFF	; 255
     1c8:	80 83       	st	Z, r24
}
     1ca:	df 91       	pop	r29
     1cc:	cf 91       	pop	r28
     1ce:	08 95       	ret

000001d0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1d0:	cf 93       	push	r28
     1d2:	df 93       	push	r29
     1d4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     1d6:	48 81       	ld	r20, Y
     1d8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     1da:	4f 3f       	cpi	r20, 0xFF	; 255
     1dc:	2f ef       	ldi	r18, 0xFF	; 255
     1de:	52 07       	cpc	r21, r18
     1e0:	21 f4       	brne	.+8      	; 0x1ea <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     1e2:	fc 01       	movw	r30, r24
     1e4:	a7 81       	ldd	r26, Z+7	; 0x07
     1e6:	b0 85       	ldd	r27, Z+8	; 0x08
     1e8:	0d c0       	rjmp	.+26     	; 0x204 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     1ea:	dc 01       	movw	r26, r24
     1ec:	13 96       	adiw	r26, 0x03	; 3
     1ee:	01 c0       	rjmp	.+2      	; 0x1f2 <vListInsert+0x22>
     1f0:	df 01       	movw	r26, r30
     1f2:	12 96       	adiw	r26, 0x02	; 2
     1f4:	ed 91       	ld	r30, X+
     1f6:	fc 91       	ld	r31, X
     1f8:	13 97       	sbiw	r26, 0x03	; 3
     1fa:	20 81       	ld	r18, Z
     1fc:	31 81       	ldd	r19, Z+1	; 0x01
     1fe:	42 17       	cp	r20, r18
     200:	53 07       	cpc	r21, r19
     202:	b0 f7       	brcc	.-20     	; 0x1f0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     204:	12 96       	adiw	r26, 0x02	; 2
     206:	ed 91       	ld	r30, X+
     208:	fc 91       	ld	r31, X
     20a:	13 97       	sbiw	r26, 0x03	; 3
     20c:	fb 83       	std	Y+3, r31	; 0x03
     20e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     210:	d5 83       	std	Z+5, r29	; 0x05
     212:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     214:	bd 83       	std	Y+5, r27	; 0x05
     216:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     218:	13 96       	adiw	r26, 0x03	; 3
     21a:	dc 93       	st	X, r29
     21c:	ce 93       	st	-X, r28
     21e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     220:	99 87       	std	Y+9, r25	; 0x09
     222:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     224:	fc 01       	movw	r30, r24
     226:	20 81       	ld	r18, Z
     228:	2f 5f       	subi	r18, 0xFF	; 255
     22a:	20 83       	st	Z, r18
}
     22c:	df 91       	pop	r29
     22e:	cf 91       	pop	r28
     230:	08 95       	ret

00000232 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     238:	a0 85       	ldd	r26, Z+8	; 0x08
     23a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     23c:	c2 81       	ldd	r28, Z+2	; 0x02
     23e:	d3 81       	ldd	r29, Z+3	; 0x03
     240:	84 81       	ldd	r24, Z+4	; 0x04
     242:	95 81       	ldd	r25, Z+5	; 0x05
     244:	9d 83       	std	Y+5, r25	; 0x05
     246:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     248:	c4 81       	ldd	r28, Z+4	; 0x04
     24a:	d5 81       	ldd	r29, Z+5	; 0x05
     24c:	82 81       	ldd	r24, Z+2	; 0x02
     24e:	93 81       	ldd	r25, Z+3	; 0x03
     250:	9b 83       	std	Y+3, r25	; 0x03
     252:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     254:	11 96       	adiw	r26, 0x01	; 1
     256:	8d 91       	ld	r24, X+
     258:	9c 91       	ld	r25, X
     25a:	12 97       	sbiw	r26, 0x02	; 2
     25c:	e8 17       	cp	r30, r24
     25e:	f9 07       	cpc	r31, r25
     260:	31 f4       	brne	.+12     	; 0x26e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     262:	84 81       	ldd	r24, Z+4	; 0x04
     264:	95 81       	ldd	r25, Z+5	; 0x05
     266:	12 96       	adiw	r26, 0x02	; 2
     268:	9c 93       	st	X, r25
     26a:	8e 93       	st	-X, r24
     26c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     26e:	11 86       	std	Z+9, r1	; 0x09
     270:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     272:	8c 91       	ld	r24, X
     274:	81 50       	subi	r24, 0x01	; 1
     276:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     278:	8c 91       	ld	r24, X
}
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	08 95       	ret

00000280 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     280:	31 e1       	ldi	r19, 0x11	; 17
     282:	fc 01       	movw	r30, r24
     284:	30 83       	st	Z, r19
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	22 e2       	ldi	r18, 0x22	; 34
     28a:	20 83       	st	Z, r18
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	a3 e3       	ldi	r26, 0x33	; 51
     290:	a0 83       	st	Z, r26
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	60 83       	st	Z, r22
     296:	31 97       	sbiw	r30, 0x01	; 1
     298:	70 83       	st	Z, r23
     29a:	31 97       	sbiw	r30, 0x01	; 1
     29c:	10 82       	st	Z, r1
     29e:	31 97       	sbiw	r30, 0x01	; 1
     2a0:	60 e8       	ldi	r22, 0x80	; 128
     2a2:	60 83       	st	Z, r22
     2a4:	31 97       	sbiw	r30, 0x01	; 1
     2a6:	10 82       	st	Z, r1
     2a8:	31 97       	sbiw	r30, 0x01	; 1
     2aa:	62 e0       	ldi	r22, 0x02	; 2
     2ac:	60 83       	st	Z, r22
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	63 e0       	ldi	r22, 0x03	; 3
     2b2:	60 83       	st	Z, r22
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	64 e0       	ldi	r22, 0x04	; 4
     2b8:	60 83       	st	Z, r22
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	65 e0       	ldi	r22, 0x05	; 5
     2be:	60 83       	st	Z, r22
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	66 e0       	ldi	r22, 0x06	; 6
     2c4:	60 83       	st	Z, r22
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	67 e0       	ldi	r22, 0x07	; 7
     2ca:	60 83       	st	Z, r22
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	68 e0       	ldi	r22, 0x08	; 8
     2d0:	60 83       	st	Z, r22
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	69 e0       	ldi	r22, 0x09	; 9
     2d6:	60 83       	st	Z, r22
     2d8:	31 97       	sbiw	r30, 0x01	; 1
     2da:	60 e1       	ldi	r22, 0x10	; 16
     2dc:	60 83       	st	Z, r22
     2de:	31 97       	sbiw	r30, 0x01	; 1
     2e0:	30 83       	st	Z, r19
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	32 e1       	ldi	r19, 0x12	; 18
     2e6:	30 83       	st	Z, r19
     2e8:	31 97       	sbiw	r30, 0x01	; 1
     2ea:	33 e1       	ldi	r19, 0x13	; 19
     2ec:	30 83       	st	Z, r19
     2ee:	31 97       	sbiw	r30, 0x01	; 1
     2f0:	34 e1       	ldi	r19, 0x14	; 20
     2f2:	30 83       	st	Z, r19
     2f4:	31 97       	sbiw	r30, 0x01	; 1
     2f6:	35 e1       	ldi	r19, 0x15	; 21
     2f8:	30 83       	st	Z, r19
     2fa:	31 97       	sbiw	r30, 0x01	; 1
     2fc:	36 e1       	ldi	r19, 0x16	; 22
     2fe:	30 83       	st	Z, r19
     300:	31 97       	sbiw	r30, 0x01	; 1
     302:	37 e1       	ldi	r19, 0x17	; 23
     304:	30 83       	st	Z, r19
     306:	31 97       	sbiw	r30, 0x01	; 1
     308:	38 e1       	ldi	r19, 0x18	; 24
     30a:	30 83       	st	Z, r19
     30c:	31 97       	sbiw	r30, 0x01	; 1
     30e:	39 e1       	ldi	r19, 0x19	; 25
     310:	30 83       	st	Z, r19
     312:	31 97       	sbiw	r30, 0x01	; 1
     314:	30 e2       	ldi	r19, 0x20	; 32
     316:	30 83       	st	Z, r19
     318:	31 97       	sbiw	r30, 0x01	; 1
     31a:	31 e2       	ldi	r19, 0x21	; 33
     31c:	30 83       	st	Z, r19
     31e:	31 97       	sbiw	r30, 0x01	; 1
     320:	20 83       	st	Z, r18
     322:	31 97       	sbiw	r30, 0x01	; 1
     324:	23 e2       	ldi	r18, 0x23	; 35
     326:	20 83       	st	Z, r18
     328:	31 97       	sbiw	r30, 0x01	; 1
     32a:	40 83       	st	Z, r20
     32c:	31 97       	sbiw	r30, 0x01	; 1
     32e:	50 83       	st	Z, r21
     330:	31 97       	sbiw	r30, 0x01	; 1
     332:	26 e2       	ldi	r18, 0x26	; 38
     334:	20 83       	st	Z, r18
     336:	31 97       	sbiw	r30, 0x01	; 1
     338:	27 e2       	ldi	r18, 0x27	; 39
     33a:	20 83       	st	Z, r18
     33c:	31 97       	sbiw	r30, 0x01	; 1
     33e:	28 e2       	ldi	r18, 0x28	; 40
     340:	20 83       	st	Z, r18
     342:	31 97       	sbiw	r30, 0x01	; 1
     344:	29 e2       	ldi	r18, 0x29	; 41
     346:	20 83       	st	Z, r18
     348:	31 97       	sbiw	r30, 0x01	; 1
     34a:	20 e3       	ldi	r18, 0x30	; 48
     34c:	20 83       	st	Z, r18
     34e:	31 97       	sbiw	r30, 0x01	; 1
     350:	21 e3       	ldi	r18, 0x31	; 49
     352:	20 83       	st	Z, r18
     354:	86 97       	sbiw	r24, 0x26	; 38
     356:	08 95       	ret

00000358 <xPortStartScheduler>:
     358:	1b bc       	out	0x2b, r1	; 43
     35a:	8e e0       	ldi	r24, 0x0E	; 14
     35c:	8a bd       	out	0x2a, r24	; 42
     35e:	8b e0       	ldi	r24, 0x0B	; 11
     360:	8e bd       	out	0x2e, r24	; 46
     362:	89 b7       	in	r24, 0x39	; 57
     364:	80 61       	ori	r24, 0x10	; 16
     366:	89 bf       	out	0x39, r24	; 57
     368:	a0 91 bb 06 	lds	r26, 0x06BB	; 0x8006bb <pxCurrentTCB>
     36c:	b0 91 bc 06 	lds	r27, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     370:	cd 91       	ld	r28, X+
     372:	cd bf       	out	0x3d, r28	; 61
     374:	dd 91       	ld	r29, X+
     376:	de bf       	out	0x3e, r29	; 62
     378:	ff 91       	pop	r31
     37a:	ef 91       	pop	r30
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
     380:	bf 91       	pop	r27
     382:	af 91       	pop	r26
     384:	9f 91       	pop	r25
     386:	8f 91       	pop	r24
     388:	7f 91       	pop	r23
     38a:	6f 91       	pop	r22
     38c:	5f 91       	pop	r21
     38e:	4f 91       	pop	r20
     390:	3f 91       	pop	r19
     392:	2f 91       	pop	r18
     394:	1f 91       	pop	r17
     396:	0f 91       	pop	r16
     398:	ff 90       	pop	r15
     39a:	ef 90       	pop	r14
     39c:	df 90       	pop	r13
     39e:	cf 90       	pop	r12
     3a0:	bf 90       	pop	r11
     3a2:	af 90       	pop	r10
     3a4:	9f 90       	pop	r9
     3a6:	8f 90       	pop	r8
     3a8:	7f 90       	pop	r7
     3aa:	6f 90       	pop	r6
     3ac:	5f 90       	pop	r5
     3ae:	4f 90       	pop	r4
     3b0:	3f 90       	pop	r3
     3b2:	2f 90       	pop	r2
     3b4:	1f 90       	pop	r1
     3b6:	0f 90       	pop	r0
     3b8:	0f be       	out	0x3f, r0	; 63
     3ba:	0f 90       	pop	r0
     3bc:	08 95       	ret
     3be:	81 e0       	ldi	r24, 0x01	; 1
     3c0:	08 95       	ret

000003c2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     3c2:	0f 92       	push	r0
     3c4:	0f b6       	in	r0, 0x3f	; 63
     3c6:	f8 94       	cli
     3c8:	0f 92       	push	r0
     3ca:	1f 92       	push	r1
     3cc:	11 24       	eor	r1, r1
     3ce:	2f 92       	push	r2
     3d0:	3f 92       	push	r3
     3d2:	4f 92       	push	r4
     3d4:	5f 92       	push	r5
     3d6:	6f 92       	push	r6
     3d8:	7f 92       	push	r7
     3da:	8f 92       	push	r8
     3dc:	9f 92       	push	r9
     3de:	af 92       	push	r10
     3e0:	bf 92       	push	r11
     3e2:	cf 92       	push	r12
     3e4:	df 92       	push	r13
     3e6:	ef 92       	push	r14
     3e8:	ff 92       	push	r15
     3ea:	0f 93       	push	r16
     3ec:	1f 93       	push	r17
     3ee:	2f 93       	push	r18
     3f0:	3f 93       	push	r19
     3f2:	4f 93       	push	r20
     3f4:	5f 93       	push	r21
     3f6:	6f 93       	push	r22
     3f8:	7f 93       	push	r23
     3fa:	8f 93       	push	r24
     3fc:	9f 93       	push	r25
     3fe:	af 93       	push	r26
     400:	bf 93       	push	r27
     402:	cf 93       	push	r28
     404:	df 93       	push	r29
     406:	ef 93       	push	r30
     408:	ff 93       	push	r31
     40a:	a0 91 bb 06 	lds	r26, 0x06BB	; 0x8006bb <pxCurrentTCB>
     40e:	b0 91 bc 06 	lds	r27, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     412:	0d b6       	in	r0, 0x3d	; 61
     414:	0d 92       	st	X+, r0
     416:	0e b6       	in	r0, 0x3e	; 62
     418:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     41a:	0e 94 01 07 	call	0xe02	; 0xe02 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     41e:	a0 91 bb 06 	lds	r26, 0x06BB	; 0x8006bb <pxCurrentTCB>
     422:	b0 91 bc 06 	lds	r27, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     426:	cd 91       	ld	r28, X+
     428:	cd bf       	out	0x3d, r28	; 61
     42a:	dd 91       	ld	r29, X+
     42c:	de bf       	out	0x3e, r29	; 62
     42e:	ff 91       	pop	r31
     430:	ef 91       	pop	r30
     432:	df 91       	pop	r29
     434:	cf 91       	pop	r28
     436:	bf 91       	pop	r27
     438:	af 91       	pop	r26
     43a:	9f 91       	pop	r25
     43c:	8f 91       	pop	r24
     43e:	7f 91       	pop	r23
     440:	6f 91       	pop	r22
     442:	5f 91       	pop	r21
     444:	4f 91       	pop	r20
     446:	3f 91       	pop	r19
     448:	2f 91       	pop	r18
     44a:	1f 91       	pop	r17
     44c:	0f 91       	pop	r16
     44e:	ff 90       	pop	r15
     450:	ef 90       	pop	r14
     452:	df 90       	pop	r13
     454:	cf 90       	pop	r12
     456:	bf 90       	pop	r11
     458:	af 90       	pop	r10
     45a:	9f 90       	pop	r9
     45c:	8f 90       	pop	r8
     45e:	7f 90       	pop	r7
     460:	6f 90       	pop	r6
     462:	5f 90       	pop	r5
     464:	4f 90       	pop	r4
     466:	3f 90       	pop	r3
     468:	2f 90       	pop	r2
     46a:	1f 90       	pop	r1
     46c:	0f 90       	pop	r0
     46e:	0f be       	out	0x3f, r0	; 63
     470:	0f 90       	pop	r0

	asm volatile ( "ret" );
     472:	08 95       	ret

00000474 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     474:	0f 92       	push	r0
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	0f 92       	push	r0
     47c:	1f 92       	push	r1
     47e:	11 24       	eor	r1, r1
     480:	2f 92       	push	r2
     482:	3f 92       	push	r3
     484:	4f 92       	push	r4
     486:	5f 92       	push	r5
     488:	6f 92       	push	r6
     48a:	7f 92       	push	r7
     48c:	8f 92       	push	r8
     48e:	9f 92       	push	r9
     490:	af 92       	push	r10
     492:	bf 92       	push	r11
     494:	cf 92       	push	r12
     496:	df 92       	push	r13
     498:	ef 92       	push	r14
     49a:	ff 92       	push	r15
     49c:	0f 93       	push	r16
     49e:	1f 93       	push	r17
     4a0:	2f 93       	push	r18
     4a2:	3f 93       	push	r19
     4a4:	4f 93       	push	r20
     4a6:	5f 93       	push	r21
     4a8:	6f 93       	push	r22
     4aa:	7f 93       	push	r23
     4ac:	8f 93       	push	r24
     4ae:	9f 93       	push	r25
     4b0:	af 93       	push	r26
     4b2:	bf 93       	push	r27
     4b4:	cf 93       	push	r28
     4b6:	df 93       	push	r29
     4b8:	ef 93       	push	r30
     4ba:	ff 93       	push	r31
     4bc:	a0 91 bb 06 	lds	r26, 0x06BB	; 0x8006bb <pxCurrentTCB>
     4c0:	b0 91 bc 06 	lds	r27, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     4c4:	0d b6       	in	r0, 0x3d	; 61
     4c6:	0d 92       	st	X+, r0
     4c8:	0e b6       	in	r0, 0x3e	; 62
     4ca:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     4cc:	0e 94 b3 05 	call	0xb66	; 0xb66 <xTaskIncrementTick>
     4d0:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     4d2:	0e 94 01 07 	call	0xe02	; 0xe02 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     4d6:	a0 91 bb 06 	lds	r26, 0x06BB	; 0x8006bb <pxCurrentTCB>
     4da:	b0 91 bc 06 	lds	r27, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     4de:	cd 91       	ld	r28, X+
     4e0:	cd bf       	out	0x3d, r28	; 61
     4e2:	dd 91       	ld	r29, X+
     4e4:	de bf       	out	0x3e, r29	; 62
     4e6:	ff 91       	pop	r31
     4e8:	ef 91       	pop	r30
     4ea:	df 91       	pop	r29
     4ec:	cf 91       	pop	r28
     4ee:	bf 91       	pop	r27
     4f0:	af 91       	pop	r26
     4f2:	9f 91       	pop	r25
     4f4:	8f 91       	pop	r24
     4f6:	7f 91       	pop	r23
     4f8:	6f 91       	pop	r22
     4fa:	5f 91       	pop	r21
     4fc:	4f 91       	pop	r20
     4fe:	3f 91       	pop	r19
     500:	2f 91       	pop	r18
     502:	1f 91       	pop	r17
     504:	0f 91       	pop	r16
     506:	ff 90       	pop	r15
     508:	ef 90       	pop	r14
     50a:	df 90       	pop	r13
     50c:	cf 90       	pop	r12
     50e:	bf 90       	pop	r11
     510:	af 90       	pop	r10
     512:	9f 90       	pop	r9
     514:	8f 90       	pop	r8
     516:	7f 90       	pop	r7
     518:	6f 90       	pop	r6
     51a:	5f 90       	pop	r5
     51c:	4f 90       	pop	r4
     51e:	3f 90       	pop	r3
     520:	2f 90       	pop	r2
     522:	1f 90       	pop	r1
     524:	0f 90       	pop	r0
     526:	0f be       	out	0x3f, r0	; 63
     528:	0f 90       	pop	r0

	asm volatile ( "ret" );
     52a:	08 95       	ret

0000052c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     52c:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYieldFromTick>
		asm volatile ( "reti" );
     530:	18 95       	reti

00000532 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     532:	cf 93       	push	r28
     534:	df 93       	push	r29
     536:	dc 01       	movw	r26, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     538:	e0 e8       	ldi	r30, 0x80	; 128
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	01 c0       	rjmp	.+2      	; 0x540 <prvInsertBlockIntoFreeList+0xe>
     53e:	f9 01       	movw	r30, r18
     540:	20 81       	ld	r18, Z
     542:	31 81       	ldd	r19, Z+1	; 0x01
     544:	2a 17       	cp	r18, r26
     546:	3b 07       	cpc	r19, r27
     548:	d0 f3       	brcs	.-12     	; 0x53e <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     54a:	82 81       	ldd	r24, Z+2	; 0x02
     54c:	93 81       	ldd	r25, Z+3	; 0x03
     54e:	af 01       	movw	r20, r30
     550:	48 0f       	add	r20, r24
     552:	59 1f       	adc	r21, r25
     554:	a4 17       	cp	r26, r20
     556:	b5 07       	cpc	r27, r21
     558:	49 f4       	brne	.+18     	; 0x56c <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     55a:	12 96       	adiw	r26, 0x02	; 2
     55c:	4d 91       	ld	r20, X+
     55e:	5c 91       	ld	r21, X
     560:	13 97       	sbiw	r26, 0x03	; 3
     562:	84 0f       	add	r24, r20
     564:	95 1f       	adc	r25, r21
     566:	93 83       	std	Z+3, r25	; 0x03
     568:	82 83       	std	Z+2, r24	; 0x02
     56a:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     56c:	12 96       	adiw	r26, 0x02	; 2
     56e:	8d 91       	ld	r24, X+
     570:	9c 91       	ld	r25, X
     572:	13 97       	sbiw	r26, 0x03	; 3
     574:	ed 01       	movw	r28, r26
     576:	c8 0f       	add	r28, r24
     578:	d9 1f       	adc	r29, r25
     57a:	2c 17       	cp	r18, r28
     57c:	3d 07       	cpc	r19, r29
     57e:	d9 f4       	brne	.+54     	; 0x5b6 <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     580:	20 91 7e 00 	lds	r18, 0x007E	; 0x80007e <pxEnd>
     584:	30 91 7f 00 	lds	r19, 0x007F	; 0x80007f <pxEnd+0x1>
     588:	c2 17       	cp	r28, r18
     58a:	d3 07       	cpc	r29, r19
     58c:	81 f0       	breq	.+32     	; 0x5ae <prvInsertBlockIntoFreeList+0x7c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     58e:	2a 81       	ldd	r18, Y+2	; 0x02
     590:	3b 81       	ldd	r19, Y+3	; 0x03
     592:	82 0f       	add	r24, r18
     594:	93 1f       	adc	r25, r19
     596:	13 96       	adiw	r26, 0x03	; 3
     598:	9c 93       	st	X, r25
     59a:	8e 93       	st	-X, r24
     59c:	12 97       	sbiw	r26, 0x02	; 2
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     59e:	c0 81       	ld	r28, Z
     5a0:	d1 81       	ldd	r29, Z+1	; 0x01
     5a2:	88 81       	ld	r24, Y
     5a4:	99 81       	ldd	r25, Y+1	; 0x01
     5a6:	11 96       	adiw	r26, 0x01	; 1
     5a8:	9c 93       	st	X, r25
     5aa:	8e 93       	st	-X, r24
     5ac:	07 c0       	rjmp	.+14     	; 0x5bc <prvInsertBlockIntoFreeList+0x8a>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     5ae:	11 96       	adiw	r26, 0x01	; 1
     5b0:	dc 93       	st	X, r29
     5b2:	ce 93       	st	-X, r28
     5b4:	03 c0       	rjmp	.+6      	; 0x5bc <prvInsertBlockIntoFreeList+0x8a>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     5b6:	11 96       	adiw	r26, 0x01	; 1
     5b8:	3c 93       	st	X, r19
     5ba:	2e 93       	st	-X, r18

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     5bc:	ae 17       	cp	r26, r30
     5be:	bf 07       	cpc	r27, r31
     5c0:	11 f0       	breq	.+4      	; 0x5c6 <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     5c2:	b1 83       	std	Z+1, r27	; 0x01
     5c4:	a0 83       	st	Z, r26
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     5c6:	df 91       	pop	r29
     5c8:	cf 91       	pop	r28
     5ca:	08 95       	ret

000005cc <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5cc:	cf 92       	push	r12
     5ce:	df 92       	push	r13
     5d0:	ef 92       	push	r14
     5d2:	ff 92       	push	r15
     5d4:	0f 93       	push	r16
     5d6:	1f 93       	push	r17
     5d8:	cf 93       	push	r28
     5da:	df 93       	push	r29
     5dc:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     5de:	0e 94 a3 05 	call	0xb46	; 0xb46 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     5e2:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <pxEnd>
     5e6:	90 91 7f 00 	lds	r25, 0x007F	; 0x80007f <pxEnd+0x1>
     5ea:	89 2b       	or	r24, r25
     5ec:	41 f5       	brne	.+80     	; 0x63e <pvPortMalloc+0x72>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     5ee:	e0 e8       	ldi	r30, 0x80	; 128
     5f0:	f0 e0       	ldi	r31, 0x00	; 0
     5f2:	a4 e8       	ldi	r26, 0x84	; 132
     5f4:	b0 e0       	ldi	r27, 0x00	; 0
     5f6:	b1 83       	std	Z+1, r27	; 0x01
     5f8:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     5fa:	13 82       	std	Z+3, r1	; 0x03
     5fc:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     5fe:	ec e5       	ldi	r30, 0x5C	; 92
     600:	f6 e0       	ldi	r31, 0x06	; 6
     602:	f0 93 7f 00 	sts	0x007F, r31	; 0x80007f <pxEnd+0x1>
     606:	e0 93 7e 00 	sts	0x007E, r30	; 0x80007e <pxEnd>
	pxEnd->xBlockSize = 0;
     60a:	13 82       	std	Z+3, r1	; 0x03
     60c:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     60e:	11 82       	std	Z+1, r1	; 0x01
     610:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     612:	88 ed       	ldi	r24, 0xD8	; 216
     614:	95 e0       	ldi	r25, 0x05	; 5
     616:	13 96       	adiw	r26, 0x03	; 3
     618:	9c 93       	st	X, r25
     61a:	8e 93       	st	-X, r24
     61c:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     61e:	ed 93       	st	X+, r30
     620:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     622:	90 93 7b 00 	sts	0x007B, r25	; 0x80007b <xMinimumEverFreeBytesRemaining+0x1>
     626:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     62a:	90 93 7d 00 	sts	0x007D, r25	; 0x80007d <xFreeBytesRemaining+0x1>
     62e:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     632:	80 e0       	ldi	r24, 0x00	; 0
     634:	90 e8       	ldi	r25, 0x80	; 128
     636:	90 93 79 00 	sts	0x0079, r25	; 0x800079 <__data_end+0x1>
     63a:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <__data_end>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     63e:	e0 90 78 00 	lds	r14, 0x0078	; 0x800078 <__data_end>
     642:	f0 90 79 00 	lds	r15, 0x0079	; 0x800079 <__data_end+0x1>
     646:	c7 01       	movw	r24, r14
     648:	8c 23       	and	r24, r28
     64a:	9d 23       	and	r25, r29
     64c:	89 2b       	or	r24, r25
     64e:	09 f0       	breq	.+2      	; 0x652 <pvPortMalloc+0x86>
     650:	5f c0       	rjmp	.+190    	; 0x710 <pvPortMalloc+0x144>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     652:	20 97       	sbiw	r28, 0x00	; 0
     654:	09 f4       	brne	.+2      	; 0x658 <pvPortMalloc+0x8c>
     656:	5f c0       	rjmp	.+190    	; 0x716 <pvPortMalloc+0x14a>
			{
				xWantedSize += xHeapStructSize;
     658:	ae 01       	movw	r20, r28
     65a:	4c 5f       	subi	r20, 0xFC	; 252
     65c:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     65e:	09 f4       	brne	.+2      	; 0x662 <pvPortMalloc+0x96>
     660:	5d c0       	rjmp	.+186    	; 0x71c <pvPortMalloc+0x150>
     662:	00 91 7c 00 	lds	r16, 0x007C	; 0x80007c <xFreeBytesRemaining>
     666:	10 91 7d 00 	lds	r17, 0x007D	; 0x80007d <xFreeBytesRemaining+0x1>
     66a:	04 17       	cp	r16, r20
     66c:	15 07       	cpc	r17, r21
     66e:	08 f4       	brcc	.+2      	; 0x672 <pvPortMalloc+0xa6>
     670:	58 c0       	rjmp	.+176    	; 0x722 <pvPortMalloc+0x156>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     672:	c0 91 80 00 	lds	r28, 0x0080	; 0x800080 <xStart>
     676:	d0 91 81 00 	lds	r29, 0x0081	; 0x800081 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     67a:	e0 e8       	ldi	r30, 0x80	; 128
     67c:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     67e:	02 c0       	rjmp	.+4      	; 0x684 <pvPortMalloc+0xb8>
     680:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
     682:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     684:	2a 81       	ldd	r18, Y+2	; 0x02
     686:	3b 81       	ldd	r19, Y+3	; 0x03
     688:	24 17       	cp	r18, r20
     68a:	35 07       	cpc	r19, r21
     68c:	28 f4       	brcc	.+10     	; 0x698 <pvPortMalloc+0xcc>
     68e:	28 81       	ld	r18, Y
     690:	39 81       	ldd	r19, Y+1	; 0x01
     692:	21 15       	cp	r18, r1
     694:	31 05       	cpc	r19, r1
     696:	a1 f7       	brne	.-24     	; 0x680 <pvPortMalloc+0xb4>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     698:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <pxEnd>
     69c:	90 91 7f 00 	lds	r25, 0x007F	; 0x80007f <pxEnd+0x1>
     6a0:	c8 17       	cp	r28, r24
     6a2:	d9 07       	cpc	r29, r25
     6a4:	09 f4       	brne	.+2      	; 0x6a8 <pvPortMalloc+0xdc>
     6a6:	40 c0       	rjmp	.+128    	; 0x728 <pvPortMalloc+0x15c>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     6a8:	c0 80       	ld	r12, Z
     6aa:	d1 80       	ldd	r13, Z+1	; 0x01
     6ac:	84 e0       	ldi	r24, 0x04	; 4
     6ae:	c8 0e       	add	r12, r24
     6b0:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     6b2:	88 81       	ld	r24, Y
     6b4:	99 81       	ldd	r25, Y+1	; 0x01
     6b6:	91 83       	std	Z+1, r25	; 0x01
     6b8:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     6ba:	2a 81       	ldd	r18, Y+2	; 0x02
     6bc:	3b 81       	ldd	r19, Y+3	; 0x03
     6be:	24 1b       	sub	r18, r20
     6c0:	35 0b       	sbc	r19, r21
     6c2:	29 30       	cpi	r18, 0x09	; 9
     6c4:	31 05       	cpc	r19, r1
     6c6:	50 f0       	brcs	.+20     	; 0x6dc <pvPortMalloc+0x110>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     6c8:	ce 01       	movw	r24, r28
     6ca:	84 0f       	add	r24, r20
     6cc:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     6ce:	fc 01       	movw	r30, r24
     6d0:	33 83       	std	Z+3, r19	; 0x03
     6d2:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     6d4:	5b 83       	std	Y+3, r21	; 0x03
     6d6:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     6d8:	0e 94 99 02 	call	0x532	; 0x532 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     6dc:	8a 81       	ldd	r24, Y+2	; 0x02
     6de:	9b 81       	ldd	r25, Y+3	; 0x03
     6e0:	08 1b       	sub	r16, r24
     6e2:	19 0b       	sbc	r17, r25
     6e4:	10 93 7d 00 	sts	0x007D, r17	; 0x80007d <xFreeBytesRemaining+0x1>
     6e8:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     6ec:	20 91 7a 00 	lds	r18, 0x007A	; 0x80007a <xMinimumEverFreeBytesRemaining>
     6f0:	30 91 7b 00 	lds	r19, 0x007B	; 0x80007b <xMinimumEverFreeBytesRemaining+0x1>
     6f4:	02 17       	cp	r16, r18
     6f6:	13 07       	cpc	r17, r19
     6f8:	20 f4       	brcc	.+8      	; 0x702 <pvPortMalloc+0x136>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     6fa:	10 93 7b 00 	sts	0x007B, r17	; 0x80007b <xMinimumEverFreeBytesRemaining+0x1>
     6fe:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     702:	e8 2a       	or	r14, r24
     704:	f9 2a       	or	r15, r25
     706:	fb 82       	std	Y+3, r15	; 0x03
     708:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     70a:	19 82       	std	Y+1, r1	; 0x01
     70c:	18 82       	st	Y, r1
     70e:	0e c0       	rjmp	.+28     	; 0x72c <pvPortMalloc+0x160>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     710:	c1 2c       	mov	r12, r1
     712:	d1 2c       	mov	r13, r1
     714:	0b c0       	rjmp	.+22     	; 0x72c <pvPortMalloc+0x160>
     716:	c1 2c       	mov	r12, r1
     718:	d1 2c       	mov	r13, r1
     71a:	08 c0       	rjmp	.+16     	; 0x72c <pvPortMalloc+0x160>
     71c:	c1 2c       	mov	r12, r1
     71e:	d1 2c       	mov	r13, r1
     720:	05 c0       	rjmp	.+10     	; 0x72c <pvPortMalloc+0x160>
     722:	c1 2c       	mov	r12, r1
     724:	d1 2c       	mov	r13, r1
     726:	02 c0       	rjmp	.+4      	; 0x72c <pvPortMalloc+0x160>
     728:	c1 2c       	mov	r12, r1
     72a:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     72c:	0e 94 6e 06 	call	0xcdc	; 0xcdc <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     730:	c6 01       	movw	r24, r12
     732:	df 91       	pop	r29
     734:	cf 91       	pop	r28
     736:	1f 91       	pop	r17
     738:	0f 91       	pop	r16
     73a:	ff 90       	pop	r15
     73c:	ef 90       	pop	r14
     73e:	df 90       	pop	r13
     740:	cf 90       	pop	r12
     742:	08 95       	ret

00000744 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     748:	00 97       	sbiw	r24, 0x00	; 0
     74a:	59 f1       	breq	.+86     	; 0x7a2 <vPortFree+0x5e>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     74c:	fc 01       	movw	r30, r24
     74e:	34 97       	sbiw	r30, 0x04	; 4
     750:	22 81       	ldd	r18, Z+2	; 0x02
     752:	33 81       	ldd	r19, Z+3	; 0x03
     754:	40 91 78 00 	lds	r20, 0x0078	; 0x800078 <__data_end>
     758:	50 91 79 00 	lds	r21, 0x0079	; 0x800079 <__data_end+0x1>
     75c:	b9 01       	movw	r22, r18
     75e:	64 23       	and	r22, r20
     760:	75 23       	and	r23, r21
     762:	67 2b       	or	r22, r23
     764:	f1 f0       	breq	.+60     	; 0x7a2 <vPortFree+0x5e>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     766:	60 81       	ld	r22, Z
     768:	71 81       	ldd	r23, Z+1	; 0x01
     76a:	67 2b       	or	r22, r23
     76c:	d1 f4       	brne	.+52     	; 0x7a2 <vPortFree+0x5e>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     76e:	ef 01       	movw	r28, r30
     770:	40 95       	com	r20
     772:	50 95       	com	r21
     774:	24 23       	and	r18, r20
     776:	35 23       	and	r19, r21
     778:	33 83       	std	Z+3, r19	; 0x03
     77a:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
     77c:	0e 94 a3 05 	call	0xb46	; 0xb46 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     780:	20 91 7c 00 	lds	r18, 0x007C	; 0x80007c <xFreeBytesRemaining>
     784:	30 91 7d 00 	lds	r19, 0x007D	; 0x80007d <xFreeBytesRemaining+0x1>
     788:	8a 81       	ldd	r24, Y+2	; 0x02
     78a:	9b 81       	ldd	r25, Y+3	; 0x03
     78c:	82 0f       	add	r24, r18
     78e:	93 1f       	adc	r25, r19
     790:	90 93 7d 00 	sts	0x007D, r25	; 0x80007d <xFreeBytesRemaining+0x1>
     794:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     798:	ce 01       	movw	r24, r28
     79a:	0e 94 99 02 	call	0x532	; 0x532 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     79e:	0e 94 6e 06 	call	0xcdc	; 0xcdc <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	08 95       	ret

000007a8 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     7a8:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxDelayedTaskList>
     7ac:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxDelayedTaskList+0x1>
     7b0:	80 81       	ld	r24, Z
     7b2:	81 11       	cpse	r24, r1
     7b4:	07 c0       	rjmp	.+14     	; 0x7c4 <prvResetNextTaskUnblockTime+0x1c>
     7b6:	8f ef       	ldi	r24, 0xFF	; 255
     7b8:	9f ef       	ldi	r25, 0xFF	; 255
     7ba:	90 93 64 06 	sts	0x0664, r25	; 0x800664 <xNextTaskUnblockTime+0x1>
     7be:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <xNextTaskUnblockTime>
     7c2:	08 95       	ret
     7c4:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxDelayedTaskList>
     7c8:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxDelayedTaskList+0x1>
     7cc:	05 80       	ldd	r0, Z+5	; 0x05
     7ce:	f6 81       	ldd	r31, Z+6	; 0x06
     7d0:	e0 2d       	mov	r30, r0
     7d2:	06 80       	ldd	r0, Z+6	; 0x06
     7d4:	f7 81       	ldd	r31, Z+7	; 0x07
     7d6:	e0 2d       	mov	r30, r0
     7d8:	82 81       	ldd	r24, Z+2	; 0x02
     7da:	93 81       	ldd	r25, Z+3	; 0x03
     7dc:	90 93 64 06 	sts	0x0664, r25	; 0x800664 <xNextTaskUnblockTime+0x1>
     7e0:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <xNextTaskUnblockTime>
     7e4:	08 95       	ret

000007e6 <prvAddCurrentTaskToDelayedList>:
     7e6:	0f 93       	push	r16
     7e8:	1f 93       	push	r17
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	ec 01       	movw	r28, r24
     7f0:	00 91 6b 06 	lds	r16, 0x066B	; 0x80066b <xTickCount>
     7f4:	10 91 6c 06 	lds	r17, 0x066C	; 0x80066c <xTickCount+0x1>
     7f8:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <pxCurrentTCB>
     7fc:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     800:	02 96       	adiw	r24, 0x02	; 2
     802:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     806:	c0 0f       	add	r28, r16
     808:	d1 1f       	adc	r29, r17
     80a:	e0 91 bb 06 	lds	r30, 0x06BB	; 0x8006bb <pxCurrentTCB>
     80e:	f0 91 bc 06 	lds	r31, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     812:	d3 83       	std	Z+3, r29	; 0x03
     814:	c2 83       	std	Z+2, r28	; 0x02
     816:	c0 17       	cp	r28, r16
     818:	d1 07       	cpc	r29, r17
     81a:	68 f4       	brcc	.+26     	; 0x836 <prvAddCurrentTaskToDelayedList+0x50>
     81c:	60 91 bb 06 	lds	r22, 0x06BB	; 0x8006bb <pxCurrentTCB>
     820:	70 91 bc 06 	lds	r23, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     824:	80 91 81 06 	lds	r24, 0x0681	; 0x800681 <pxOverflowDelayedTaskList>
     828:	90 91 82 06 	lds	r25, 0x0682	; 0x800682 <pxOverflowDelayedTaskList+0x1>
     82c:	6e 5f       	subi	r22, 0xFE	; 254
     82e:	7f 4f       	sbci	r23, 0xFF	; 255
     830:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
     834:	17 c0       	rjmp	.+46     	; 0x864 <__stack+0x5>
     836:	60 91 bb 06 	lds	r22, 0x06BB	; 0x8006bb <pxCurrentTCB>
     83a:	70 91 bc 06 	lds	r23, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     83e:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <pxDelayedTaskList>
     842:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <pxDelayedTaskList+0x1>
     846:	6e 5f       	subi	r22, 0xFE	; 254
     848:	7f 4f       	sbci	r23, 0xFF	; 255
     84a:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInsert>
     84e:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <xNextTaskUnblockTime>
     852:	90 91 64 06 	lds	r25, 0x0664	; 0x800664 <xNextTaskUnblockTime+0x1>
     856:	c8 17       	cp	r28, r24
     858:	d9 07       	cpc	r29, r25
     85a:	20 f4       	brcc	.+8      	; 0x864 <__stack+0x5>
     85c:	d0 93 64 06 	sts	0x0664, r29	; 0x800664 <xNextTaskUnblockTime+0x1>
     860:	c0 93 63 06 	sts	0x0663, r28	; 0x800663 <xNextTaskUnblockTime>
     864:	df 91       	pop	r29
     866:	cf 91       	pop	r28
     868:	1f 91       	pop	r17
     86a:	0f 91       	pop	r16
     86c:	08 95       	ret

0000086e <prvIdleTask>:
     86e:	0f e6       	ldi	r16, 0x6F	; 111
     870:	16 e0       	ldi	r17, 0x06	; 6
     872:	0f 2e       	mov	r0, r31
     874:	f7 e9       	ldi	r31, 0x97	; 151
     876:	ef 2e       	mov	r14, r31
     878:	f6 e0       	ldi	r31, 0x06	; 6
     87a:	ff 2e       	mov	r15, r31
     87c:	f0 2d       	mov	r31, r0
     87e:	80 91 6e 06 	lds	r24, 0x066E	; 0x80066e <uxDeletedTasksWaitingCleanUp>
     882:	88 23       	and	r24, r24
     884:	29 f1       	breq	.+74     	; 0x8d0 <prvIdleTask+0x62>
     886:	0f b6       	in	r0, 0x3f	; 63
     888:	f8 94       	cli
     88a:	0f 92       	push	r0
     88c:	d8 01       	movw	r26, r16
     88e:	15 96       	adiw	r26, 0x05	; 5
     890:	ed 91       	ld	r30, X+
     892:	fc 91       	ld	r31, X
     894:	16 97       	sbiw	r26, 0x06	; 6
     896:	c6 81       	ldd	r28, Z+6	; 0x06
     898:	d7 81       	ldd	r29, Z+7	; 0x07
     89a:	ce 01       	movw	r24, r28
     89c:	02 96       	adiw	r24, 0x02	; 2
     89e:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     8a2:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <uxCurrentNumberOfTasks>
     8a6:	81 50       	subi	r24, 0x01	; 1
     8a8:	80 93 6d 06 	sts	0x066D, r24	; 0x80066d <uxCurrentNumberOfTasks>
     8ac:	80 91 6e 06 	lds	r24, 0x066E	; 0x80066e <uxDeletedTasksWaitingCleanUp>
     8b0:	81 50       	subi	r24, 0x01	; 1
     8b2:	80 93 6e 06 	sts	0x066E, r24	; 0x80066e <uxDeletedTasksWaitingCleanUp>
     8b6:	0f 90       	pop	r0
     8b8:	0f be       	out	0x3f, r0	; 63
     8ba:	8f 89       	ldd	r24, Y+23	; 0x17
     8bc:	98 8d       	ldd	r25, Y+24	; 0x18
     8be:	0e 94 a2 03 	call	0x744	; 0x744 <vPortFree>
     8c2:	ce 01       	movw	r24, r28
     8c4:	0e 94 a2 03 	call	0x744	; 0x744 <vPortFree>
     8c8:	80 91 6e 06 	lds	r24, 0x066E	; 0x80066e <uxDeletedTasksWaitingCleanUp>
     8cc:	81 11       	cpse	r24, r1
     8ce:	db cf       	rjmp	.-74     	; 0x886 <prvIdleTask+0x18>
     8d0:	f7 01       	movw	r30, r14
     8d2:	80 81       	ld	r24, Z
     8d4:	82 30       	cpi	r24, 0x02	; 2
     8d6:	10 f0       	brcs	.+4      	; 0x8dc <prvIdleTask+0x6e>
     8d8:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <vPortYield>
     8dc:	0e 94 f7 07 	call	0xfee	; 0xfee <vApplicationIdleHook>
     8e0:	ce cf       	rjmp	.-100    	; 0x87e <prvIdleTask+0x10>

000008e2 <xTaskCreate>:
     8e2:	4f 92       	push	r4
     8e4:	5f 92       	push	r5
     8e6:	6f 92       	push	r6
     8e8:	7f 92       	push	r7
     8ea:	8f 92       	push	r8
     8ec:	9f 92       	push	r9
     8ee:	af 92       	push	r10
     8f0:	bf 92       	push	r11
     8f2:	cf 92       	push	r12
     8f4:	df 92       	push	r13
     8f6:	ef 92       	push	r14
     8f8:	ff 92       	push	r15
     8fa:	0f 93       	push	r16
     8fc:	cf 93       	push	r28
     8fe:	df 93       	push	r29
     900:	4c 01       	movw	r8, r24
     902:	6b 01       	movw	r12, r22
     904:	5a 01       	movw	r10, r20
     906:	29 01       	movw	r4, r18
     908:	ca 01       	movw	r24, r20
     90a:	0e 94 e6 02 	call	0x5cc	; 0x5cc <pvPortMalloc>
     90e:	3c 01       	movw	r6, r24
     910:	89 2b       	or	r24, r25
     912:	09 f4       	brne	.+2      	; 0x916 <xTaskCreate+0x34>
     914:	dd c0       	rjmp	.+442    	; 0xad0 <xTaskCreate+0x1ee>
     916:	86 e2       	ldi	r24, 0x26	; 38
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	0e 94 e6 02 	call	0x5cc	; 0x5cc <pvPortMalloc>
     91e:	ec 01       	movw	r28, r24
     920:	89 2b       	or	r24, r25
     922:	71 f0       	breq	.+28     	; 0x940 <xTaskCreate+0x5e>
     924:	78 8e       	std	Y+24, r7	; 0x18
     926:	6f 8a       	std	Y+23, r6	; 0x17
     928:	81 e0       	ldi	r24, 0x01	; 1
     92a:	a8 1a       	sub	r10, r24
     92c:	b1 08       	sbc	r11, r1
     92e:	a6 0c       	add	r10, r6
     930:	b7 1c       	adc	r11, r7
     932:	d6 01       	movw	r26, r12
     934:	8c 91       	ld	r24, X
     936:	89 8f       	std	Y+25, r24	; 0x19
     938:	8c 91       	ld	r24, X
     93a:	81 11       	cpse	r24, r1
     93c:	05 c0       	rjmp	.+10     	; 0x948 <xTaskCreate+0x66>
     93e:	18 c0       	rjmp	.+48     	; 0x970 <xTaskCreate+0x8e>
     940:	c3 01       	movw	r24, r6
     942:	0e 94 a2 03 	call	0x744	; 0x744 <vPortFree>
     946:	c4 c0       	rjmp	.+392    	; 0xad0 <xTaskCreate+0x1ee>
     948:	ae 01       	movw	r20, r28
     94a:	46 5e       	subi	r20, 0xE6	; 230
     94c:	5f 4f       	sbci	r21, 0xFF	; 255
     94e:	f6 01       	movw	r30, r12
     950:	31 96       	adiw	r30, 0x01	; 1
     952:	b8 e0       	ldi	r27, 0x08	; 8
     954:	cb 0e       	add	r12, r27
     956:	d1 1c       	adc	r13, r1
     958:	cf 01       	movw	r24, r30
     95a:	21 91       	ld	r18, Z+
     95c:	da 01       	movw	r26, r20
     95e:	2d 93       	st	X+, r18
     960:	ad 01       	movw	r20, r26
     962:	dc 01       	movw	r26, r24
     964:	8c 91       	ld	r24, X
     966:	88 23       	and	r24, r24
     968:	19 f0       	breq	.+6      	; 0x970 <xTaskCreate+0x8e>
     96a:	ec 15       	cp	r30, r12
     96c:	fd 05       	cpc	r31, r13
     96e:	a1 f7       	brne	.-24     	; 0x958 <xTaskCreate+0x76>
     970:	18 a2       	std	Y+32, r1	; 0x20
     972:	04 30       	cpi	r16, 0x04	; 4
     974:	08 f0       	brcs	.+2      	; 0x978 <xTaskCreate+0x96>
     976:	03 e0       	ldi	r16, 0x03	; 3
     978:	0e 8b       	std	Y+22, r16	; 0x16
     97a:	6e 01       	movw	r12, r28
     97c:	b2 e0       	ldi	r27, 0x02	; 2
     97e:	cb 0e       	add	r12, r27
     980:	d1 1c       	adc	r13, r1
     982:	c6 01       	movw	r24, r12
     984:	0e 94 c3 00 	call	0x186	; 0x186 <vListInitialiseItem>
     988:	ce 01       	movw	r24, r28
     98a:	0c 96       	adiw	r24, 0x0c	; 12
     98c:	0e 94 c3 00 	call	0x186	; 0x186 <vListInitialiseItem>
     990:	d9 87       	std	Y+9, r29	; 0x09
     992:	c8 87       	std	Y+8, r28	; 0x08
     994:	84 e0       	ldi	r24, 0x04	; 4
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	80 1b       	sub	r24, r16
     99a:	91 09       	sbc	r25, r1
     99c:	9d 87       	std	Y+13, r25	; 0x0d
     99e:	8c 87       	std	Y+12, r24	; 0x0c
     9a0:	db 8b       	std	Y+19, r29	; 0x13
     9a2:	ca 8b       	std	Y+18, r28	; 0x12
     9a4:	19 a2       	std	Y+33, r1	; 0x21
     9a6:	1a a2       	std	Y+34, r1	; 0x22
     9a8:	1b a2       	std	Y+35, r1	; 0x23
     9aa:	1c a2       	std	Y+36, r1	; 0x24
     9ac:	1d a2       	std	Y+37, r1	; 0x25
     9ae:	a2 01       	movw	r20, r4
     9b0:	b4 01       	movw	r22, r8
     9b2:	c5 01       	movw	r24, r10
     9b4:	0e 94 40 01 	call	0x280	; 0x280 <pxPortInitialiseStack>
     9b8:	99 83       	std	Y+1, r25	; 0x01
     9ba:	88 83       	st	Y, r24
     9bc:	e1 14       	cp	r14, r1
     9be:	f1 04       	cpc	r15, r1
     9c0:	19 f0       	breq	.+6      	; 0x9c8 <xTaskCreate+0xe6>
     9c2:	f7 01       	movw	r30, r14
     9c4:	d1 83       	std	Z+1, r29	; 0x01
     9c6:	c0 83       	st	Z, r28
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	0f 92       	push	r0
     9ce:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <uxCurrentNumberOfTasks>
     9d2:	8f 5f       	subi	r24, 0xFF	; 255
     9d4:	80 93 6d 06 	sts	0x066D, r24	; 0x80066d <uxCurrentNumberOfTasks>
     9d8:	80 91 bb 06 	lds	r24, 0x06BB	; 0x8006bb <pxCurrentTCB>
     9dc:	90 91 bc 06 	lds	r25, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     9e0:	89 2b       	or	r24, r25
     9e2:	a9 f5       	brne	.+106    	; 0xa4e <xTaskCreate+0x16c>
     9e4:	d0 93 bc 06 	sts	0x06BC, r29	; 0x8006bc <pxCurrentTCB+0x1>
     9e8:	c0 93 bb 06 	sts	0x06BB, r28	; 0x8006bb <pxCurrentTCB>
     9ec:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <uxCurrentNumberOfTasks>
     9f0:	81 30       	cpi	r24, 0x01	; 1
     9f2:	e9 f5       	brne	.+122    	; 0xa6e <xTaskCreate+0x18c>
     9f4:	87 e9       	ldi	r24, 0x97	; 151
     9f6:	96 e0       	ldi	r25, 0x06	; 6
     9f8:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     9fc:	80 ea       	ldi	r24, 0xA0	; 160
     9fe:	96 e0       	ldi	r25, 0x06	; 6
     a00:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     a04:	89 ea       	ldi	r24, 0xA9	; 169
     a06:	96 e0       	ldi	r25, 0x06	; 6
     a08:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     a0c:	82 eb       	ldi	r24, 0xB2	; 178
     a0e:	96 e0       	ldi	r25, 0x06	; 6
     a10:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     a14:	8e e8       	ldi	r24, 0x8E	; 142
     a16:	96 e0       	ldi	r25, 0x06	; 6
     a18:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     a1c:	85 e8       	ldi	r24, 0x85	; 133
     a1e:	96 e0       	ldi	r25, 0x06	; 6
     a20:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     a24:	88 e7       	ldi	r24, 0x78	; 120
     a26:	96 e0       	ldi	r25, 0x06	; 6
     a28:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     a2c:	8f e6       	ldi	r24, 0x6F	; 111
     a2e:	96 e0       	ldi	r25, 0x06	; 6
     a30:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInitialise>
     a34:	8e e8       	ldi	r24, 0x8E	; 142
     a36:	96 e0       	ldi	r25, 0x06	; 6
     a38:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <pxDelayedTaskList+0x1>
     a3c:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <pxDelayedTaskList>
     a40:	85 e8       	ldi	r24, 0x85	; 133
     a42:	96 e0       	ldi	r25, 0x06	; 6
     a44:	90 93 82 06 	sts	0x0682, r25	; 0x800682 <pxOverflowDelayedTaskList+0x1>
     a48:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <pxOverflowDelayedTaskList>
     a4c:	10 c0       	rjmp	.+32     	; 0xa6e <xTaskCreate+0x18c>
     a4e:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xSchedulerRunning>
     a52:	81 11       	cpse	r24, r1
     a54:	0c c0       	rjmp	.+24     	; 0xa6e <xTaskCreate+0x18c>
     a56:	e0 91 bb 06 	lds	r30, 0x06BB	; 0x8006bb <pxCurrentTCB>
     a5a:	f0 91 bc 06 	lds	r31, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     a5e:	96 89       	ldd	r25, Z+22	; 0x16
     a60:	8e 89       	ldd	r24, Y+22	; 0x16
     a62:	89 17       	cp	r24, r25
     a64:	20 f0       	brcs	.+8      	; 0xa6e <xTaskCreate+0x18c>
     a66:	d0 93 bc 06 	sts	0x06BC, r29	; 0x8006bc <pxCurrentTCB+0x1>
     a6a:	c0 93 bb 06 	sts	0x06BB, r28	; 0x8006bb <pxCurrentTCB>
     a6e:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <uxTaskNumber>
     a72:	8f 5f       	subi	r24, 0xFF	; 255
     a74:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <uxTaskNumber>
     a78:	8e 89       	ldd	r24, Y+22	; 0x16
     a7a:	90 91 6a 06 	lds	r25, 0x066A	; 0x80066a <uxTopReadyPriority>
     a7e:	98 17       	cp	r25, r24
     a80:	10 f4       	brcc	.+4      	; 0xa86 <xTaskCreate+0x1a4>
     a82:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <uxTopReadyPriority>
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	9c 01       	movw	r18, r24
     a8a:	22 0f       	add	r18, r18
     a8c:	33 1f       	adc	r19, r19
     a8e:	22 0f       	add	r18, r18
     a90:	33 1f       	adc	r19, r19
     a92:	22 0f       	add	r18, r18
     a94:	33 1f       	adc	r19, r19
     a96:	82 0f       	add	r24, r18
     a98:	93 1f       	adc	r25, r19
     a9a:	b6 01       	movw	r22, r12
     a9c:	89 56       	subi	r24, 0x69	; 105
     a9e:	99 4f       	sbci	r25, 0xF9	; 249
     aa0:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
     aa4:	0f 90       	pop	r0
     aa6:	0f be       	out	0x3f, r0	; 63
     aa8:	80 91 69 06 	lds	r24, 0x0669	; 0x800669 <xSchedulerRunning>
     aac:	88 23       	and	r24, r24
     aae:	61 f0       	breq	.+24     	; 0xac8 <xTaskCreate+0x1e6>
     ab0:	e0 91 bb 06 	lds	r30, 0x06BB	; 0x8006bb <pxCurrentTCB>
     ab4:	f0 91 bc 06 	lds	r31, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     ab8:	96 89       	ldd	r25, Z+22	; 0x16
     aba:	8e 89       	ldd	r24, Y+22	; 0x16
     abc:	98 17       	cp	r25, r24
     abe:	30 f4       	brcc	.+12     	; 0xacc <xTaskCreate+0x1ea>
     ac0:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <vPortYield>
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	05 c0       	rjmp	.+10     	; 0xad2 <xTaskCreate+0x1f0>
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	03 c0       	rjmp	.+6      	; 0xad2 <xTaskCreate+0x1f0>
     acc:	81 e0       	ldi	r24, 0x01	; 1
     ace:	01 c0       	rjmp	.+2      	; 0xad2 <xTaskCreate+0x1f0>
     ad0:	8f ef       	ldi	r24, 0xFF	; 255
     ad2:	df 91       	pop	r29
     ad4:	cf 91       	pop	r28
     ad6:	0f 91       	pop	r16
     ad8:	ff 90       	pop	r15
     ada:	ef 90       	pop	r14
     adc:	df 90       	pop	r13
     ade:	cf 90       	pop	r12
     ae0:	bf 90       	pop	r11
     ae2:	af 90       	pop	r10
     ae4:	9f 90       	pop	r9
     ae6:	8f 90       	pop	r8
     ae8:	7f 90       	pop	r7
     aea:	6f 90       	pop	r6
     aec:	5f 90       	pop	r5
     aee:	4f 90       	pop	r4
     af0:	08 95       	ret

00000af2 <vTaskStartScheduler>:
     af2:	ef 92       	push	r14
     af4:	ff 92       	push	r15
     af6:	0f 93       	push	r16
     af8:	0f 2e       	mov	r0, r31
     afa:	f1 e6       	ldi	r31, 0x61	; 97
     afc:	ef 2e       	mov	r14, r31
     afe:	f6 e0       	ldi	r31, 0x06	; 6
     b00:	ff 2e       	mov	r15, r31
     b02:	f0 2d       	mov	r31, r0
     b04:	00 e0       	ldi	r16, 0x00	; 0
     b06:	20 e0       	ldi	r18, 0x00	; 0
     b08:	30 e0       	ldi	r19, 0x00	; 0
     b0a:	45 e5       	ldi	r20, 0x55	; 85
     b0c:	50 e0       	ldi	r21, 0x00	; 0
     b0e:	61 e6       	ldi	r22, 0x61	; 97
     b10:	70 e0       	ldi	r23, 0x00	; 0
     b12:	87 e3       	ldi	r24, 0x37	; 55
     b14:	94 e0       	ldi	r25, 0x04	; 4
     b16:	0e 94 71 04 	call	0x8e2	; 0x8e2 <xTaskCreate>
     b1a:	81 30       	cpi	r24, 0x01	; 1
     b1c:	81 f4       	brne	.+32     	; 0xb3e <vTaskStartScheduler+0x4c>
     b1e:	f8 94       	cli
     b20:	8f ef       	ldi	r24, 0xFF	; 255
     b22:	9f ef       	ldi	r25, 0xFF	; 255
     b24:	90 93 64 06 	sts	0x0664, r25	; 0x800664 <xNextTaskUnblockTime+0x1>
     b28:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <xNextTaskUnblockTime>
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <xSchedulerRunning>
     b32:	10 92 6c 06 	sts	0x066C, r1	; 0x80066c <xTickCount+0x1>
     b36:	10 92 6b 06 	sts	0x066B, r1	; 0x80066b <xTickCount>
     b3a:	0e 94 ac 01 	call	0x358	; 0x358 <xPortStartScheduler>
     b3e:	0f 91       	pop	r16
     b40:	ff 90       	pop	r15
     b42:	ef 90       	pop	r14
     b44:	08 95       	ret

00000b46 <vTaskSuspendAll>:
     b46:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <uxSchedulerSuspended>
     b4a:	8f 5f       	subi	r24, 0xFF	; 255
     b4c:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <uxSchedulerSuspended>
     b50:	08 95       	ret

00000b52 <xTaskGetTickCount>:
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	0f 92       	push	r0
     b58:	80 91 6b 06 	lds	r24, 0x066B	; 0x80066b <xTickCount>
     b5c:	90 91 6c 06 	lds	r25, 0x066C	; 0x80066c <xTickCount+0x1>
     b60:	0f 90       	pop	r0
     b62:	0f be       	out	0x3f, r0	; 63
     b64:	08 95       	ret

00000b66 <xTaskIncrementTick>:
     b66:	cf 92       	push	r12
     b68:	df 92       	push	r13
     b6a:	ef 92       	push	r14
     b6c:	ff 92       	push	r15
     b6e:	0f 93       	push	r16
     b70:	1f 93       	push	r17
     b72:	cf 93       	push	r28
     b74:	df 93       	push	r29
     b76:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <uxSchedulerSuspended>
     b7a:	81 11       	cpse	r24, r1
     b7c:	99 c0       	rjmp	.+306    	; 0xcb0 <xTaskIncrementTick+0x14a>
     b7e:	e0 90 6b 06 	lds	r14, 0x066B	; 0x80066b <xTickCount>
     b82:	f0 90 6c 06 	lds	r15, 0x066C	; 0x80066c <xTickCount+0x1>
     b86:	8f ef       	ldi	r24, 0xFF	; 255
     b88:	e8 1a       	sub	r14, r24
     b8a:	f8 0a       	sbc	r15, r24
     b8c:	f0 92 6c 06 	sts	0x066C, r15	; 0x80066c <xTickCount+0x1>
     b90:	e0 92 6b 06 	sts	0x066B, r14	; 0x80066b <xTickCount>
     b94:	e1 14       	cp	r14, r1
     b96:	f1 04       	cpc	r15, r1
     b98:	b9 f4       	brne	.+46     	; 0xbc8 <xTaskIncrementTick+0x62>
     b9a:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <pxDelayedTaskList>
     b9e:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <pxDelayedTaskList+0x1>
     ba2:	20 91 81 06 	lds	r18, 0x0681	; 0x800681 <pxOverflowDelayedTaskList>
     ba6:	30 91 82 06 	lds	r19, 0x0682	; 0x800682 <pxOverflowDelayedTaskList+0x1>
     baa:	30 93 84 06 	sts	0x0684, r19	; 0x800684 <pxDelayedTaskList+0x1>
     bae:	20 93 83 06 	sts	0x0683, r18	; 0x800683 <pxDelayedTaskList>
     bb2:	90 93 82 06 	sts	0x0682, r25	; 0x800682 <pxOverflowDelayedTaskList+0x1>
     bb6:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <pxOverflowDelayedTaskList>
     bba:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xNumOfOverflows>
     bbe:	8f 5f       	subi	r24, 0xFF	; 255
     bc0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <xNumOfOverflows>
     bc4:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <prvResetNextTaskUnblockTime>
     bc8:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <xNextTaskUnblockTime>
     bcc:	90 91 64 06 	lds	r25, 0x0664	; 0x800664 <xNextTaskUnblockTime+0x1>
     bd0:	e8 16       	cp	r14, r24
     bd2:	f9 06       	cpc	r15, r25
     bd4:	10 f4       	brcc	.+4      	; 0xbda <xTaskIncrementTick+0x74>
     bd6:	d1 2c       	mov	r13, r1
     bd8:	53 c0       	rjmp	.+166    	; 0xc80 <xTaskIncrementTick+0x11a>
     bda:	d1 2c       	mov	r13, r1
     bdc:	cc 24       	eor	r12, r12
     bde:	c3 94       	inc	r12
     be0:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxDelayedTaskList>
     be4:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxDelayedTaskList+0x1>
     be8:	80 81       	ld	r24, Z
     bea:	81 11       	cpse	r24, r1
     bec:	07 c0       	rjmp	.+14     	; 0xbfc <xTaskIncrementTick+0x96>
     bee:	8f ef       	ldi	r24, 0xFF	; 255
     bf0:	9f ef       	ldi	r25, 0xFF	; 255
     bf2:	90 93 64 06 	sts	0x0664, r25	; 0x800664 <xNextTaskUnblockTime+0x1>
     bf6:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <xNextTaskUnblockTime>
     bfa:	42 c0       	rjmp	.+132    	; 0xc80 <xTaskIncrementTick+0x11a>
     bfc:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxDelayedTaskList>
     c00:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxDelayedTaskList+0x1>
     c04:	05 80       	ldd	r0, Z+5	; 0x05
     c06:	f6 81       	ldd	r31, Z+6	; 0x06
     c08:	e0 2d       	mov	r30, r0
     c0a:	c6 81       	ldd	r28, Z+6	; 0x06
     c0c:	d7 81       	ldd	r29, Z+7	; 0x07
     c0e:	8a 81       	ldd	r24, Y+2	; 0x02
     c10:	9b 81       	ldd	r25, Y+3	; 0x03
     c12:	e8 16       	cp	r14, r24
     c14:	f9 06       	cpc	r15, r25
     c16:	28 f4       	brcc	.+10     	; 0xc22 <xTaskIncrementTick+0xbc>
     c18:	90 93 64 06 	sts	0x0664, r25	; 0x800664 <xNextTaskUnblockTime+0x1>
     c1c:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <xNextTaskUnblockTime>
     c20:	2f c0       	rjmp	.+94     	; 0xc80 <xTaskIncrementTick+0x11a>
     c22:	8e 01       	movw	r16, r28
     c24:	0e 5f       	subi	r16, 0xFE	; 254
     c26:	1f 4f       	sbci	r17, 0xFF	; 255
     c28:	c8 01       	movw	r24, r16
     c2a:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     c2e:	8c 89       	ldd	r24, Y+20	; 0x14
     c30:	9d 89       	ldd	r25, Y+21	; 0x15
     c32:	89 2b       	or	r24, r25
     c34:	21 f0       	breq	.+8      	; 0xc3e <xTaskIncrementTick+0xd8>
     c36:	ce 01       	movw	r24, r28
     c38:	0c 96       	adiw	r24, 0x0c	; 12
     c3a:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     c3e:	8e 89       	ldd	r24, Y+22	; 0x16
     c40:	90 91 6a 06 	lds	r25, 0x066A	; 0x80066a <uxTopReadyPriority>
     c44:	98 17       	cp	r25, r24
     c46:	10 f4       	brcc	.+4      	; 0xc4c <xTaskIncrementTick+0xe6>
     c48:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <uxTopReadyPriority>
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	9c 01       	movw	r18, r24
     c50:	22 0f       	add	r18, r18
     c52:	33 1f       	adc	r19, r19
     c54:	22 0f       	add	r18, r18
     c56:	33 1f       	adc	r19, r19
     c58:	22 0f       	add	r18, r18
     c5a:	33 1f       	adc	r19, r19
     c5c:	82 0f       	add	r24, r18
     c5e:	93 1f       	adc	r25, r19
     c60:	b8 01       	movw	r22, r16
     c62:	89 56       	subi	r24, 0x69	; 105
     c64:	99 4f       	sbci	r25, 0xF9	; 249
     c66:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
     c6a:	e0 91 bb 06 	lds	r30, 0x06BB	; 0x8006bb <pxCurrentTCB>
     c6e:	f0 91 bc 06 	lds	r31, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     c72:	9e 89       	ldd	r25, Y+22	; 0x16
     c74:	86 89       	ldd	r24, Z+22	; 0x16
     c76:	98 17       	cp	r25, r24
     c78:	08 f4       	brcc	.+2      	; 0xc7c <xTaskIncrementTick+0x116>
     c7a:	b2 cf       	rjmp	.-156    	; 0xbe0 <xTaskIncrementTick+0x7a>
     c7c:	dc 2c       	mov	r13, r12
     c7e:	b0 cf       	rjmp	.-160    	; 0xbe0 <xTaskIncrementTick+0x7a>
     c80:	e0 91 bb 06 	lds	r30, 0x06BB	; 0x8006bb <pxCurrentTCB>
     c84:	f0 91 bc 06 	lds	r31, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     c88:	86 89       	ldd	r24, Z+22	; 0x16
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	fc 01       	movw	r30, r24
     c8e:	ee 0f       	add	r30, r30
     c90:	ff 1f       	adc	r31, r31
     c92:	ee 0f       	add	r30, r30
     c94:	ff 1f       	adc	r31, r31
     c96:	ee 0f       	add	r30, r30
     c98:	ff 1f       	adc	r31, r31
     c9a:	8e 0f       	add	r24, r30
     c9c:	9f 1f       	adc	r25, r31
     c9e:	fc 01       	movw	r30, r24
     ca0:	e9 56       	subi	r30, 0x69	; 105
     ca2:	f9 4f       	sbci	r31, 0xF9	; 249
     ca4:	80 81       	ld	r24, Z
     ca6:	82 30       	cpi	r24, 0x02	; 2
     ca8:	48 f0       	brcs	.+18     	; 0xcbc <xTaskIncrementTick+0x156>
     caa:	dd 24       	eor	r13, r13
     cac:	d3 94       	inc	r13
     cae:	06 c0       	rjmp	.+12     	; 0xcbc <xTaskIncrementTick+0x156>
     cb0:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <uxPendedTicks>
     cb4:	8f 5f       	subi	r24, 0xFF	; 255
     cb6:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <uxPendedTicks>
     cba:	d1 2c       	mov	r13, r1
     cbc:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xYieldPending>
     cc0:	88 23       	and	r24, r24
     cc2:	11 f0       	breq	.+4      	; 0xcc8 <xTaskIncrementTick+0x162>
     cc4:	dd 24       	eor	r13, r13
     cc6:	d3 94       	inc	r13
     cc8:	8d 2d       	mov	r24, r13
     cca:	df 91       	pop	r29
     ccc:	cf 91       	pop	r28
     cce:	1f 91       	pop	r17
     cd0:	0f 91       	pop	r16
     cd2:	ff 90       	pop	r15
     cd4:	ef 90       	pop	r14
     cd6:	df 90       	pop	r13
     cd8:	cf 90       	pop	r12
     cda:	08 95       	ret

00000cdc <xTaskResumeAll>:
     cdc:	df 92       	push	r13
     cde:	ef 92       	push	r14
     ce0:	ff 92       	push	r15
     ce2:	0f 93       	push	r16
     ce4:	1f 93       	push	r17
     ce6:	cf 93       	push	r28
     ce8:	df 93       	push	r29
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	0f 92       	push	r0
     cf0:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <uxSchedulerSuspended>
     cf4:	81 50       	subi	r24, 0x01	; 1
     cf6:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <uxSchedulerSuspended>
     cfa:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <uxSchedulerSuspended>
     cfe:	81 11       	cpse	r24, r1
     d00:	5f c0       	rjmp	.+190    	; 0xdc0 <xTaskResumeAll+0xe4>
     d02:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <uxCurrentNumberOfTasks>
     d06:	81 11       	cpse	r24, r1
     d08:	33 c0       	rjmp	.+102    	; 0xd70 <xTaskResumeAll+0x94>
     d0a:	5d c0       	rjmp	.+186    	; 0xdc6 <xTaskResumeAll+0xea>
     d0c:	d7 01       	movw	r26, r14
     d0e:	15 96       	adiw	r26, 0x05	; 5
     d10:	ed 91       	ld	r30, X+
     d12:	fc 91       	ld	r31, X
     d14:	16 97       	sbiw	r26, 0x06	; 6
     d16:	c6 81       	ldd	r28, Z+6	; 0x06
     d18:	d7 81       	ldd	r29, Z+7	; 0x07
     d1a:	ce 01       	movw	r24, r28
     d1c:	0c 96       	adiw	r24, 0x0c	; 12
     d1e:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     d22:	8e 01       	movw	r16, r28
     d24:	0e 5f       	subi	r16, 0xFE	; 254
     d26:	1f 4f       	sbci	r17, 0xFF	; 255
     d28:	c8 01       	movw	r24, r16
     d2a:	0e 94 19 01 	call	0x232	; 0x232 <uxListRemove>
     d2e:	8e 89       	ldd	r24, Y+22	; 0x16
     d30:	90 91 6a 06 	lds	r25, 0x066A	; 0x80066a <uxTopReadyPriority>
     d34:	98 17       	cp	r25, r24
     d36:	10 f4       	brcc	.+4      	; 0xd3c <xTaskResumeAll+0x60>
     d38:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <uxTopReadyPriority>
     d3c:	90 e0       	ldi	r25, 0x00	; 0
     d3e:	9c 01       	movw	r18, r24
     d40:	22 0f       	add	r18, r18
     d42:	33 1f       	adc	r19, r19
     d44:	22 0f       	add	r18, r18
     d46:	33 1f       	adc	r19, r19
     d48:	22 0f       	add	r18, r18
     d4a:	33 1f       	adc	r19, r19
     d4c:	82 0f       	add	r24, r18
     d4e:	93 1f       	adc	r25, r19
     d50:	b8 01       	movw	r22, r16
     d52:	89 56       	subi	r24, 0x69	; 105
     d54:	99 4f       	sbci	r25, 0xF9	; 249
     d56:	0e 94 c7 00 	call	0x18e	; 0x18e <vListInsertEnd>
     d5a:	e0 91 bb 06 	lds	r30, 0x06BB	; 0x8006bb <pxCurrentTCB>
     d5e:	f0 91 bc 06 	lds	r31, 0x06BC	; 0x8006bc <pxCurrentTCB+0x1>
     d62:	9e 89       	ldd	r25, Y+22	; 0x16
     d64:	86 89       	ldd	r24, Z+22	; 0x16
     d66:	98 17       	cp	r25, r24
     d68:	68 f0       	brcs	.+26     	; 0xd84 <xTaskResumeAll+0xa8>
     d6a:	d0 92 67 06 	sts	0x0667, r13	; 0x800667 <xYieldPending>
     d6e:	0a c0       	rjmp	.+20     	; 0xd84 <xTaskResumeAll+0xa8>
     d70:	c0 e0       	ldi	r28, 0x00	; 0
     d72:	d0 e0       	ldi	r29, 0x00	; 0
     d74:	0f 2e       	mov	r0, r31
     d76:	f8 e7       	ldi	r31, 0x78	; 120
     d78:	ef 2e       	mov	r14, r31
     d7a:	f6 e0       	ldi	r31, 0x06	; 6
     d7c:	ff 2e       	mov	r15, r31
     d7e:	f0 2d       	mov	r31, r0
     d80:	dd 24       	eor	r13, r13
     d82:	d3 94       	inc	r13
     d84:	f7 01       	movw	r30, r14
     d86:	80 81       	ld	r24, Z
     d88:	81 11       	cpse	r24, r1
     d8a:	c0 cf       	rjmp	.-128    	; 0xd0c <xTaskResumeAll+0x30>
     d8c:	cd 2b       	or	r28, r29
     d8e:	11 f0       	breq	.+4      	; 0xd94 <xTaskResumeAll+0xb8>
     d90:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <prvResetNextTaskUnblockTime>
     d94:	c0 91 68 06 	lds	r28, 0x0668	; 0x800668 <uxPendedTicks>
     d98:	cc 23       	and	r28, r28
     d9a:	51 f0       	breq	.+20     	; 0xdb0 <xTaskResumeAll+0xd4>
     d9c:	d1 e0       	ldi	r29, 0x01	; 1
     d9e:	0e 94 b3 05 	call	0xb66	; 0xb66 <xTaskIncrementTick>
     da2:	81 11       	cpse	r24, r1
     da4:	d0 93 67 06 	sts	0x0667, r29	; 0x800667 <xYieldPending>
     da8:	c1 50       	subi	r28, 0x01	; 1
     daa:	c9 f7       	brne	.-14     	; 0xd9e <xTaskResumeAll+0xc2>
     dac:	10 92 68 06 	sts	0x0668, r1	; 0x800668 <uxPendedTicks>
     db0:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <xYieldPending>
     db4:	88 23       	and	r24, r24
     db6:	31 f0       	breq	.+12     	; 0xdc4 <xTaskResumeAll+0xe8>
     db8:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <vPortYield>
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	03 c0       	rjmp	.+6      	; 0xdc6 <xTaskResumeAll+0xea>
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	01 c0       	rjmp	.+2      	; 0xdc6 <xTaskResumeAll+0xea>
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	0f 90       	pop	r0
     dc8:	0f be       	out	0x3f, r0	; 63
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	1f 91       	pop	r17
     dd0:	0f 91       	pop	r16
     dd2:	ff 90       	pop	r15
     dd4:	ef 90       	pop	r14
     dd6:	df 90       	pop	r13
     dd8:	08 95       	ret

00000dda <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     dda:	cf 93       	push	r28
     ddc:	df 93       	push	r29
     dde:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     de0:	89 2b       	or	r24, r25
     de2:	51 f0       	breq	.+20     	; 0xdf8 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     de4:	0e 94 a3 05 	call	0xb46	; 0xb46 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     de8:	60 e0       	ldi	r22, 0x00	; 0
     dea:	ce 01       	movw	r24, r28
     dec:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     df0:	0e 94 6e 06 	call	0xcdc	; 0xcdc <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     df4:	81 11       	cpse	r24, r1
     df6:	02 c0       	rjmp	.+4      	; 0xdfc <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
     df8:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     dfc:	df 91       	pop	r29
     dfe:	cf 91       	pop	r28
     e00:	08 95       	ret

00000e02 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     e02:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <uxSchedulerSuspended>
     e06:	88 23       	and	r24, r24
     e08:	21 f0       	breq	.+8      	; 0xe12 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     e0a:	81 e0       	ldi	r24, 0x01	; 1
     e0c:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <xYieldPending>
     e10:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     e12:	10 92 67 06 	sts	0x0667, r1	; 0x800667 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     e16:	20 91 6a 06 	lds	r18, 0x066A	; 0x80066a <uxTopReadyPriority>
     e1a:	82 2f       	mov	r24, r18
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	fc 01       	movw	r30, r24
     e20:	ee 0f       	add	r30, r30
     e22:	ff 1f       	adc	r31, r31
     e24:	ee 0f       	add	r30, r30
     e26:	ff 1f       	adc	r31, r31
     e28:	ee 0f       	add	r30, r30
     e2a:	ff 1f       	adc	r31, r31
     e2c:	e8 0f       	add	r30, r24
     e2e:	f9 1f       	adc	r31, r25
     e30:	e9 56       	subi	r30, 0x69	; 105
     e32:	f9 4f       	sbci	r31, 0xF9	; 249
     e34:	30 81       	ld	r19, Z
     e36:	31 11       	cpse	r19, r1
     e38:	11 c0       	rjmp	.+34     	; 0xe5c <vTaskSwitchContext+0x5a>
     e3a:	21 50       	subi	r18, 0x01	; 1
     e3c:	82 2f       	mov	r24, r18
     e3e:	90 e0       	ldi	r25, 0x00	; 0
     e40:	fc 01       	movw	r30, r24
     e42:	ee 0f       	add	r30, r30
     e44:	ff 1f       	adc	r31, r31
     e46:	ee 0f       	add	r30, r30
     e48:	ff 1f       	adc	r31, r31
     e4a:	ee 0f       	add	r30, r30
     e4c:	ff 1f       	adc	r31, r31
     e4e:	e8 0f       	add	r30, r24
     e50:	f9 1f       	adc	r31, r25
     e52:	e9 56       	subi	r30, 0x69	; 105
     e54:	f9 4f       	sbci	r31, 0xF9	; 249
     e56:	30 81       	ld	r19, Z
     e58:	33 23       	and	r19, r19
     e5a:	79 f3       	breq	.-34     	; 0xe3a <vTaskSwitchContext+0x38>
     e5c:	ac 01       	movw	r20, r24
     e5e:	44 0f       	add	r20, r20
     e60:	55 1f       	adc	r21, r21
     e62:	44 0f       	add	r20, r20
     e64:	55 1f       	adc	r21, r21
     e66:	44 0f       	add	r20, r20
     e68:	55 1f       	adc	r21, r21
     e6a:	48 0f       	add	r20, r24
     e6c:	59 1f       	adc	r21, r25
     e6e:	da 01       	movw	r26, r20
     e70:	a9 56       	subi	r26, 0x69	; 105
     e72:	b9 4f       	sbci	r27, 0xF9	; 249
     e74:	11 96       	adiw	r26, 0x01	; 1
     e76:	ed 91       	ld	r30, X+
     e78:	fc 91       	ld	r31, X
     e7a:	12 97       	sbiw	r26, 0x02	; 2
     e7c:	02 80       	ldd	r0, Z+2	; 0x02
     e7e:	f3 81       	ldd	r31, Z+3	; 0x03
     e80:	e0 2d       	mov	r30, r0
     e82:	12 96       	adiw	r26, 0x02	; 2
     e84:	fc 93       	st	X, r31
     e86:	ee 93       	st	-X, r30
     e88:	11 97       	sbiw	r26, 0x01	; 1
     e8a:	46 56       	subi	r20, 0x66	; 102
     e8c:	59 4f       	sbci	r21, 0xF9	; 249
     e8e:	e4 17       	cp	r30, r20
     e90:	f5 07       	cpc	r31, r21
     e92:	29 f4       	brne	.+10     	; 0xe9e <vTaskSwitchContext+0x9c>
     e94:	42 81       	ldd	r20, Z+2	; 0x02
     e96:	53 81       	ldd	r21, Z+3	; 0x03
     e98:	fd 01       	movw	r30, r26
     e9a:	52 83       	std	Z+2, r21	; 0x02
     e9c:	41 83       	std	Z+1, r20	; 0x01
     e9e:	fc 01       	movw	r30, r24
     ea0:	ee 0f       	add	r30, r30
     ea2:	ff 1f       	adc	r31, r31
     ea4:	ee 0f       	add	r30, r30
     ea6:	ff 1f       	adc	r31, r31
     ea8:	ee 0f       	add	r30, r30
     eaa:	ff 1f       	adc	r31, r31
     eac:	8e 0f       	add	r24, r30
     eae:	9f 1f       	adc	r25, r31
     eb0:	fc 01       	movw	r30, r24
     eb2:	e9 56       	subi	r30, 0x69	; 105
     eb4:	f9 4f       	sbci	r31, 0xF9	; 249
     eb6:	01 80       	ldd	r0, Z+1	; 0x01
     eb8:	f2 81       	ldd	r31, Z+2	; 0x02
     eba:	e0 2d       	mov	r30, r0
     ebc:	86 81       	ldd	r24, Z+6	; 0x06
     ebe:	97 81       	ldd	r25, Z+7	; 0x07
     ec0:	90 93 bc 06 	sts	0x06BC, r25	; 0x8006bc <pxCurrentTCB+0x1>
     ec4:	80 93 bb 06 	sts	0x06BB, r24	; 0x8006bb <pxCurrentTCB>
     ec8:	20 93 6a 06 	sts	0x066A, r18	; 0x80066a <uxTopReadyPriority>
     ecc:	08 95       	ret

00000ece <LCDWriteByte>:
	_delay_ms(100);
}

void LCDWriteByte(_LCDRegister reg, uint8_t data)
{
	LCD_PORT&=LCD_MASK;
     ece:	9b b3       	in	r25, 0x1b	; 27
     ed0:	90 7c       	andi	r25, 0xC0	; 192
     ed2:	9b bb       	out	0x1b, r25	; 27
	
	if(reg)LCD_PORT|=LCD_RS;
     ed4:	81 11       	cpse	r24, r1
     ed6:	dc 9a       	sbi	0x1b, 4	; 27
	
	LCD_PORT|=data>>4;
     ed8:	8b b3       	in	r24, 0x1b	; 27
     eda:	96 2f       	mov	r25, r22
     edc:	92 95       	swap	r25
     ede:	9f 70       	andi	r25, 0x0F	; 15
     ee0:	89 2b       	or	r24, r25
     ee2:	8b bb       	out	0x1b, r24	; 27
	LCD_PORT|=LCD_E;
     ee4:	dd 9a       	sbi	0x1b, 5	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ee6:	8d e0       	ldi	r24, 0x0D	; 13
     ee8:	8a 95       	dec	r24
     eea:	f1 f7       	brne	.-4      	; 0xee8 <LCDWriteByte+0x1a>
     eec:	00 00       	nop
	_delay_us(40);
	LCD_PORT&=~LCD_E;
     eee:	dd 98       	cbi	0x1b, 5	; 27
     ef0:	8d e0       	ldi	r24, 0x0D	; 13
     ef2:	8a 95       	dec	r24
     ef4:	f1 f7       	brne	.-4      	; 0xef2 <LCDWriteByte+0x24>
     ef6:	00 00       	nop
	_delay_us(40);
	
	LCD_PORT&=0xf0;
     ef8:	8b b3       	in	r24, 0x1b	; 27
     efa:	80 7f       	andi	r24, 0xF0	; 240
     efc:	8b bb       	out	0x1b, r24	; 27
	
	LCD_PORT|=data&0x0f;
     efe:	8b b3       	in	r24, 0x1b	; 27
     f00:	6f 70       	andi	r22, 0x0F	; 15
     f02:	68 2b       	or	r22, r24
     f04:	6b bb       	out	0x1b, r22	; 27
	LCD_PORT|=LCD_E;
     f06:	dd 9a       	sbi	0x1b, 5	; 27
     f08:	8d e0       	ldi	r24, 0x0D	; 13
     f0a:	8a 95       	dec	r24
     f0c:	f1 f7       	brne	.-4      	; 0xf0a <LCDWriteByte+0x3c>
     f0e:	00 00       	nop
	_delay_us(40);
	LCD_PORT&=~LCD_E;
     f10:	dd 98       	cbi	0x1b, 5	; 27
     f12:	8d e0       	ldi	r24, 0x0D	; 13
     f14:	8a 95       	dec	r24
     f16:	f1 f7       	brne	.-4      	; 0xf14 <LCDWriteByte+0x46>
     f18:	00 00       	nop
     f1a:	08 95       	ret

00000f1c <LCDInit>:
#define LCD_E (1<<5)
#define LCD_MASK 0xC0

void LCDInit()
{
	DDRA|=~LCD_MASK;
     f1c:	8a b3       	in	r24, 0x1a	; 26
     f1e:	8f 63       	ori	r24, 0x3F	; 63
     f20:	8a bb       	out	0x1a, r24	; 26
	LCDWriteByte(LCD_IR, 0x33);
     f22:	63 e3       	ldi	r22, 0x33	; 51
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f2a:	87 ea       	ldi	r24, 0xA7	; 167
     f2c:	91 e6       	ldi	r25, 0x61	; 97
     f2e:	01 97       	sbiw	r24, 0x01	; 1
     f30:	f1 f7       	brne	.-4      	; 0xf2e <LCDInit+0x12>
     f32:	00 c0       	rjmp	.+0      	; 0xf34 <LCDInit+0x18>
     f34:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x32);
     f36:	62 e3       	ldi	r22, 0x32	; 50
     f38:	80 e0       	ldi	r24, 0x00	; 0
     f3a:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
     f3e:	87 ea       	ldi	r24, 0xA7	; 167
     f40:	91 e6       	ldi	r25, 0x61	; 97
     f42:	01 97       	sbiw	r24, 0x01	; 1
     f44:	f1 f7       	brne	.-4      	; 0xf42 <LCDInit+0x26>
     f46:	00 c0       	rjmp	.+0      	; 0xf48 <LCDInit+0x2c>
     f48:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x28);
     f4a:	68 e2       	ldi	r22, 0x28	; 40
     f4c:	80 e0       	ldi	r24, 0x00	; 0
     f4e:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
     f52:	87 ea       	ldi	r24, 0xA7	; 167
     f54:	91 e6       	ldi	r25, 0x61	; 97
     f56:	01 97       	sbiw	r24, 0x01	; 1
     f58:	f1 f7       	brne	.-4      	; 0xf56 <LCDInit+0x3a>
     f5a:	00 c0       	rjmp	.+0      	; 0xf5c <LCDInit+0x40>
     f5c:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x01);
     f5e:	61 e0       	ldi	r22, 0x01	; 1
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
     f66:	87 ea       	ldi	r24, 0xA7	; 167
     f68:	91 e6       	ldi	r25, 0x61	; 97
     f6a:	01 97       	sbiw	r24, 0x01	; 1
     f6c:	f1 f7       	brne	.-4      	; 0xf6a <LCDInit+0x4e>
     f6e:	00 c0       	rjmp	.+0      	; 0xf70 <LCDInit+0x54>
     f70:	00 00       	nop
	_delay_ms(100);
	LCDWriteByte(LCD_IR, 0x0c);
     f72:	6c e0       	ldi	r22, 0x0C	; 12
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
     f7a:	87 ea       	ldi	r24, 0xA7	; 167
     f7c:	91 e6       	ldi	r25, 0x61	; 97
     f7e:	01 97       	sbiw	r24, 0x01	; 1
     f80:	f1 f7       	brne	.-4      	; 0xf7e <LCDInit+0x62>
     f82:	00 c0       	rjmp	.+0      	; 0xf84 <LCDInit+0x68>
     f84:	00 00       	nop
     f86:	08 95       	ret

00000f88 <LCDKursorPosihin>:
	_delay_us(40);
}

void LCDKursorPosihin(uint8_t row, uint8_t col)
{
	if(!row) {
     f88:	81 11       	cpse	r24, r1
     f8a:	04 c0       	rjmp	.+8      	; 0xf94 <LCDKursorPosihin+0xc>
		LCDWriteByte(LCD_IR, (1<<7)|col);
     f8c:	60 68       	ori	r22, 0x80	; 128
     f8e:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
     f92:	08 95       	ret
	}
	else{
		LCDWriteByte(LCD_IR, (3<<6)|col);
     f94:	60 6c       	ori	r22, 0xC0	; 192
     f96:	80 e0       	ldi	r24, 0x00	; 0
     f98:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
     f9c:	08 95       	ret

00000f9e <init_timer>:



void init_timer(){
	    //     
    TCCR0 |= (1 << WGM01) | (1 << CS02) | (1 << CS00);
     f9e:	83 b7       	in	r24, 0x33	; 51
     fa0:	8d 60       	ori	r24, 0x0D	; 13
     fa2:	83 bf       	out	0x33, r24	; 51
    
    //    
    TCNT0 = 0;
     fa4:	12 be       	out	0x32, r1	; 50
    
    //     
    TIMSK |= (1 << TOIE0);
     fa6:	89 b7       	in	r24, 0x39	; 57
     fa8:	81 60       	ori	r24, 0x01	; 1
     faa:	89 bf       	out	0x39, r24	; 57
    
    //   
    sei();
     fac:	78 94       	sei
     fae:	08 95       	ret

00000fb0 <__vector_11>:
}

ISR(TIMER0_OVF_vect) {
     fb0:	1f 92       	push	r1
     fb2:	0f 92       	push	r0
     fb4:	0f b6       	in	r0, 0x3f	; 63
     fb6:	0f 92       	push	r0
     fb8:	11 24       	eor	r1, r1
     fba:	8f 93       	push	r24
    //    
    //computeTimeArray();
    //   
    TIFR |= (1 << TOV0);
     fbc:	88 b7       	in	r24, 0x38	; 56
     fbe:	81 60       	ori	r24, 0x01	; 1
     fc0:	88 bf       	out	0x38, r24	; 56
}
     fc2:	8f 91       	pop	r24
     fc4:	0f 90       	pop	r0
     fc6:	0f be       	out	0x3f, r0	; 63
     fc8:	0f 90       	pop	r0
     fca:	1f 90       	pop	r1
     fcc:	18 95       	reti

00000fce <main>:

void vDisplayClockTask (void *pvParameters);

int main(void)
{
	xTaskCreate(vDisplayClockTask, (char*) "DisplayClockTask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, NULL);
     fce:	e1 2c       	mov	r14, r1
     fd0:	f1 2c       	mov	r15, r1
     fd2:	01 e0       	ldi	r16, 0x01	; 1
     fd4:	20 e0       	ldi	r18, 0x00	; 0
     fd6:	30 e0       	ldi	r19, 0x00	; 0
     fd8:	45 e5       	ldi	r20, 0x55	; 85
     fda:	50 e0       	ldi	r21, 0x00	; 0
     fdc:	66 e6       	ldi	r22, 0x66	; 102
     fde:	70 e0       	ldi	r23, 0x00	; 0
     fe0:	8c e4       	ldi	r24, 0x4C	; 76
     fe2:	98 e0       	ldi	r25, 0x08	; 8
     fe4:	0e 94 71 04 	call	0x8e2	; 0x8e2 <xTaskCreate>
	vTaskStartScheduler();
     fe8:	0e 94 79 05 	call	0xaf2	; 0xaf2 <vTaskStartScheduler>
     fec:	ff cf       	rjmp	.-2      	; 0xfec <main+0x1e>

00000fee <vApplicationIdleHook>:
    while (1)
    {
    }
}

void vApplicationIdleHook() {} // empty func to rid of idle-thread
     fee:	08 95       	ret

00000ff0 <computePosition>:
	vTaskDelete(NULL);
}

void computePosition()
{
	switch(PIND)
     ff0:	80 b3       	in	r24, 0x10	; 16
     ff2:	8f 3b       	cpi	r24, 0xBF	; 191
     ff4:	51 f0       	breq	.+20     	; 0x100a <computePosition+0x1a>
     ff6:	8f 3d       	cpi	r24, 0xDF	; 223
     ff8:	19 f0       	breq	.+6      	; 0x1000 <computePosition+0x10>
     ffa:	8f 37       	cpi	r24, 0x7F	; 127
     ffc:	a1 f4       	brne	.+40     	; 0x1026 <computePosition+0x36>
     ffe:	0c c0       	rjmp	.+24     	; 0x1018 <computePosition+0x28>
	{
		case CHANGING:
		flagMoovingSpeed = 0;
    1000:	10 92 c2 06 	sts	0x06C2, r1	; 0x8006c2 <flagMoovingSpeed+0x1>
    1004:	10 92 c1 06 	sts	0x06C1, r1	; 0x8006c1 <flagMoovingSpeed>
    1008:	1a c0       	rjmp	.+52     	; 0x103e <computePosition+0x4e>
		break;
		case RIGHT:
		flagMoovingSpeed = 1;
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	90 93 c2 06 	sts	0x06C2, r25	; 0x8006c2 <flagMoovingSpeed+0x1>
    1012:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <flagMoovingSpeed>
    1016:	18 c0       	rjmp	.+48     	; 0x1048 <computePosition+0x58>
		break;
		case LEFT:
		flagMoovingSpeed = 2;
    1018:	82 e0       	ldi	r24, 0x02	; 2
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	90 93 c2 06 	sts	0x06C2, r25	; 0x8006c2 <flagMoovingSpeed+0x1>
    1020:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <flagMoovingSpeed>
    1024:	16 c0       	rjmp	.+44     	; 0x1052 <computePosition+0x62>
		break;
	}
	
	switch(flagMoovingSpeed)
    1026:	80 91 c1 06 	lds	r24, 0x06C1	; 0x8006c1 <flagMoovingSpeed>
    102a:	90 91 c2 06 	lds	r25, 0x06C2	; 0x8006c2 <flagMoovingSpeed+0x1>
    102e:	81 30       	cpi	r24, 0x01	; 1
    1030:	91 05       	cpc	r25, r1
    1032:	51 f0       	breq	.+20     	; 0x1048 <computePosition+0x58>
    1034:	82 30       	cpi	r24, 0x02	; 2
    1036:	91 05       	cpc	r25, r1
    1038:	61 f0       	breq	.+24     	; 0x1052 <computePosition+0x62>
    103a:	89 2b       	or	r24, r25
    103c:	71 f4       	brne	.+28     	; 0x105a <computePosition+0x6a>
	{
		case 0:
		 vTaskDelay(150);
    103e:	86 e9       	ldi	r24, 0x96	; 150
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	0e 94 ed 06 	call	0xdda	; 0xdda <vTaskDelay>
		break;
    1046:	09 c0       	rjmp	.+18     	; 0x105a <computePosition+0x6a>
		case 1:
		 vTaskDelay(500);
    1048:	84 ef       	ldi	r24, 0xF4	; 244
    104a:	91 e0       	ldi	r25, 0x01	; 1
    104c:	0e 94 ed 06 	call	0xdda	; 0xdda <vTaskDelay>
		break;
    1050:	04 c0       	rjmp	.+8      	; 0x105a <computePosition+0x6a>
		case 2:
		 vTaskDelay(1000);
    1052:	88 ee       	ldi	r24, 0xE8	; 232
    1054:	93 e0       	ldi	r25, 0x03	; 3
    1056:	0e 94 ed 06 	call	0xdda	; 0xdda <vTaskDelay>
		break;
	}
	if (positionOnDisplay == 5 || positionOnDisplay == 0)
    105a:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <positionOnDisplay>
    105e:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <positionOnDisplay+0x1>
    1062:	85 30       	cpi	r24, 0x05	; 5
    1064:	91 05       	cpc	r25, r1
    1066:	11 f0       	breq	.+4      	; 0x106c <computePosition+0x7c>
    1068:	00 97       	sbiw	r24, 0x00	; 0
    106a:	31 f4       	brne	.+12     	; 0x1078 <computePosition+0x88>
	isGoingLeft = !isGoingLeft;
    106c:	30 91 60 00 	lds	r19, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    1070:	21 e0       	ldi	r18, 0x01	; 1
    1072:	23 27       	eor	r18, r19
    1074:	20 93 60 00 	sts	0x0060, r18	; 0x800060 <__DATA_REGION_ORIGIN__>

	isGoingLeft ? positionOnDisplay-- : positionOnDisplay++;
    1078:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    107c:	22 23       	and	r18, r18
    107e:	31 f0       	breq	.+12     	; 0x108c <computePosition+0x9c>
    1080:	01 97       	sbiw	r24, 0x01	; 1
    1082:	90 93 c4 06 	sts	0x06C4, r25	; 0x8006c4 <positionOnDisplay+0x1>
    1086:	80 93 c3 06 	sts	0x06C3, r24	; 0x8006c3 <positionOnDisplay>
    108a:	08 95       	ret
    108c:	01 96       	adiw	r24, 0x01	; 1
    108e:	90 93 c4 06 	sts	0x06C4, r25	; 0x8006c4 <positionOnDisplay+0x1>
    1092:	80 93 c3 06 	sts	0x06C3, r24	; 0x8006c3 <positionOnDisplay>
    1096:	08 95       	ret

00001098 <vDisplayClockTask>:

void vApplicationIdleHook() {} // empty func to rid of idle-thread

void vDisplayClockTask(void *pvParameters)
{	
    LCDInit(); 
    1098:	0e 94 8e 07 	call	0xf1c	; 0xf1c <LCDInit>
    nullifyTimeArray(); 
    109c:	0e 94 ae 08 	call	0x115c	; 0x115c <nullifyTimeArray>
	nullifyDataArray();
    10a0:	0e 94 49 00 	call	0x92	; 0x92 <nullifyDataArray>
		
        computePosition(); 
        displayTime(positionOnDisplay); 
        displayData(positionOnDisplay);
		counter = xTaskGetTickCount();
		tick = counter % 1000;
    10a4:	c8 ee       	ldi	r28, 0xE8	; 232
    10a6:	d3 e0       	ldi	r29, 0x03	; 3
	nullifyDataArray();

    while (1) 
    {
		
		init_timer();
    10a8:	0e 94 cf 07 	call	0xf9e	; 0xf9e <init_timer>
		//vTaskStartScheduler();
		
		
		
		
        computePosition(); 
    10ac:	0e 94 f8 07 	call	0xff0	; 0xff0 <computePosition>
        displayTime(positionOnDisplay); 
    10b0:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <positionOnDisplay>
    10b4:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <positionOnDisplay+0x1>
    10b8:	0e 94 9d 08 	call	0x113a	; 0x113a <displayTime>
        displayData(positionOnDisplay);
    10bc:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <positionOnDisplay>
    10c0:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <positionOnDisplay+0x1>
    10c4:	0e 94 a8 00 	call	0x150	; 0x150 <displayData>
		counter = xTaskGetTickCount();
    10c8:	0e 94 a9 05 	call	0xb52	; 0xb52 <xTaskGetTickCount>
    10cc:	90 93 c0 06 	sts	0x06C0, r25	; 0x8006c0 <counter+0x1>
    10d0:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <counter>
		tick = counter % 1000;
    10d4:	be 01       	movw	r22, r28
    10d6:	0e 94 bb 08 	call	0x1176	; 0x1176 <__divmodhi4>
    10da:	90 93 be 06 	sts	0x06BE, r25	; 0x8006be <tick+0x1>
    10de:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <tick>
    10e2:	e2 cf       	rjmp	.-60     	; 0x10a8 <vDisplayClockTask+0x10>

000010e4 <clearDisplayFirstLine>:
	timeArrayToDisplayFirstLine(positionOnDisplay);
	showDisplayFirstLine();
}

void clearDisplayFirstLine() //  
{
    10e4:	eb ef       	ldi	r30, 0xFB	; 251
    10e6:	f6 e0       	ldi	r31, 0x06	; 6
    10e8:	2b e0       	ldi	r18, 0x0B	; 11
    10ea:	37 e0       	ldi	r19, 0x07	; 7
	for (int i = 0; i < 16; i++)
	{
		displayFirstLine[i] = ' ';
    10ec:	80 e2       	ldi	r24, 0x20	; 32
    10ee:	81 93       	st	Z+, r24
	showDisplayFirstLine();
}

void clearDisplayFirstLine() //  
{
	for (int i = 0; i < 16; i++)
    10f0:	e2 17       	cp	r30, r18
    10f2:	f3 07       	cpc	r31, r19
    10f4:	e1 f7       	brne	.-8      	; 0x10ee <clearDisplayFirstLine+0xa>
	{
		displayFirstLine[i] = ' ';
	}
}
    10f6:	08 95       	ret

000010f8 <timeArrayToDisplayFirstLine>:

void timeArrayToDisplayFirstLine(int positionOnDisplay)
{
    10f8:	eb e0       	ldi	r30, 0x0B	; 11
    10fa:	f7 e0       	ldi	r31, 0x07	; 7
    10fc:	dc 01       	movw	r26, r24
    10fe:	a2 50       	subi	r26, 0x02	; 2
    1100:	b9 4f       	sbci	r27, 0xF9	; 249
    1102:	23 e1       	ldi	r18, 0x13	; 19
    1104:	37 e0       	ldi	r19, 0x07	; 7
	for(int i = 0; i<8; i++)
	{
		// +3     ,  
		displayFirstLine[positionOnDisplay + i + 3] = time[i];
    1106:	81 91       	ld	r24, Z+
    1108:	8d 93       	st	X+, r24
	}
}

void timeArrayToDisplayFirstLine(int positionOnDisplay)
{
	for(int i = 0; i<8; i++)
    110a:	e2 17       	cp	r30, r18
    110c:	f3 07       	cpc	r31, r19
    110e:	d9 f7       	brne	.-10     	; 0x1106 <timeArrayToDisplayFirstLine+0xe>
	{
		// +3     ,  
		displayFirstLine[positionOnDisplay + i + 3] = time[i];
	}
}
    1110:	08 95       	ret

00001112 <showDisplayFirstLine>:

void showDisplayFirstLine()
{
    1112:	0f 93       	push	r16
    1114:	1f 93       	push	r17
    1116:	cf 93       	push	r28
    1118:	df 93       	push	r29
    111a:	cb ef       	ldi	r28, 0xFB	; 251
    111c:	d6 e0       	ldi	r29, 0x06	; 6
    111e:	0b e0       	ldi	r16, 0x0B	; 11
    1120:	17 e0       	ldi	r17, 0x07	; 7
	for(int i = 0; i < 16; i++)
	{
		LCDWriteByte(LCD_DR, displayFirstLine[i]);
    1122:	69 91       	ld	r22, Y+
    1124:	81 e0       	ldi	r24, 0x01	; 1
    1126:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
	}
}

void showDisplayFirstLine()
{
	for(int i = 0; i < 16; i++)
    112a:	c0 17       	cp	r28, r16
    112c:	d1 07       	cpc	r29, r17
    112e:	c9 f7       	brne	.-14     	; 0x1122 <showDisplayFirstLine+0x10>
	{
		LCDWriteByte(LCD_DR, displayFirstLine[i]);
	}
}
    1130:	df 91       	pop	r29
    1132:	cf 91       	pop	r28
    1134:	1f 91       	pop	r17
    1136:	0f 91       	pop	r16
    1138:	08 95       	ret

0000113a <displayTime>:
#include "LCD.h"

uint8_t displayFirstLine[16], count_timer = 0, time[8];

void displayTime(int positionOnDisplay)
{
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	ec 01       	movw	r28, r24
	LCDWriteByte(LCD_IR, 0b10000000);
    1140:	60 e8       	ldi	r22, 0x80	; 128
    1142:	80 e0       	ldi	r24, 0x00	; 0
    1144:	0e 94 67 07 	call	0xece	; 0xece <LCDWriteByte>
	clearDisplayFirstLine();
    1148:	0e 94 72 08 	call	0x10e4	; 0x10e4 <clearDisplayFirstLine>
	timeArrayToDisplayFirstLine(positionOnDisplay);
    114c:	ce 01       	movw	r24, r28
    114e:	0e 94 7c 08 	call	0x10f8	; 0x10f8 <timeArrayToDisplayFirstLine>
	showDisplayFirstLine();
    1152:	0e 94 89 08 	call	0x1112	; 0x1112 <showDisplayFirstLine>
}
    1156:	df 91       	pop	r29
    1158:	cf 91       	pop	r28
    115a:	08 95       	ret

0000115c <nullifyTimeArray>:
	time[0]++;
}

void nullifyTimeArray()
{
	time[0] = '0';
    115c:	eb e0       	ldi	r30, 0x0B	; 11
    115e:	f7 e0       	ldi	r31, 0x07	; 7
    1160:	80 e3       	ldi	r24, 0x30	; 48
    1162:	80 83       	st	Z, r24
	time[1] = '0';
    1164:	81 83       	std	Z+1, r24	; 0x01
	time[2] = ':';
    1166:	9a e3       	ldi	r25, 0x3A	; 58
    1168:	92 83       	std	Z+2, r25	; 0x02
	time[3] = '0';
    116a:	83 83       	std	Z+3, r24	; 0x03
	time[4] = '0';
    116c:	84 83       	std	Z+4, r24	; 0x04
	time[5] = ':';
    116e:	95 83       	std	Z+5, r25	; 0x05
	time[6] = '0';
    1170:	86 83       	std	Z+6, r24	; 0x06
	time[7] = '0';
    1172:	87 83       	std	Z+7, r24	; 0x07
    1174:	08 95       	ret

00001176 <__divmodhi4>:
    1176:	97 fb       	bst	r25, 7
    1178:	07 2e       	mov	r0, r23
    117a:	16 f4       	brtc	.+4      	; 0x1180 <__divmodhi4+0xa>
    117c:	00 94       	com	r0
    117e:	07 d0       	rcall	.+14     	; 0x118e <__divmodhi4_neg1>
    1180:	77 fd       	sbrc	r23, 7
    1182:	09 d0       	rcall	.+18     	; 0x1196 <__divmodhi4_neg2>
    1184:	0e 94 cf 08 	call	0x119e	; 0x119e <__udivmodhi4>
    1188:	07 fc       	sbrc	r0, 7
    118a:	05 d0       	rcall	.+10     	; 0x1196 <__divmodhi4_neg2>
    118c:	3e f4       	brtc	.+14     	; 0x119c <__divmodhi4_exit>

0000118e <__divmodhi4_neg1>:
    118e:	90 95       	com	r25
    1190:	81 95       	neg	r24
    1192:	9f 4f       	sbci	r25, 0xFF	; 255
    1194:	08 95       	ret

00001196 <__divmodhi4_neg2>:
    1196:	70 95       	com	r23
    1198:	61 95       	neg	r22
    119a:	7f 4f       	sbci	r23, 0xFF	; 255

0000119c <__divmodhi4_exit>:
    119c:	08 95       	ret

0000119e <__udivmodhi4>:
    119e:	aa 1b       	sub	r26, r26
    11a0:	bb 1b       	sub	r27, r27
    11a2:	51 e1       	ldi	r21, 0x11	; 17
    11a4:	07 c0       	rjmp	.+14     	; 0x11b4 <__udivmodhi4_ep>

000011a6 <__udivmodhi4_loop>:
    11a6:	aa 1f       	adc	r26, r26
    11a8:	bb 1f       	adc	r27, r27
    11aa:	a6 17       	cp	r26, r22
    11ac:	b7 07       	cpc	r27, r23
    11ae:	10 f0       	brcs	.+4      	; 0x11b4 <__udivmodhi4_ep>
    11b0:	a6 1b       	sub	r26, r22
    11b2:	b7 0b       	sbc	r27, r23

000011b4 <__udivmodhi4_ep>:
    11b4:	88 1f       	adc	r24, r24
    11b6:	99 1f       	adc	r25, r25
    11b8:	5a 95       	dec	r21
    11ba:	a9 f7       	brne	.-22     	; 0x11a6 <__udivmodhi4_loop>
    11bc:	80 95       	com	r24
    11be:	90 95       	com	r25
    11c0:	bc 01       	movw	r22, r24
    11c2:	cd 01       	movw	r24, r26
    11c4:	08 95       	ret

000011c6 <_exit>:
    11c6:	f8 94       	cli

000011c8 <__stop_program>:
    11c8:	ff cf       	rjmp	.-2      	; 0x11c8 <__stop_program>
